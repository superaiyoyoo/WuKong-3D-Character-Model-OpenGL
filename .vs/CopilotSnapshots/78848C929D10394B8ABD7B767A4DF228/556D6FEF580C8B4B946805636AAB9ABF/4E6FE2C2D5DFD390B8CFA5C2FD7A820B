#include <Windows.h>
#include <gl/GL.h>
#include <gl/GLU.h>
#include <math.h>

#pragma comment (lib, "OpenGL32.lib")
#pragma comment (lib, "GLU32.lib")

#define WINDOW_TITLE "Black Myth Wukong - Armored Monkey King Warrior"
#define PI 3.14159f

// Global variables for camera control
float rotationX = 10.0f;
float rotationY = 0.0f;
float zoom = -15.0f;

// Forward declarations
void drawWukongMuscularLeg(bool isLeft);
void drawHighContrastArmoredPants(float legHeight);
void drawWukongOuterArmorLayer(float legHeight);
void drawEnhancedHeritageBootWithContrast(bool isLeft);
void drawBlackMythWukongCharacter(bool isLeft);
void drawDecorativeBowKnot();
void drawRealistic3DShoelaces();  // New forward declaration

// Function to draw Wukong-style muscular leg anatomy with enhanced color variations
void drawWukongMuscularLeg(bool isLeft) {
    glPushMatrix();

    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }

    // Enhanced skin tones for Wukong with depth variations
    GLfloat wukongSkinBase[] = { 0.85f, 0.7f, 0.45f, 1.0f };           // Base golden-brown
    GLfloat wukongSkinLight[] = { 0.92f, 0.78f, 0.52f, 1.0f };         // Lighter highlights
    GLfloat wukongSkinMid[] = { 0.78f, 0.63f, 0.38f, 1.0f };           // Mid-tone areas
    GLfloat wukongSkinDeep[] = { 0.68f, 0.53f, 0.28f, 1.0f };          // Deeper shadows
    GLfloat muscleDefinition[] = { 0.58f, 0.43f, 0.23f, 1.0f };        // Deep muscle definition
    GLfloat muscleHighlight[] = { 0.88f, 0.73f, 0.48f, 1.0f };         // Muscle highlights

    // --- ENHANCED UPPER THIGH (Much Larger and More Muscular) ---
    glColor3fv(wukongSkinBase);

    // Main upper thigh muscle mass
    glPushMatrix();
    glTranslatef(0.0f, 6.2f, 0.0f);
    glScalef(0.85f, 1.4f, 0.85f);
    GLUquadric* upperThigh = gluNewQuadric();
    gluSphere(upperThigh, 0.5, 20, 20);
    gluDeleteQuadric(upperThigh);
    glPopMatrix();

    // Quadriceps muscle definition with varying depths
    for (int i = 0; i < 3; i++) {
        float angle = (i - 1) * 0.3f;
        // Vary colors based on position for depth
        if (i == 0) glColor3fv(muscleDefinition);      // Deepest
        else if (i == 1) glColor3fv(wukongSkinMid);    // Mid-tone
        else glColor3fv(muscleHighlight);              // Highlighted

        glPushMatrix();
        glTranslatef(sinf(angle) * 0.25f, 6.1f, cosf(angle) * 0.15f + 0.2f);
        glScalef(0.15f, 0.6f, 0.2f);
        GLUquadric* quad = gluNewQuadric();
        gluSphere(quad, 0.5, 16, 16);
        gluDeleteQuadric(quad);
        glPopMatrix();
    }

    // --- ENHANCED MID THIGH (Larger and More Defined) ---
    glColor3fv(wukongSkinLight);  // Lighter tone for prominence
    glPushMatrix();
    glTranslatef(0.0f, 5.2f, 0.0f);
    glScalef(0.8f, 1.2f, 0.8f);
    GLUquadric* midThigh = gluNewQuadric();
    gluSphere(midThigh, 0.5, 20, 20);
    gluDeleteQuadric(midThigh);
    glPopMatrix();

    // Hamstring muscle definition
    glColor3fv(wukongSkinDeep);  // Deeper shadow tone
    glPushMatrix();
    glTranslatef(0.0f, 5.1f, -0.3f);
    glScalef(0.6f, 0.8f, 0.25f);
    GLUquadric* hamstring = gluNewQuadric();
    gluSphere(hamstring, 0.5, 16, 16);
    gluDeleteQuadric(hamstring);
    glPopMatrix();

    // --- ENHANCED KNEE AREA ---
    glColor3fv(wukongSkinMid);  // Mid-tone for natural transition
    glPushMatrix();
    glTranslatef(0.0f, 4.3f, 0.0f);
    glScalef(0.65f, 0.4f, 0.65f);
    GLUquadric* knee = gluNewQuadric();
    gluSphere(knee, 0.5, 16, 16);
    gluDeleteQuadric(knee);
    glPopMatrix();

    // --- ENHANCED CALF MUSCLES (Much More Defined) ---
    glColor3fv(wukongSkinBase);

    // Main calf muscle
    glPushMatrix();
    glTranslatef(0.0f, 3.8f, 0.1f);
    glScalef(0.55f, 0.9f, 0.7f);
    GLUquadric* calf = gluNewQuadric();
    gluSphere(calf, 0.5, 18, 18);
    gluDeleteQuadric(calf);
    glPopMatrix();

    // Gastrocnemius muscle definition with highlights
    glColor3fv(muscleHighlight);  // Highlighted muscle
    glPushMatrix();
    glTranslatef(0.0f, 3.7f, 0.2f);
    glScalef(0.35f, 0.7f, 0.4f);
    GLUquadric* gastrocnemius = gluNewQuadric();
    gluSphere(gastrocnemius, 0.5, 14, 14);
    gluDeleteQuadric(gastrocnemius);
    glPopMatrix();

    // Soleus muscle
    glColor3fv(muscleDefinition);  // Deep muscle definition
    glPushMatrix();
    glTranslatef(0.0f, 3.5f, -0.1f);
    glScalef(0.4f, 0.5f, 0.3f);
    GLUquadric* soleus = gluNewQuadric();
    gluSphere(soleus, 0.5, 14, 14);
    gluDeleteQuadric(soleus);
    glPopMatrix();

    // --- ENHANCED SHIN AREA ---
    glColor3fv(wukongSkinMid);
    glPushMatrix();
    glTranslatef(0.0f, 3.2f, 0.3f);
    glScalef(0.35f, 0.6f, 0.25f);
    GLUquadric* shin = gluNewQuadric();
    gluSphere(shin, 0.5, 14, 14);
    gluDeleteQuadric(shin);
    glPopMatrix();

    glPopMatrix();
}

// Enhanced function to draw high-contrast armored combat pants with depth variations
void drawHighContrastArmoredPants(float legHeight) {
    // Enhanced armored pants colors with depth variations
    GLfloat pantsBase[] = { 0.08f, 0.06f, 0.04f, 1.0f };           // Base very dark fabric
    GLfloat pantsHighlight[] = { 0.12f, 0.09f, 0.06f, 1.0f };      // Subtle highlights
    GLfloat pantsDeep[] = { 0.05f, 0.03f, 0.02f, 1.0f };           // Deepest shadows
    GLfloat armorBase[] = { 0.50f, 0.50f, 0.53f, 1.0f };           // Base steel gray
    GLfloat armorLight[] = { 0.62f, 0.62f, 0.65f, 1.0f };          // Lighter armor highlights
    GLfloat armorDeep[] = { 0.38f, 0.38f, 0.41f, 1.0f };           // Deeper armor shadows
    GLfloat rivetBase[] = { 0.40f, 0.40f, 0.42f, 1.0f };           // Base rivet color
    GLfloat rivetHighlight[] = { 0.52f, 0.52f, 0.54f, 1.0f };      // Highlighted rivets
    GLfloat rivetShadow[] = { 0.28f, 0.28f, 0.30f, 1.0f };         // Shadow rivets

    float pantsBottom = 4.2f;
    float pantsTop = pantsBottom + legHeight;

    // Draw main armored pants with depth variation
    int segments = 24;
    float angleStep = 2.0f * PI / segments;

    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        // Vary color based on position for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;  // 0 to 1 based on angle
        if (lightFactor > 0.6f) {
            glColor3fv(pantsHighlight);  // Highlighted areas
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(pantsDeep);       // Shadow areas
        }
        else {
            glColor3fv(pantsBase);       // Base areas
        }

        float bottomRadius = 0.26f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, pantsBottom, z * bottomRadius);

        float topRadius = 0.55f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, pantsTop, z * topRadius);
    }
    glEnd();

    // --- ENHANCED KNEE ARMOR PLATE with depth variations ---
    glColor3fv(armorBase);
    glPushMatrix();
    glTranslatef(0.0f, 5.2f, 0.18f);
    glScalef(0.35f, 0.25f, 0.12f);
    GLUquadric* kneePlate = gluNewQuadric();
    gluSphere(kneePlate, 1.0, 20, 16);
    gluDeleteQuadric(kneePlate);
    glPopMatrix();

    // Add armor highlights and shadows
    glColor3fv(armorLight);
    glPushMatrix();
    glTranslatef(0.05f, 5.25f, 0.22f);  // Slightly offset for highlight
    glScalef(0.15f, 0.12f, 0.06f);
    GLUquadric* kneeHighlight = gluNewQuadric();
    gluSphere(kneeHighlight, 1.0, 12, 8);
    gluDeleteQuadric(kneeHighlight);
    glPopMatrix();

    glColor3fv(armorDeep);
    glPushMatrix();
    glTranslatef(-0.05f, 5.15f, 0.16f);  // Shadow area
    glScalef(0.12f, 0.10f, 0.05f);
    GLUquadric* kneeShadow = gluNewQuadric();
    gluSphere(kneeShadow, 1.0, 12, 8);
    gluDeleteQuadric(kneeShadow);
    glPopMatrix();

    // Enhanced knee armor rivets with varied depth
    for (int i = 0; i < 10; i++) {
        float angle = i * 2.0f * PI / 10.0f;
        float x = sinf(angle) * 0.28f;
        float y = 5.2f + cosf(angle) * 0.18f;

        // Vary rivet colors for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(rivetHighlight);
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(rivetShadow);
        }
        else {
            glColor3fv(rivetBase);
        }

        glPushMatrix();
        glTranslatef(x, y, 0.23f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* rivet = gluNewQuadric();
        gluSphere(rivet, 1.0f, 8, 8);
        gluDeleteQuadric(rivet);
        glPopMatrix();
    }
}

// Function to draw Wukong-style outer armor layer with enhanced depth variations
void drawWukongOuterArmorLayer(float legHeight) {
    // Enhanced Wukong armor colors with rich depth variations
    GLfloat goldenBase[] = { 0.80f, 0.65f, 0.20f, 1.0f };         // Base golden armor
    GLfloat goldenLight[] = { 0.95f, 0.78f, 0.28f, 1.0f };        // Bright golden highlights
    GLfloat goldenMid[] = { 0.72f, 0.58f, 0.15f, 1.0f };          // Mid-tone golden
    GLfloat goldenDeep[] = { 0.58f, 0.45f, 0.10f, 1.0f };         // Deep golden shadows
    GLfloat bronzeBase[] = { 0.70f, 0.45f, 0.15f, 1.0f };         // Base bronze
    GLfloat bronzeLight[] = { 0.82f, 0.55f, 0.22f, 1.0f };        // Light bronze highlights
    GLfloat bronzeDeep[] = { 0.55f, 0.32f, 0.08f, 1.0f };         // Deep bronze shadows
    GLfloat darkMetalBase[] = { 0.15f, 0.12f, 0.10f, 1.0f };      // Base dark metal
    GLfloat darkMetalLight[] = { 0.22f, 0.18f, 0.15f, 1.0f };     // Lighter dark metal
    GLfloat jadeBase[] = { 0.20f, 0.60f, 0.30f, 1.0f };           // Base jade
    GLfloat jadeLight[] = { 0.28f, 0.75f, 0.40f, 1.0f };          // Light jade
    GLfloat jadeDeep[] = { 0.12f, 0.45f, 0.20f, 1.0f };           // Deep jade
    GLfloat redBase[] = { 0.80f, 0.20f, 0.10f, 1.0f };            // Base red
    GLfloat redLight[] = { 0.95f, 0.35f, 0.20f, 1.0f };           // Light red
    GLfloat redDeep[] = { 0.60f, 0.12f, 0.05f, 1.0f };            // Deep red

    float armorBottom = 3.8f;
    float armorTop = armorBottom + legHeight + 1.5f;

    // --- MAIN OUTER ARMOR SHELL with depth gradients ---
    int segments = 28;
    float angleStep = 2.0f * PI / segments;

    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        // Create depth through lighting simulation
        float lightFactor = (cosf(angle + PI * 0.3f) + 1.0f) * 0.5f;
        if (lightFactor > 0.7f) {
            glColor3fv(goldenLight);     // Bright highlights
        }
        else if (lightFactor > 0.4f) {
            glColor3fv(goldenBase);      // Mid tones
        }
        else if (lightFactor > 0.2f) {
            glColor3fv(goldenMid);       // Darker mid tones
        }
        else {
            glColor3fv(goldenDeep);      // Deep shadows
        }

        float bottomRadius = 0.4f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, armorBottom, z * bottomRadius);

        float topRadius = 0.7f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, armorTop, z * topRadius);
    }
    glEnd();

    // --- SEGMENTED ARMOR PLATES with rich depth variations ---
    for (int segment = 0; segment < 6; segment++) {
        float segmentHeight = armorBottom + 0.8f + (segment * 0.7f);
        float heightFactor = (float)segment / 5.0f;  // 0 to 1 from bottom to top

        // Vary golden armor based on height and position
        if (heightFactor > 0.6f) {
            glColor3fv(goldenLight);     // Upper segments brighter
        }
        else if (heightFactor > 0.3f) {
            glColor3fv(goldenBase);      // Middle segments
        }
        else {
            glColor3fv(goldenMid);       // Lower segments more subdued
        }

        glPushMatrix();
        glTranslatef(0.0f, segmentHeight, 0.0f);
        glRotatef(90, 1, 0, 0);
        glScalef(0.42f + (segment * 0.05f), 0.42f + (segment * 0.05f), 0.08f);
        GLUquadric* armorRing = gluNewQuadric();
        gluCylinder(armorRing, 1.0f, 1.0f, 1.0f, segments, 1);
        gluDeleteQuadric(armorRing);
        glPopMatrix();

        // Bronze decorative trim with depth variations
        if (segment % 2 == 0) {
            glColor3fv(bronzeLight);     // Alternating bright bronze
        }
        else {
            glColor3fv(bronzeBase);      // Alternating standard bronze
        }

        glPushMatrix();
        glTranslatef(0.0f, segmentHeight + 0.04f, 0.0f);
        glRotatef(90, 1, 0, 0);
        glScalef(0.44f + (segment * 0.05f), 0.44f + (segment * 0.05f), 0.02f);
        GLUquadric* trim = gluNewQuadric();
        gluCylinder(trim, 1.0f, 1.0f, 1.0f, segments, 1);
        gluDeleteQuadric(trim);
        glPopMatrix();
    }

    // --- ENHANCED KNEE ARMOR with rich depth ---
    glColor3fv(goldenBase);
    glPushMatrix();
    glTranslatef(0.0f, 4.8f, 0.3f);
    glScalef(0.5f, 0.35f, 0.18f);
    GLUquadric* kneeArmor = gluNewQuadric();
    gluSphere(kneeArmor, 1.0, 28, 24);
    gluDeleteQuadric(kneeArmor);
    glPopMatrix();

    // Add knee armor highlights
    glColor3fv(goldenLight);
    glPushMatrix();
    glTranslatef(0.08f, 4.85f, 0.35f);
    glScalef(0.2f, 0.15f, 0.08f);
    GLUquadric* kneeHighlight = gluNewQuadric();
    gluSphere(kneeHighlight, 1.0, 16, 12);
    gluDeleteQuadric(kneeHighlight);
    glPopMatrix();

    // Add knee armor shadows
    glColor3fv(goldenDeep);
    glPushMatrix();
    glTranslatef(-0.08f, 4.75f, 0.28f);
    glScalef(0.15f, 0.12f, 0.06f);
    GLUquadric* kneeShadow = gluNewQuadric();
    gluSphere(kneeShadow, 1.0, 16, 12);
    gluDeleteQuadric(kneeShadow);
    glPopMatrix();

    // Jade accents with depth variations
    for (int i = 0; i < 8; i++) {
        float angle = i * 2.0f * PI / 8.0f;
        float x = sinf(angle) * 0.35f;
        float z = cosf(angle) * 0.12f + 0.35f;

        // Vary jade colors for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(jadeLight);
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(jadeDeep);
        }
        else {
            glColor3fv(jadeBase);
        }

        glPushMatrix();
        glTranslatef(x, 4.8f, z);
        glScalef(0.03f, 0.03f, 0.03f);
        GLUquadric* jadeStud = gluNewQuadric();
        gluSphere(jadeStud, 1.0f, 10, 10);
        gluDeleteQuadric(jadeStud);
        glPopMatrix();
    }

    // --- DECORATIVE SIDE PANELS with enhanced depth ---
    for (int side = -1; side <= 1; side += 2) {
        // Main side panel with gradient
        if (side == -1) {
            glColor3fv(bronzeBase);      // Left side base bronze
        }
        else {
            glColor3fv(bronzeLight);     // Right side lighter bronze
        }

        glPushMatrix();
        glTranslatef(side * 0.45f, 5.5f, 0.1f);
        glScalef(0.15f, 1.8f, 0.3f);
        GLUquadric* sidePanel = gluNewQuadric();
        gluSphere(sidePanel, 1.0f, 20, 20);
        gluDeleteQuadric(sidePanel);
        glPopMatrix();

        // Decorative studs with varied depth
        for (int i = 0; i < 5; i++) {
            float y = 4.8f + i * 0.3f;
            float heightFactor = (float)i / 4.0f;

            // Vary red accents based on height
            if (heightFactor > 0.6f) {
                glColor3fv(redLight);
            }
            else if (heightFactor < 0.3f) {
                glColor3fv(redDeep);
            }
            else {
                glColor3fv(redBase);
            }

            glPushMatrix();
            glTranslatef(side * 0.45f, y, 0.2f);
            glScalef(0.04f, 0.04f, 0.04f);
            GLUquadric* stud = gluNewQuadric();
            gluSphere(stud, 1.0f, 12, 12);
            gluDeleteQuadric(stud);
            glPopMatrix();
        }
    }

    // --- DECORATIVE ENGRAVINGS with enhanced golden variations ---
    glDisable(GL_LIGHTING);
    glLineWidth(2.5f);

    // Cloud pattern engravings with depth variation
    for (int layer = 0; layer < 4; layer++) {
        float y = 4.5f + layer * 0.8f;
        float layerFactor = (float)layer / 3.0f;

        // Vary engraving brightness based on layer
        if (layerFactor > 0.6f) {
            glColor3f(0.98f, 0.85f, 0.35f);     // Brightest top layers
        }
        else if (layerFactor > 0.3f) {
            glColor3f(0.90f, 0.80f, 0.30f);     // Medium layers
        }
        else {
            glColor3f(0.82f, 0.72f, 0.25f);     // Deeper bottom layers
        }

        glBegin(GL_LINE_STRIP);
        for (int i = 0; i <= 20; i++) {
            float angle = i * 2.0f * PI / 20.0f;
            float radius = 0.3f + sinf(angle * 3.0f) * 0.05f;
            float x = cosf(angle) * radius;
            float z = sinf(angle) * radius * 0.7f + 0.2f;
            glVertex3f(x, y, z);
        }
        glEnd();
    }

    // Dragon scale pattern with depth variation
    for (int ring = 0; ring < 3; ring++) {
        float y = 5.2f + ring * 0.7f;
        float ringFactor = (float)ring / 2.0f;

        if (ringFactor > 0.6f) {
            glColor3f(0.95f, 0.82f, 0.32f);     // Bright upper scales
        }
        else {
            glColor3f(0.85f, 0.75f, 0.28f);     // Deeper lower scales
        }

        for (int scale = 0; scale < 12; scale++) {
            float angle = scale * 2.0f * PI / 12.0f;
            float x = cosf(angle) * 0.38f;
            float z = sinf(angle) * 0.25f + 0.15f;

            glBegin(GL_LINE_LOOP);
            for (int i = 0; i < 6; i++) {
                float scaleAngle = i * PI / 3.0f;
                float dx = cosf(scaleAngle) * 0.03f;
                float dz = sinf(scaleAngle) * 0.02f;
                glVertex3f(x + dx, y, z + dz);
            }
            glEnd();
        }
    }

    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);
}

// Function to draw treaded sole pattern
void drawTreadedSole() {
    glDisable(GL_LIGHTING);
    glLineWidth(2.0f);
    glColor3f(0.1f, 0.08f, 0.06f); // Very dark brown for treads

    // Draw horizontal tread lines
    for (int i = 0; i < 8; i++) {
        float z = -1.0f + (i * 0.25f);
        glBegin(GL_LINES);
        for (int j = 0; j < 6; j++) {
            float x = -0.3f + (j * 0.12f);
            glVertex3f(x, -0.82f, z);
            glVertex3f(x + 0.08f, -0.82f, z);
        }
        glEnd();
    }

    // Draw diagonal tread pattern
    for (int i = 0; i < 12; i++) {
        float z = -1.0f + (i * 0.15f);
        glBegin(GL_LINES);
        glVertex3f(-0.35f, -0.82f, z);
        glVertex3f(0.35f, -0.82f, z + 0.1f);
        glEnd();
    }

    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);
}

// Function to draw reinforced toe cap - simplified version
void drawReinforcedToeCap() {
    // This function is now integrated into the main boot function
}

// Function to draw speed hooks for quick lacing
void drawSpeedHooks() {
    GLfloat metalColor[] = { 0.7f, 0.7f, 0.7f, 1.0f }; // Metallic color
    glColor3fv(metalColor);

    for (int i = 0; i < 4; i++) { // INCREASED from 3 to 4 speed hooks for taller boots
        float y = 1.6f + i * 0.25f; // ADJUSTED spacing for taller boot

        // Left speed hook
        glPushMatrix();
        glTranslatef(-0.18f, y, 0.35f);
        glRotatef(90, 0, 1, 0);
        glScalef(0.025f, 0.1f, 0.025f); // Larger hooks
        GLUquadric* leftHook = gluNewQuadric();
        gluCylinder(leftHook, 1.0f, 1.0f, 1.0f, 8, 1);
        gluDeleteQuadric(leftHook);
        glPopMatrix();

        // Right speed hook
        glPushMatrix();
        glTranslatef(0.18f, y, 0.35f);
        glRotatef(90, 0, 1, 0);
        glScalef(0.025f, 0.1f, 0.025f); // Larger hooks
        GLUquadric* rightHook = gluNewQuadric();
        gluCylinder(rightHook, 1.0f, 1.0f, 1.0f, 8, 1);
        gluDeleteQuadric(rightHook);
        glPopMatrix();
    }
}

// Function to draw ankle support padding
void drawAnkleSupport() {
    GLfloat paddingColor[] = { 0.45f, 0.28f, 0.18f, 1.0f }; // Padded material
    glColor3fv(paddingColor);

    // Inner ankle padding
    glPushMatrix();
    glTranslatef(-0.25f, 0.8f, -0.1f);
    glScalef(0.12f, 0.4f, 0.3f);
    GLUquadric* innerPadding = gluNewQuadric();
    gluSphere(innerPadding, 0.5, 12, 12);
    gluDeleteQuadric(innerPadding);
    glPopMatrix();

    // Outer ankle padding
    glPushMatrix();
    glTranslatef(0.25f, 0.8f, -0.1f);
    glScalef(0.12f, 0.4f, 0.3f);
    GLUquadric* outerPadding = gluNewQuadric();
    gluSphere(outerPadding, 0.5, 12, 12);
    gluDeleteQuadric(outerPadding);
    glPopMatrix();
}

// Enhanced utility function to draw a curved boot shaft
void drawCurvedBootShaft(float height, float bottomRadius, float topRadius) {
    int segments = 20;
    float angleStep = 2.0f * PI / segments;

    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        // Bottom vertex
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, 0, z * bottomRadius);

        // Top vertex (slightly tapered and curved)
        float topX = x * topRadius;
        float topZ = z * topRadius * 0.9f; // Slightly flatten the back
        glNormal3f(x, 0, z);
        glVertex3f(topX, height, topZ);
    }
    glEnd();

    // Draw top cap
    glBegin(GL_TRIANGLE_FAN);
    glNormal3f(0, 1, 0);
    glVertex3f(0, height, 0); // Center point
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle) * topRadius;
        float z = sinf(angle) * topRadius * 0.9f;
        glVertex3f(x, height, z);
    }
    glEnd();
}

// Enhanced function to draw organic foot shape
void drawOrganicFootShape() {
    // Draw the main foot body using multiple scaled spheres for organic shape
    glPushMatrix();
    // Toe area
    glTranslatef(0.0f, 0.0f, 0.6f);
    glScalef(0.6f, 0.5f, 0.8f);
    GLUquadric* toe = gluNewQuadric();
    gluSphere(toe, 0.5, 16, 16);
    gluDeleteQuadric(toe);
    glPopMatrix();

    // Mid foot
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, 0.0f);
    glScalef(0.7f, 0.6f, 1.0f);
    GLUquadric* mid = gluNewQuadric();
    gluSphere(mid, 0.5, 16, 16);
    gluDeleteQuadric(mid);
    glPopMatrix();

    // Heel area
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, -0.6f);
    glScalef(0.65f, 0.55f, 0.7f);
    GLUquadric* heel = gluNewQuadric();
    gluSphere(heel, 0.5, 16, 16);
    gluDeleteQuadric(heel);
    glPopMatrix();
}

// Function to draw protective heel counter
void drawHeelCounter() {
    GLfloat counterColor[] = { 0.35f, 0.22f, 0.16f, 1.0f }; // Protective material
    glColor3fv(counterColor);

    glPushMatrix();
    glTranslatef(0.0f, 0.1f, -0.7f);
    glScalef(0.6f, 0.8f, 0.5f);
    GLUquadric* counter = gluNewQuadric();
    gluSphere(counter, 0.5, 16, 16);
    gluDeleteQuadric(counter);
    glPopMatrix();
}

// Function to draw realistic 3D shoelaces with proper X-pattern overlapping
void drawRealistic3DShoelaces() {
    // Enhanced lace colors with realistic variations
    GLfloat laceBase[] = { 0.18f, 0.12f, 0.07f, 1.0f };        // Rich dark leather base
    GLfloat laceHighlight[] = { 0.28f, 0.20f, 0.12f, 1.0f };   // Highlighted areas
    GLfloat laceShadow[] = { 0.12f, 0.08f, 0.04f, 1.0f };      // Shadow areas
    GLfloat laceOver[] = { 0.22f, 0.15f, 0.09f, 1.0f };        // Overlapping sections
    
    // Eyelet positions (6 pairs, from bottom to top)
    const int numEyelets = 6;
    float eyeletPositions[numEyelets];
    for (int i = 0; i < numEyelets; i++) {
        eyeletPositions[i] = 0.4f + i * 0.28f;
    }
    
    float eyeletLeftX = -0.18f;
    float eyeletRightX = 0.18f;
    float eyeletZ = 0.45f;
    float laceThickness = 0.022f;
    int laceResolution = 10;
    
    // Helper function to draw a single lace segment with proper 3D orientation
    auto drawLaceSegment = [&](float startX, float startY, float startZ, 
                              float endX, float endY, float endZ, 
                              GLfloat* color, float zOffset = 0.0f) {
        glColor3fv(color);
        
        // Calculate direction vector and length
        float dx = endX - startX;
        float dy = endY - startY;
        float dz = endZ - startZ;
        float length = sqrt(dx*dx + dy*dy + dz*dz);
        
        if (length < 0.001f) return; // Skip if too short
        
        glPushMatrix();
        
        // Position at start point with Z offset for layering
        glTranslatef(startX, startY, startZ + zOffset);
        
        // Calculate rotation angles for proper orientation
        float angleY = atan2(dx, dz) * 180.0f / PI;
        float angleX = -atan2(dy, sqrt(dx*dx + dz*dz)) * 180.0f / PI;
        
        glRotatef(angleY, 0, 1, 0);
        glRotatef(angleX, 1, 0, 0);
        
        // Draw the main lace cylinder
        GLUquadric* lace = gluNewQuadric();
        gluQuadricOrientation(lace, GLU_OUTSIDE);
        gluQuadricNormals(lace, GLU_SMOOTH);
        gluCylinder(lace, laceThickness, laceThickness, length, laceResolution, 1);
        
        // Add end caps for complete cylinder
        gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, length);
        gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
        glPopMatrix();
        
        gluDeleteQuadric(lace);
        glPopMatrix();
        
        // Add highlight stripe along the lace for realism
        glColor3fv(laceHighlight);
        glPushMatrix();
        glTranslatef(startX + dx * 0.1f, startY + dy * 0.1f, startZ + dz * 0.1f + zOffset + 0.01f);
        glRotatef(angleY, 0, 1, 0);
        glRotatef(angleX, 1, 0, 0);
        
        GLUquadric* highlight = gluNewQuadric();
        gluQuadricOrientation(highlight, GLU_OUTSIDE);
        gluCylinder(highlight, laceThickness * 0.3f, laceThickness * 0.3f, length * 0.8f, 6, 1);
        gluDeleteQuadric(highlight);
        glPopMatrix();
    };
    
    // Draw the complex X-pattern lacing with proper depth layering
    
    // === BOTTOM TO TOP DIAGONAL LACES (LEFT TO RIGHT) ===
    for (int i = 0; i < numEyelets - 1; i++) {
        float startY = eyeletPositions[i];
        float endY = eyeletPositions[i + 1];
        
        // Left-bottom to right-top diagonal (under layer)
        drawLaceSegment(eyeletLeftX, startY, eyeletZ, 
                       eyeletRightX, endY, eyeletZ, 
                       laceBase, 0.0f);
    }
    
    // === TOP TO BOTTOM DIAGONAL LACES (RIGHT TO LEFT) ===
    for (int i = 0; i < numEyelets - 1; i++) {
        float startY = eyeletPositions[i];
        float endY = eyeletPositions[i + 1];
        
        // Right-bottom to left-top diagonal (over layer)
        drawLaceSegment(eyeletRightX, startY, eyeletZ, 
                       eyeletLeftX, endY, eyeletZ, 
                       laceOver, 0.03f); // Higher Z for overlapping effect
    }
    
    // === HORIZONTAL CONNECTING SEGMENTS ===
    // These represent the lace going through eyelets horizontally
    for (int i = 1; i < numEyelets - 1; i += 2) { // 