#include <Windows.h>
#include <gl/GL.h>
#include <gl/GLU.h>
#include <math.h>

#pragma comment (lib, "OpenGL32.lib")
#pragma comment (lib, "GLU32.lib")

#define WINDOW_TITLE "Black Myth Wukong - Armored Monkey King Warrior"
#define PI 3.14159265359

// Global variables for camera control
float rotationX = 10.0f;
float rotationY = 0.0f;
float zoom = -15.0f;

// Forward declarations
void drawWukongMuscularLeg(bool isLeft);
void drawHighContrastArmoredPants(float legHeight);
void drawWukongOuterArmorLayer(float legHeight);
void drawEnhancedHeritageBootWithContrast(bool isLeft);
void drawBlackMythWukongCharacter(bool isLeft);

// Function to draw Wukong-style muscular leg anatomy with enhanced color variations
void drawWukongMuscularLeg(bool isLeft) {
    glPushMatrix();
    
    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }
    
    // Enhanced skin tones for Wukong with depth variations
    GLfloat wukongSkinBase[] = { 0.85f, 0.7f, 0.45f, 1.0f };           // Base golden-brown
    GLfloat wukongSkinLight[] = { 0.92f, 0.78f, 0.52f, 1.0f };         // Lighter highlights
    GLfloat wukongSkinMid[] = { 0.78f, 0.63f, 0.38f, 1.0f };           // Mid-tone areas
    GLfloat wukongSkinDeep[] = { 0.68f, 0.53f, 0.28f, 1.0f };          // Deeper shadows
    GLfloat muscleDefinition[] = { 0.58f, 0.43f, 0.23f, 1.0f };        // Deep muscle definition
    GLfloat muscleHighlight[] = { 0.88f, 0.73f, 0.48f, 1.0f };         // Muscle highlights
    
    // --- ENHANCED UPPER THIGH (Much Larger and More Muscular) ---
    glColor3fv(wukongSkinBase);
    
    // Main upper thigh muscle mass
    glPushMatrix();
    glTranslatef(0.0f, 6.2f, 0.0f);
    glScalef(0.85f, 1.4f, 0.85f);
    GLUquadric* upperThigh = gluNewQuadric();
    gluSphere(upperThigh, 0.5, 20, 20);
    gluDeleteQuadric(upperThigh);
    glPopMatrix();
    
    // Quadriceps muscle definition with varying depths
    for (int i = 0; i < 3; i++) {
        float angle = (i - 1) * 0.3f;
        // Vary colors based on position for depth
        if (i == 0) glColor3fv(muscleDefinition);      // Deepest
        else if (i == 1) glColor3fv(wukongSkinMid);    // Mid-tone
        else glColor3fv(muscleHighlight);              // Highlighted
        
        glPushMatrix();
        glTranslatef(sinf(angle) * 0.25f, 6.1f, cosf(angle) * 0.15f + 0.2f);
        glScalef(0.15f, 0.6f, 0.2f);
        GLUquadric* quad = gluNewQuadric();
        gluSphere(quad, 0.5, 16, 16);
        gluDeleteQuadric(quad);
        glPopMatrix();
    }
    
    // --- ENHANCED MID THIGH (Larger and More Defined) ---
    glColor3fv(wukongSkinLight);  // Lighter tone for prominence
    glPushMatrix();
    glTranslatef(0.0f, 5.2f, 0.0f);
    glScalef(0.8f, 1.2f, 0.8f);
    GLUquadric* midThigh = gluNewQuadric();
    gluSphere(midThigh, 0.5, 20, 20);
    gluDeleteQuadric(midThigh);
    glPopMatrix();
    
    // Hamstring muscle definition
    glColor3fv(wukongSkinDeep);  // Deeper shadow tone
    glPushMatrix();
    glTranslatef(0.0f, 5.1f, -0.3f);
    glScalef(0.6f, 0.8f, 0.25f);
    GLUquadric* hamstring = gluNewQuadric();
    gluSphere(hamstring, 0.5, 16, 16);
    gluDeleteQuadric(hamstring);
    glPopMatrix();
    
    // --- ENHANCED KNEE AREA ---
    glColor3fv(wukongSkinMid);  // Mid-tone for natural transition
    glPushMatrix();
    glTranslatef(0.0f, 4.3f, 0.0f);
    glScalef(0.65f, 0.4f, 0.65f);
    GLUquadric* knee = gluNewQuadric();
    gluSphere(knee, 0.5, 16, 16);
    gluDeleteQuadric(knee);
    glPopMatrix();
    
    // --- ENHANCED CALF MUSCLES (Much More Defined) ---
    glColor3fv(wukongSkinBase);
    
    // Main calf muscle
    glPushMatrix();
    glTranslatef(0.0f, 3.8f, 0.1f);
    glScalef(0.55f, 0.9f, 0.7f);
    GLUquadric* calf = gluNewQuadric();
    gluSphere(calf, 0.5, 18, 18);
    gluDeleteQuadric(calf);
    glPopMatrix();
    
    // Gastrocnemius muscle definition with highlights
    glColor3fv(muscleHighlight);  // Highlighted muscle
    glPushMatrix();
    glTranslatef(0.0f, 3.7f, 0.2f);
    glScalef(0.35f, 0.7f, 0.4f);
    GLUquadric* gastrocnemius = gluNewQuadric();
    gluSphere(gastrocnemius, 0.5, 14, 14);
    gluDeleteQuadric(gastrocnemius);
    glPopMatrix();
    
    // Soleus muscle
    glColor3fv(muscleDefinition);  // Deep muscle definition
    glPushMatrix();
    glTranslatef(0.0f, 3.5f, -0.1f);
    glScalef(0.4f, 0.5f, 0.3f);
    GLUquadric* soleus = gluNewQuadric();
    gluSphere(soleus, 0.5, 14, 14);
    gluDeleteQuadric(soleus);
    glPopMatrix();
    
    // --- ENHANCED SHIN AREA ---
    glColor3fv(wukongSkinMid);
    glPushMatrix();
    glTranslatef(0.0f, 3.2f, 0.3f);
    glScalef(0.35f, 0.6f, 0.25f);
    GLUquadric* shin = gluNewQuadric();
    gluSphere(shin, 0.5, 14, 14);
    gluDeleteQuadric(shin);
    glPopMatrix();
    
    glPopMatrix();
}

// Enhanced function to draw high-contrast armored combat pants with depth variations
void drawHighContrastArmoredPants(float legHeight) {
    // Enhanced armored pants colors with depth variations
    GLfloat pantsBase[] = { 0.08f, 0.06f, 0.04f, 1.0f };           // Base very dark fabric
    GLfloat pantsHighlight[] = { 0.12f, 0.09f, 0.06f, 1.0f };      // Subtle highlights
    GLfloat pantsDeep[] = { 0.05f, 0.03f, 0.02f, 1.0f };           // Deepest shadows
    GLfloat armorBase[] = { 0.50f, 0.50f, 0.53f, 1.0f };           // Base steel gray
    GLfloat armorLight[] = { 0.62f, 0.62f, 0.65f, 1.0f };          // Lighter armor highlights
    GLfloat armorDeep[] = { 0.38f, 0.38f, 0.41f, 1.0f };           // Deeper armor shadows
    GLfloat rivetBase[] = { 0.40f, 0.40f, 0.42f, 1.0f };           // Base rivet color
    GLfloat rivetHighlight[] = { 0.52f, 0.52f, 0.54f, 1.0f };      // Highlighted rivets
    GLfloat rivetShadow[] = { 0.28f, 0.28f, 0.30f, 1.0f };         // Shadow rivets
    
    float pantsBottom = 4.2f;
    float pantsTop = pantsBottom + legHeight;
    
    // Draw main armored pants with depth variation
    int segments = 24;
    float angleStep = 2.0f * PI / segments;
    
    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);
        
        // Vary color based on position for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;  // 0 to 1 based on angle
        if (lightFactor > 0.6f) {
            glColor3fv(pantsHighlight);  // Highlighted areas
        } else if (lightFactor < 0.3f) {
            glColor3fv(pantsDeep);       // Shadow areas
        } else {
            glColor3fv(pantsBase);       // Base areas
        }
        
        float bottomRadius = 0.26f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, pantsBottom, z * bottomRadius);
        
        float topRadius = 0.55f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, pantsTop, z * topRadius);
    }
    glEnd();
    
    // --- ENHANCED KNEE ARMOR PLATE with depth variations ---
    glColor3fv(armorBase);
    glPushMatrix();
    glTranslatef(0.0f, 5.2f, 0.18f);
    glScalef(0.35f, 0.25f, 0.12f);
    GLUquadric* kneePlate = gluNewQuadric();
    gluSphere(kneePlate, 1.0, 20, 16);
    gluDeleteQuadric(kneePlate);
    glPopMatrix();
    
    // Add armor highlights and shadows
    glColor3fv(armorLight);
    glPushMatrix();
    glTranslatef(0.05f, 5.25f, 0.22f);  // Slightly offset for highlight
    glScalef(0.15f, 0.12f, 0.06f);
    GLUquadric* kneeHighlight = gluNewQuadric();
    gluSphere(kneeHighlight, 1.0, 12, 8);
    gluDeleteQuadric(kneeHighlight);
    glPopMatrix();
    
    glColor3fv(armorDeep);
    glPushMatrix();
    glTranslatef(-0.05f, 5.15f, 0.16f);  // Shadow area
    glScalef(0.12f, 0.10f, 0.05f);
    GLUquadric* kneeShadow = gluNewQuadric();
    gluSphere(kneeShadow, 1.0, 12, 8);
    gluDeleteQuadric(kneeShadow);
    glPopMatrix();
    
    // Enhanced knee armor rivets with varied depth
    for (int i = 0; i < 10; i++) {
        float angle = i * 2.0f * PI / 10.0f;
        float x = sinf(angle) * 0.28f;
        float y = 5.2f + cosf(angle) * 0.18f;
        
        // Vary rivet colors for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(rivetHighlight);
        } else if (lightFactor < 0.3f) {
            glColor3fv(rivetShadow);
        } else {
            glColor3fv(rivetBase);
        }
        
        glPushMatrix();
        glTranslatef(x, y, 0.23f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* rivet = gluNewQuadric();
        gluSphere(rivet, 1.0f, 8, 8);
        gluDeleteQuadric(rivet);
        glPopMatrix();
    }
}

// Function to draw Wukong-style outer armor layer with enhanced depth variations
void drawWukongOuterArmorLayer(float legHeight) {
    // Enhanced Wukong armor colors with rich depth variations
    GLfloat goldenBase[] = { 0.80f, 0.65f, 0.20f, 1.0f };         // Base golden armor
    GLfloat goldenLight[] = { 0.95f, 0.78f, 0.28f, 1.0f };        // Bright golden highlights
    GLfloat goldenMid[] = { 0.72f, 0.58f, 0.15f, 1.0f };          // Mid-tone golden
    GLfloat goldenDeep[] = { 0.58f, 0.45f, 0.10f, 1.0f };         // Deep golden shadows
    GLfloat bronzeBase[] = { 0.70f, 0.45f, 0.15f, 1.0f };         // Base bronze
    GLfloat bronzeLight[] = { 0.82f, 0.55f, 0.22f, 1.0f };        // Light bronze highlights
    GLfloat bronzeDeep[] = { 0.55f, 0.32f, 0.08f, 1.0f };         // Deep bronze shadows
    GLfloat darkMetalBase[] = { 0.15f, 0.12f, 0.10f, 1.0f };      // Base dark metal
    GLfloat darkMetalLight[] = { 0.22f, 0.18f, 0.15f, 1.0f };     // Lighter dark metal
    GLfloat jadeBase[] = { 0.20f, 0.60f, 0.30f, 1.0f };           // Base jade
    GLfloat jadeLight[] = { 0.28f, 0.75f, 0.40f, 1.0f };          // Light jade
    GLfloat jadeDeep[] = { 0.12f, 0.45f, 0.20f, 1.0f };           // Deep jade
    GLfloat redBase[] = { 0.80f, 0.20f, 0.10f, 1.0f };            // Base red
    GLfloat redLight[] = { 0.95f, 0.35f, 0.20f, 1.0f };           // Light red
    GLfloat redDeep[] = { 0.60f, 0.12f, 0.05f, 1.0f };            // Deep red
    
    float armorBottom = 3.8f;
    float armorTop = armorBottom + legHeight + 1.5f;
    
    // --- MAIN OUTER ARMOR SHELL with depth gradients ---
    int segments = 28;
    float angleStep = 2.0f * PI / segments;
    
    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);
        
        // Create depth through lighting simulation
        float lightFactor = (cosf(angle + PI * 0.3f) + 1.0f) * 0.5f;
        if (lightFactor > 0.7f) {
            glColor3fv(goldenLight);     // Bright highlights
        } else if (lightFactor > 0.4f) {
            glColor3fv(goldenBase);      // Mid tones
        } else if (lightFactor > 0.2f) {
            glColor3fv(goldenMid);       // Darker mid tones
        } else {
            glColor3fv(goldenDeep);      // Deep shadows
        }
        
        float bottomRadius = 0.4f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, armorBottom, z * bottomRadius);
        
        float topRadius = 0.7f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, armorTop, z * topRadius);
    }
    glEnd();
    
    // --- SEGMENTED ARMOR PLATES with rich depth variations ---
    for (int segment = 0; segment < 6; segment++) {
        float segmentHeight = armorBottom + 0.8f + (segment * 0.7f);
        float heightFactor = (float)segment / 5.0f;  // 0 to 1 from bottom to top
        
        // Vary golden armor based on height and position
        if (heightFactor > 0.6f) {
            glColor3fv(goldenLight);     // Upper segments brighter
        } else if (heightFactor > 0.3f) {
            glColor3fv(goldenBase);      // Middle segments
        } else {
            glColor3fv(goldenMid);       // Lower segments more subdued
        }
        
        glPushMatrix();
        glTranslatef(0.0f, segmentHeight, 0.0f);
        glRotatef(90, 1, 0, 0);
        glScalef(0.42f + (segment * 0.05f), 0.42f + (segment * 0.05f), 0.08f);
        GLUquadric* armorRing = gluNewQuadric();
        gluCylinder(armorRing, 1.0f, 1.0f, 1.0f, segments, 1);
        gluDeleteQuadric(armorRing);
        glPopMatrix();
        
        // Bronze decorative trim with depth variations
        if (segment % 2 == 0) {
            glColor3fv(bronzeLight);     // Alternating bright bronze
        } else {
            glColor3fv(bronzeBase);      // Alternating standard bronze
        }
        
        glPushMatrix();
        glTranslatef(0.0f, segmentHeight + 0.04f, 0.0f);
        glRotatef(90, 1, 0, 0);
        glScalef(0.44f + (segment * 0.05f), 0.44f + (segment * 0.05f), 0.02f);
        GLUquadric* trim = gluNewQuadric();
        gluCylinder(trim, 1.0f, 1.0f, 1.0f, segments, 1);
        gluDeleteQuadric(trim);
        glPopMatrix();
    }
    
    // --- ENHANCED KNEE ARMOR with rich depth ---
    glColor3fv(goldenBase);
    glPushMatrix();
    glTranslatef(0.0f, 4.8f, 0.3f);
    glScalef(0.5f, 0.35f, 0.18f);
    GLUquadric* kneeArmor = gluNewQuadric();
    gluSphere(kneeArmor, 1.0, 28, 24);
    gluDeleteQuadric(kneeArmor);
    glPopMatrix();
    
    // Add knee armor highlights
    glColor3fv(goldenLight);
    glPushMatrix();
    glTranslatef(0.08f, 4.85f, 0.35f);
    glScalef(0.2f, 0.15f, 0.08f);
    GLUquadric* kneeHighlight = gluNewQuadric();
    gluSphere(kneeHighlight, 1.0, 16, 12);
    gluDeleteQuadric(kneeHighlight);
    glPopMatrix();
    
    // Add knee armor shadows
    glColor3fv(goldenDeep);
    glPushMatrix();
    glTranslatef(-0.08f, 4.75f, 0.28f);
    glScalef(0.15f, 0.12f, 0.06f);
    GLUquadric* kneeShadow = gluNewQuadric();
    gluSphere(kneeShadow, 1.0, 16, 12);
    gluDeleteQuadric(kneeShadow);
    glPopMatrix();
    
    // Jade accents with depth variations
    for (int i = 0; i < 8; i++) {
        float angle = i * 2.0f * PI / 8.0f;
        float x = sinf(angle) * 0.35f;
        float z = cosf(angle) * 0.12f + 0.35f;
        
        // Vary jade colors for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(jadeLight);
        } else if (lightFactor < 0.3f) {
            glColor3fv(jadeDeep);
        } else {
            glColor3fv(jadeBase);
        }
        
        glPushMatrix();
        glTranslatef(x, 4.8f, z);
        glScalef(0.03f, 0.03f, 0.03f);
        GLUquadric* jadeStud = gluNewQuadric();
        gluSphere(jadeStud, 1.0f, 10, 10);
        gluDeleteQuadric(jadeStud);
        glPopMatrix();
    }
    
    // --- DECORATIVE SIDE PANELS with enhanced depth ---
    for (int side = -1; side <= 1; side += 2) {
        // Main side panel with gradient
        if (side == -1) {
            glColor3fv(bronzeBase);      // Left side base bronze
        } else {
            glColor3fv(bronzeLight);     // Right side lighter bronze
        }
        
        glPushMatrix();
        glTranslatef(side * 0.45f, 5.5f, 0.1f);
        glScalef(0.15f, 1.8f, 0.3f);
        GLUquadric* sidePanel = gluNewQuadric();
        gluSphere(sidePanel, 1.0f, 20, 20);
        gluDeleteQuadric(sidePanel);
        glPopMatrix();
        
        // Decorative studs with varied depth
        for (int i = 0; i < 5; i++) {
            float y = 4.8f + i * 0.3f;
            float heightFactor = (float)i / 4.0f;
            
            // Vary red accents based on height
            if (heightFactor > 0.6f) {
                glColor3fv(redLight);
            } else if (heightFactor < 0.3f) {
                glColor3fv(redDeep);
            } else {
                glColor3fv(redBase);
            }
            
            glPushMatrix();
            glTranslatef(side * 0.45f, y, 0.2f);
            glScalef(0.04f, 0.04f, 0.04f);
            GLUquadric* stud = gluNewQuadric();
            gluSphere(stud, 1.0f, 12, 12);
            gluDeleteQuadric(stud);
            glPopMatrix();
        }
    }
    
    // --- DECORATIVE ENGRAVINGS with enhanced golden variations ---
    glDisable(GL_LIGHTING);
    glLineWidth(2.5f);
    
    // Cloud pattern engravings with depth variation
    for (int layer = 0; layer < 4; layer++) {
        float y = 4.5f + layer * 0.8f;
        float layerFactor = (float)layer / 3.0f;
        
        // Vary engraving brightness based on layer
        if (layerFactor > 0.6f) {
            glColor3f(0.98f, 0.85f, 0.35f);     // Brightest top layers
        } else if (layerFactor > 0.3f) {
            glColor3f(0.90f, 0.80f, 0.30f);     // Medium layers
        } else {
            glColor3f(0.82f, 0.72f, 0.25f);     // Deeper bottom layers
        }
        
        glBegin(GL_LINE_STRIP);
        for (int i = 0; i <= 20; i++) {
            float angle = i * 2.0f * PI / 20.0f;
            float radius = 0.3f + sinf(angle * 3.0f) * 0.05f;
            float x = cosf(angle) * radius;
            float z = sinf(angle) * radius * 0.7f + 0.2f;
            glVertex3f(x, y, z);
        }
        glEnd();
    }
    
    // Dragon scale pattern with depth variation
    for (int ring = 0; ring < 3; ring++) {
        float y = 5.2f + ring * 0.7f;
        float ringFactor = (float)ring / 2.0f;
        
        if (ringFactor > 0.6f) {
            glColor3f(0.95f, 0.82f, 0.32f);     // Bright upper scales
        } else {
            glColor3f(0.85f, 0.75f, 0.28f);     // Deeper lower scales
        }
        
        for (int scale = 0; scale < 12; scale++) {
            float angle = scale * 2.0f * PI / 12.0f;
            float x = cosf(angle) * 0.38f;
            float z = sinf(angle) * 0.25f + 0.15f;
            
            glBegin(GL_LINE_LOOP);
            for (int i = 0; i < 6; i++) {
                float scaleAngle = i * PI / 3.0f;
                float dx = cosf(scaleAngle) * 0.03f;
                float dz = sinf(scaleAngle) * 0.02f;
                glVertex3f(x + dx, y, z + dz);
            }
            glEnd();
        }
    }
    
    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);
}

// Function to draw treaded sole pattern
void drawTreadedSole() {
    glDisable(GL_LIGHTING);
    glLineWidth(2.0f);
    glColor3f(0.1f, 0.08f, 0.06f); // Very dark brown for treads
    
    // Draw horizontal tread lines
    for (int i = 0; i < 8; i++) {
        float z = -1.0f + (i * 0.25f);
        glBegin(GL_LINES);
        for (int j = 0; j < 6; j++) {
            float x = -0.3f + (j * 0.12f);
            glVertex3f(x, -0.82f, z);
            glVertex3f(x + 0.08f, -0.82f, z);
        }
        glEnd();
    }
    
    // Draw diagonal tread pattern
    for (int i = 0; i < 12; i++) {
        float z = -1.0f + (i * 0.15f);
        glBegin(GL_LINES);
        glVertex3f(-0.35f, -0.82f, z);
        glVertex3f(0.35f, -0.82f, z + 0.1f);
        glEnd();
    }
    
    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);
}

// Function to draw reinforced toe cap
void drawReinforcedToeCap() {
    GLfloat reinforcementColor[] = { 0.3f, 0.2f, 0.15f, 1.0f }; // Darker protective material
    glColor3fv(reinforcementColor);
    
    glPushMatrix();
    glTranslatef(0.0f, -0.15f, 0.7f);
    glScalef(0.65f, 0.4f, 0.6f);
    GLUquadric* toeCap = gluNewQuadric();
    gluSphere(toeCap, 0.5, 16, 16);
    gluDeleteQuadric(toeCap);
    glPopMatrix();
    
    // Add toe cap stitching
    glDisable(GL_LIGHTING);
    glColor3f(0.7f, 0.6f, 0.4f); // Tan stitching
    glLineWidth(2.5f);
    glBegin(GL_LINE_LOOP);
    for (int i = 0; i <= 15; i++) {
        float angle = (i - 7.5f) * 0.12f;
        float x = sinf(angle) * 0.4f;
        float y = -0.05f;
        float z = cosf(angle) * 0.25f + 0.5f;
        glVertex3f(x, y, z);
    }
    glEnd();
    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);
}

// Function to draw speed hooks for quick lacing
void drawSpeedHooks() {
    GLfloat metalColor[] = { 0.7f, 0.7f, 0.7f, 1.0f }; // Metallic color
    glColor3fv(metalColor);
    
    for (int i = 0; i < 4; i++) { // INCREASED from 3 to 4 speed hooks for taller boots
        float y = 1.6f + i * 0.25f; // ADJUSTED spacing for taller boot
        
        // Left speed hook
        glPushMatrix();
        glTranslatef(-0.18f, y, 0.35f);
        glRotatef(90, 0, 1, 0);
        glScalef(0.025f, 0.1f, 0.025f); // Larger hooks
        GLUquadric* leftHook = gluNewQuadric();
        gluCylinder(leftHook, 1.0f, 1.0f, 1.0f, 8, 1);
        gluDeleteQuadric(leftHook);
        glPopMatrix();
        
        // Right speed hook
        glPushMatrix();
        glTranslatef(0.18f, y, 0.35f);
        glRotatef(90, 0, 1, 0);
        glScalef(0.025f, 0.1f, 0.025f); // Larger hooks
        GLUquadric* rightHook = gluNewQuadric();
        gluCylinder(rightHook, 1.0f, 1.0f, 1.0f, 8, 1);
        gluDeleteQuadric(rightHook);
        glPopMatrix();
    }
}

// Function to draw ankle support padding
void drawAnkleSupport() {
    GLfloat paddingColor[] = { 0.45f, 0.28f, 0.18f, 1.0f }; // Padded material
    glColor3fv(paddingColor);
    
    // Inner ankle padding
    glPushMatrix();
    glTranslatef(-0.25f, 0.8f, -0.1f);
    glScalef(0.12f, 0.4f, 0.3f);
    GLUquadric* innerPadding = gluNewQuadric();
    gluSphere(innerPadding, 0.5, 12, 12);
    gluDeleteQuadric(innerPadding);
    glPopMatrix();
    
    // Outer ankle padding
    glPushMatrix();
    glTranslatef(0.25f, 0.8f, -0.1f);
    glScalef(0.12f, 0.4f, 0.3f);
    GLUquadric* outerPadding = gluNewQuadric();
    gluSphere(outerPadding, 0.5, 12, 12);
    gluDeleteQuadric(outerPadding);
    glPopMatrix();
}

// Enhanced utility function to draw a curved boot shaft
void drawCurvedBootShaft(float height, float bottomRadius, float topRadius) {
    int segments = 20;
    float angleStep = 2.0f * PI / segments;
    
    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);
        
        // Bottom vertex
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, 0, z * bottomRadius);
        
        // Top vertex (slightly tapered and curved)
        float topX = x * topRadius;
        float topZ = z * topRadius * 0.9f; // Slightly flatten the back
        glNormal3f(x, 0, z);
        glVertex3f(topX, height, topZ);
    }
    glEnd();
    
    // Draw top cap
    glBegin(GL_TRIANGLE_FAN);
    glNormal3f(0, 1, 0);
    glVertex3f(0, height, 0); // Center point
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle) * topRadius;
        float z = sinf(angle) * topRadius * 0.9f;
        glVertex3f(x, height, z);
    }
    glEnd();
}

// Enhanced function to draw organic foot shape
void drawOrganicFootShape() {
    // Draw the main foot body using multiple scaled spheres for organic shape
    glPushMatrix();
    // Toe area
    glTranslatef(0.0f, 0.0f, 0.6f);
    glScalef(0.6f, 0.5f, 0.8f);
    GLUquadric* toe = gluNewQuadric();
    gluSphere(toe, 0.5, 16, 16);
    gluDeleteQuadric(toe);
    glPopMatrix();
    
    // Mid foot
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, 0.0f);
    glScalef(0.7f, 0.6f, 1.0f);
    GLUquadric* mid = gluNewQuadric();
    gluSphere(mid, 0.5, 16, 16);
    gluDeleteQuadric(mid);
    glPopMatrix();
    
    // Heel area
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, -0.6f);
    glScalef(0.65f, 0.55f, 0.7f);
    GLUquadric* heel = gluNewQuadric();
    gluSphere(heel, 0.5, 16, 16);
    gluDeleteQuadric(heel);
    glPopMatrix();
}

// Function to draw protective heel counter
void drawHeelCounter() {
    GLfloat counterColor[] = { 0.35f, 0.22f, 0.16f, 1.0f }; // Protective material
    glColor3fv(counterColor);
    
    glPushMatrix();
    glTranslatef(0.0f, 0.1f, -0.7f);
    glScalef(0.6f, 0.8f, 0.5f);
    GLUquadric* counter = gluNewQuadric();
    gluSphere(counter, 0.5, 16, 16);
    gluDeleteQuadric(counter);
    glPopMatrix();
}

// Enhanced function to draw enhanced heritage combat boot with rich depth variations
void drawEnhancedHeritageBootWithContrast(bool isLeft) {
    // Enhanced heritage colors with rich depth variations
    GLfloat soleBase[] = { 0.15f, 0.08f, 0.05f, 1.0f };           // Base dark sole
    GLfloat soleLight[] = { 0.22f, 0.12f, 0.08f, 1.0f };          // Lighter sole areas
    GLfloat soleDeep[] = { 0.10f, 0.05f, 0.03f, 1.0f };           // Deepest sole shadows
    GLfloat leatherBase[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Base rich leather
    GLfloat leatherLight[] = { 0.78f, 0.58f, 0.38f, 1.0f };       // Light leather highlights
    GLfloat leatherMid[] = { 0.58f, 0.38f, 0.22f, 1.0f };         // Mid-tone leather
    GLfloat leatherDeep[] = { 0.48f, 0.28f, 0.15f, 1.0f };        // Deep leather shadows
    GLfloat darkerBase[] = { 0.50f, 0.32f, 0.20f, 1.0f };         // Base darker panels
    GLfloat darkerLight[] = { 0.58f, 0.38f, 0.25f, 1.0f };        // Light darker panels
    GLfloat darkerDeep[] = { 0.40f, 0.24f, 0.14f, 1.0f };         // Deep darker panels
    GLfloat stitchBright[] = { 0.98f, 0.88f, 0.68f, 1.0f };       // Bright stitching
    GLfloat stitchMid[] = { 0.88f, 0.78f, 0.58f, 1.0f };          // Mid stitching
    GLfloat lacingBase[] = { 0.20f, 0.12f, 0.08f, 1.0f };         // Base lacing
    GLfloat lacingLight[] = { 0.28f, 0.18f, 0.12f, 1.0f };        // Light lacing
    GLfloat metalBase[] = { 0.80f, 0.80f, 0.82f, 1.0f };          // Base metal
    GLfloat metalLight[] = { 0.92f, 0.92f, 0.94f, 1.0f };         // Bright metal
    GLfloat metalDeep[] = { 0.65f, 0.65f, 0.67f, 1.0f };          // Deep metal
    
    glPushMatrix();

    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }

    // --- Enhanced Heritage Sole with depth variations ---
    glColor3fv(soleBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.8f, 0.1f);
    glScalef(0.8f, 0.12f, 2.4f);
    GLUquadric* sole = gluNewQuadric();
    gluSphere(sole, 0.5, 20, 20);
    gluDeleteQuadric(sole);
    glPopMatrix();

    // Add sole highlights and shadows
    glColor3fv(soleLight);
    glPushMatrix();
    glTranslatef(0.1f, -0.78f, 0.3f);  // Highlight area
    glScalef(0.3f, 0.06f, 0.8f);
    GLUquadric* soleHighlight = gluNewQuadric();
    gluSphere(soleHighlight, 0.5, 12, 12);
    gluDeleteQuadric(soleHighlight);
    glPopMatrix();

    glColor3fv(soleDeep);
    glPushMatrix();
    glTranslatef(-0.1f, -0.82f, -0.2f);  // Shadow area
    glScalef(0.25f, 0.04f, 0.6f);
    GLUquadric* soleShadow = gluNewQuadric();
    gluSphere(soleShadow, 0.5, 12, 12);
    gluDeleteQuadric(soleShadow);
    glPopMatrix();

    // Enhanced sole welt with depth
    GLfloat weltBase[] = { 0.45f, 0.28f, 0.18f, 1.0f };
    GLfloat weltLight[] = { 0.55f, 0.35f, 0.22f, 1.0f };
    glColor3fv(weltBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.68f, 0.1f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.82f, 2.5f, 0.05f);
    GLUquadric* welt = gluNewQuadric();
    gluCylinder(welt, 0.5, 0.5, 1.0, 24, 1);
    gluDeleteQuadric(welt);
    glPopMatrix();

    // Welt highlights
    glColor3fv(weltLight);
    glPushMatrix();
    glTranslatef(0.0f, -0.67f, 0.1f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.84f, 2.6f, 0.02f);
    GLUquadric* weltHighlight = gluNewQuadric();
    gluCylinder(weltHighlight, 0.5, 0.5, 1.0, 24, 1);
    gluDeleteQuadric(weltHighlight);
    glPopMatrix();

    // Enhanced welt stitching with depth
    glDisable(GL_LIGHTING);
    glColor3f(0.98f, 0.88f, 0.72f); // Bright stitching
    glLineWidth(3.5f);
    glBegin(GL_LINE_LOOP);
    for (int i = 0; i <= 30; i++) {
        float angle = i * 2.0f * PI / 30.0f;
        float x = cosf(angle) * 0.42f;
        float z = sinf(angle) * 1.2f;
        glVertex3f(x, -0.67f, z + 0.1f);
    }
    glEnd();
    
    // Add secondary stitching line
    glColor3f(0.85f, 0.75f, 0.55f); // Slightly darker secondary stitching
    glLineWidth(2.0f);
    glBegin(GL_LINE_LOOP);
    for (int i = 0; i <= 30; i++) {
        float angle = i * 2.0f * PI / 30.0f;
        float x = cosf(angle) * 0.40f;
        float z = sinf(angle) * 1.15f;
        glVertex3f(x, -0.69f, z + 0.1f);
    }
    glEnd();
    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);

    drawTreadedSole();

    // --- ENHANCED MILITARY HEEL with depth ---
    glColor3fv(soleBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.6f, -0.8f);
    glScalef(0.55f, 0.35f, 0.45f);
    GLUquadric* heel = gluNewQuadric();
    gluSphere(heel, 0.5, 12, 12);
    gluDeleteQuadric(heel);
    glPopMatrix();

    // Heel highlights and shadows
    glColor3fv(soleLight);
    glPushMatrix();
    glTranslatef(0.08f, -0.55f, -0.75f);
    glScalef(0.25f, 0.18f, 0.2f);
    GLUquadric* heelHighlight = gluNewQuadric();
    gluSphere(heelHighlight, 0.5, 8, 8);
    gluDeleteQuadric(heelHighlight);
    glPopMatrix();

    glColor3fv(soleDeep);
    glPushMatrix();
    glTranslatef(-0.08f, -0.55f, -0.85f);
    glScalef(0.2f, 0.15f, 0.1f);
    GLUquadric* heelShadow = gluNewQuadric();
    gluSphere(heelShadow, 0.5, 8, 8);
    gluDeleteQuadric(heelShadow);
    glPopMatrix();

    // --- MAIN FOOT BODY with rich depth variations ---
    glColor3fv(leatherBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.25f, 0.2f);
    drawOrganicFootShape();
    glPopMatrix();

    // Add leather highlights across the foot
    glColor3fv(leatherLight);
    glPushMatrix();
    glTranslatef(0.1f, -0.15f, 0.4f);  // Toe highlight
    glScalef(0.3f, 0.25f, 0.4f);
    GLUquadric* toeHighlight = gluNewQuadric();
    gluSphere(toeHighlight, 0.5, 12, 12);
    gluDeleteQuadric(toeHighlight);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.15f, -0.2f, 0.0f);  // Side highlight
    glScalef(0.25f, 0.3f, 0.5f);
    GLUquadric* sideHighlight = gluNewQuadric();
    gluSphere(sideHighlight, 0.5, 12, 12);
    gluDeleteQuadric(sideHighlight);
    glPopMatrix();

    // Add leather shadows
    glColor3fv(leatherDeep);
    glPushMatrix();
    glTranslatef(-0.15f, -0.3f, 0.1f);  // Side shadow
    glScalef(0.2f, 0.25f, 0.4f);
    GLUquadric* sideShadow = gluNewQuadric();
    gluSphere(sideShadow, 0.5, 12, 12);
    gluDeleteQuadric(sideShadow);
    glPopMatrix();

    // Enhanced leather grain texture with depth
    glDisable(GL_LIGHTING);
    glPointSize(1.5f);
    
    glBegin(GL_POINTS);
    for (int i = 0; i < 250; i++) {
        float x = ((i * 13) % 100 - 50) * 0.008f;
        float y = ((i * 17) % 200 - 50) * 0.008f;
        float z = ((i * 23) % 150 - 50) * 0.008f;
        
        if (x*x + z*z < 0.4f && y > -0.4f && y < 1.8f) {
            // Vary texture color based on position
            float lightFactor = (x + z + 1.0f) * 0.25f;
            if (lightFactor > 0.6f) {
                glColor3f(0.62f, 0.42f, 0.28f); // Lighter texture
            } else if (lightFactor < 0.3f) {
                glColor3f(0.45f, 0.28f, 0.16f); // Darker texture
            } else {
                glColor3f(0.55f, 0.35f, 0.22f); // Mid texture
            }
            glVertex3f(x, y, z);
        }
    }
    glEnd();
    glPointSize(1.0f);
    glEnable(GL_LIGHTING);

    drawReinforcedToeCap();

    // --- ENHANCED BOOT SHAFT with rich depth variations ---
    glColor3fv(leatherBase);
    glPushMatrix();
    glTranslatef(0.0f, 0.45f, -0.3f);
    drawCurvedBootShaft(2.7f, 0.52f, 0.44f);
    glPopMatrix();

    // Shaft highlights
    glColor3fv(leatherLight);
    glPushMatrix();
    glTranslatef(0.12f, 1.5f, -0.25f);  // Side highlight
    glScalef(0.15f, 1.2f, 0.3f);
    GLUquadric* shaftHighlight = gluNewQuadric();
    gluSphere(shaftHighlight, 0.5, 16, 16);
    gluDeleteQuadric(shaftHighlight);
    glPopMatrix();

    glColor3fv(leatherDeep);
    glPushMatrix();
    glTranslatef(-0.12f, 1.2f, -0.35f);  // Side shadow
    glScalef(0.12f, 1.0f, 0.25f);
    GLUquadric* shaftShadow = gluNewQuadric();
    gluSphere(shaftShadow, 0.5, 16, 16);
    gluDeleteQuadric(shaftShadow);
    glPopMatrix();

    drawHeelCounter();

    // --- HERITAGE CUFF with depth variations ---
    glColor3fv(darkerBase);
    glPushMatrix();
    glTranslatef(0.0f, 3.0f, -0.3f);
    glScalef(0.47f, 0.18f, 0.47f);
    GLUquadric* cuff = gluNewQuadric();
    gluSphere(cuff, 1.0f, 16, 16);
    gluDeleteQuadric(cuff);
    glPopMatrix();

    // Cuff highlights
    glColor3fv(darkerLight);
    glPushMatrix();
    glTranslatef(0.08f, 3.05f, -0.25f);
    glScalef(0.2f, 0.08f, 0.2f);
    GLUquadric* cuffHighlight = gluNewQuadric();
    gluSphere(cuffHighlight, 1.0f, 12, 12);
    gluDeleteQuadric(cuffHighlight);
    glPopMatrix();

    // --- ENHANCED PULL TAB with depth variations ---
    GLfloat tabBase[] = { 0.50f, 0.30f, 0.20f, 1.0f };
    GLfloat tabLight[] = { 0.62f, 0.38f, 0.26f, 1.0f };
    glColor3fv(tabBase);
    
    glPushMatrix();
    glTranslatef(0.0f, 2.8f, -0.45f);
    glScalef(0.15f, 0.25f, 0.08f);
    GLUquadric* tab = gluNewQuadric();
    gluSphere(tab, 0.5, 12, 12);
    gluDeleteQuadric(tab);
    glPopMatrix();

    // Tab highlight
    glColor3fv(tabLight);
    glPushMatrix();
    glTranslatef(0.02f, 2.85f, -0.42f);
    glScalef(0.08f, 0.12f, 0.04f);
    GLUquadric* tabHighlight = gluNewQuadric();
    gluSphere(tabHighlight, 0.5, 8, 8);
    gluDeleteQuadric(tabHighlight);
    glPopMatrix();

    // --- GUSSETED TONGUE with depth variations ---
    glColor3fv(leatherMid);  // Slightly different tone for contrast
    glPushMatrix();
    glTranslatef(0.0f, 0.25f, 0.65f);
    glRotatef(-8, 1, 0, 0);
    glScalef(0.32f, 0.06f, 0.85f);
    GLUquadric* tongue = gluNewQuadric();
    gluSphere(tongue, 0.5, 12, 12);
    gluDeleteQuadric(tongue);
    glPopMatrix();

    // Tongue highlights
    glColor3fv(leatherLight);
    glPushMatrix();
    glTranslatef(0.0f, 0.28f, 0.7f);
    glRotatef(-8, 1, 0, 0);
    glScalef(0.15f, 0.03f, 0.4f);
    GLUquadric* tongueHighlight = gluNewQuadric();
    gluSphere(tongueHighlight, 0.5, 8, 8);
    gluDeleteQuadric(tongueHighlight);
    glPopMatrix();

    // --- ENHANCED SIDE REINFORCEMENT PANELS with depth variations ---
    glColor3fv(darkerBase);
    // Left panel
    glPushMatrix();
    glTranslatef(-0.37f, 0.35f, 0.0f);
    glScalef(0.12f, 0.9f, 0.65f);
    GLUquadric* leftPanel = gluNewQuadric();
    gluSphere(leftPanel, 0.5, 12, 12);
    gluDeleteQuadric(leftPanel);
    glPopMatrix();
    
    // Left panel highlights
    glColor3fv(darkerLight);
    glPushMatrix();
    glTranslatef(-0.35f, 0.45f, 0.1f);
    glScalef(0.06f, 0.4f, 0.3f);
    GLUquadric* leftPanelHighlight = gluNewQuadric();
    gluSphere(leftPanelHighlight, 0.5, 8, 8);
    gluDeleteQuadric(leftPanelHighlight);
    glPopMatrix();
    
    // Right panel
    glColor3fv(darkerDeep);  // Slightly different depth for variation
    glPushMatrix();
    glTranslatef(0.37f, 0.35f, 0.0f);
    glScalef(0.12f, 0.9f, 0.65f);
    GLUquadric* rightPanel = gluNewQuadric();
    gluSphere(rightPanel, 0.5, 12, 12);
    gluDeleteQuadric(rightPanel);
    glPopMatrix();
    
    // Right panel highlights
    glColor3fv(darkerBase);
    glPushMatrix();
    glTranslatef(0.35f, 0.45f, 0.1f);
    glScalef(0.06f, 0.4f, 0.3f);
    GLUquadric* rightPanelHighlight = gluNewQuadric();
    gluSphere(rightPanelHighlight, 0.5, 8, 8);
    gluDeleteQuadric(rightPanelHighlight);
    glPopMatrix();

    // --- ENHANCED VENTILATION GROMMETS with depth ---
    for (int i = 0; i < 3; i++) {
        float y = 0.6f + i * 0.3f;
        float heightFactor = (float)i / 2.0f;
        
        // Vary grommet colors based on height
        if (heightFactor > 0.6f) {
            glColor3fv(metalLight);      // Bright upper grommets
        } else if (heightFactor < 0.3f) {
            glColor3fv(metalDeep);       // Deeper lower grommets
        } else {
            glColor3fv(metalBase);       // Mid-tone grommets
        }
        
        // Left grommets
        glPushMatrix();
        glTranslatef(-0.4f, y, 0.1f);
        glScalef(0.035f, 0.035f, 0.035f);
        GLUquadric* leftGrommet = gluNewQuadric();
        gluSphere(leftGrommet, 1.0f, 10, 10);
        gluDeleteQuadric(leftGrommet);
        glPopMatrix();
        
        // Right grommets
        glPushMatrix();
        glTranslatef(0.4f, y, 0.1f);
        glScalef(0.035f, 0.035f, 0.035f);
        GLUquadric* rightGrommet = gluNewQuadric();
        gluSphere(rightGrommet, 1.0f, 10, 10);
        gluDeleteQuadric(rightGrommet);
        glPopMatrix();
    }

    // --- ENHANCED HERITAGE STITCHING with depth variations ---
    glDisable(GL_LIGHTING);
    glLineWidth(3.5f);
    
    // Traditional side panel stitching with varying brightness
    glColor3f(0.98f, 0.88f, 0.68f); // Brightest stitching
    glBegin(GL_LINE_STRIP);
    glVertex3f(-0.45f, -0.1f, 0.5f);
    glVertex3f(-0.5f, 0.1f, 0.2f);
    glVertex3f(-0.45f, 0.3f, -0.1f);
    glEnd();
    
    glColor3f(0.90f, 0.80f, 0.60f); // Mid-bright stitching
    glBegin(GL_LINE_STRIP);
    glVertex3f(-0.4f, 0.5f, -0.3f);
    glVertex3f(-0.35f, 0.8f, -0.4f);
    glVertex3f(-0.32f, 1.2f, -0.4f);
    glEnd();
    
    glColor3f(0.85f, 0.75f, 0.55f); // Deeper stitching for upper areas
    glBegin(GL_LINE_STRIP);
    glVertex3f(-0.3f, 1.6f, -0.35f);
    glVertex3f(-0.28f, 2.0f, -0.3f);
    glVertex3f(-0.26f, 2.4f, -0.25f);
    glEnd();
    
    // Right side stitching with complementary depth
    glColor3f(0.95f, 0.85f, 0.65f); // Bright right stitching
    glBegin(GL_LINE_STRIP);
    glVertex3f(0.45f, -0.1f, 0.5f);
    glVertex3f(0.5f, 0.1f, 0.2f);
    glVertex3f(0.45f, 0.3f, -0.1f);
    glEnd();
    
    glColor3f(0.88f, 0.78f, 0.58f); // Mid-tone right stitching
    glBegin(GL_LINE_STRIP);
    glVertex3f(0.4f, 0.5f, -0.3f);
    glVertex3f(0.35f, 0.8f, -0.4f);
    glVertex3f(0.32f, 1.2f, -0.4f);
    glEnd();
    
    glColor3f(0.82f, 0.72f, 0.52f); // Deeper right upper stitching
    glBegin(GL_LINE_STRIP);
    glVertex3f(0.3f, 1.6f, -0.35f);
    glVertex3f(0.28f, 2.0f, -0.3f);
    glVertex3f(0.26f, 2.4f, -0.25f);
    glEnd();
    
    // Central heritage seam with gradient
    glColor3f(0.92f, 0.82f, 0.62f); // Bright center bottom
    glBegin(GL_LINE_STRIP);
    glVertex3f(0.0f, 0.3f, 0.6f);
    glVertex3f(0.0f, 0.5f, 0.3f);
    glVertex3f(0.0f, 0.7f, 0.0f);
    glEnd();
    
    glColor3f(0.86f, 0.76f, 0.56f); // Mid-tone center
    glBegin(GL_LINE_STRIP);
    glVertex3f(0.0f, 1.0f, -0.2f);
    glVertex3f(0.0f, 1.5f, -0.3f);
    glEnd();
    
    glColor3f(0.80f, 0.70f, 0.50f); // Deeper center top
    glBegin(GL_LINE_STRIP);
    glVertex3f(0.0f, 2.0f, -0.32f);
    glVertex3f(0.0f, 2.5f, -0.34f);
    glEnd();
    
    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);

    // --- Enhanced Boot Lacing System with depth ---
    GLfloat reinforcementBase[] = { 0.40f, 0.25f, 0.18f, 1.0f };
    GLfloat reinforcementLight[] = { 0.48f, 0.32f, 0.22f, 1.0f };
    GLfloat reinforcementDeep[] = { 0.32f, 0.18f, 0.12f, 1.0f };
    
    // Regular eyelets with depth variations
    for (int i = 0; i < 5; i++) {
        float y = 0.4f + i * 0.2f;
        float heightFactor = (float)i / 4.0f;
        
        // Vary eyelet colors based on height
        if (heightFactor > 0.6f) {
            glColor3fv(reinforcementLight);
        } else if (heightFactor < 0.3f) {
            glColor3fv(reinforcementDeep);
        } else {
            glColor3fv(reinforcementBase);
        }
        
        // Left eyelet
        glPushMatrix();
        glTranslatef(-0.16f, y, 0.42f);
        glScalef(0.045f, 0.045f, 0.045f);
        GLUquadric* eyelet1 = gluNewQuadric();
        gluSphere(eyelet1, 1.0f, 10, 10);
        gluDeleteQuadric(eyelet1);
        glPopMatrix();
        
        // Right eyelet
        glPushMatrix();
        glTranslatef(0.16f, y, 0.42f);
        glScalef(0.045f, 0.045f, 0.045f);
        GLUquadric* eyelet2 = gluNewQuadric();
        gluSphere(eyelet2, 1.0f, 10, 10);
        gluDeleteQuadric(eyelet2);
        glPopMatrix();
    }

    // --- Enhanced Eyelet Reinforcement Rings with depth ---
    for (int i = 0; i < 5; i++) {
        float y = 0.4f + i * 0.2f;
        float heightFactor = (float)i / 4.0f;
        
        // Vary metal ring colors
        if (heightFactor > 0.6f) {
            glColor3fv(metalLight);
        } else if (heightFactor < 0.3f) {
            glColor3fv(metalDeep);
        } else {
            glColor3fv(metalBase);
        }
        
        // Left ring
        glPushMatrix();
        glTranslatef(-0.16f, y, 0.42f);
        glRotatef(90, 0, 1, 0);
        glScalef(0.035f, 0.035f, 0.018f);
        GLUquadric* leftRing = gluNewQuadric();
        gluCylinder(leftRing, 1.0f, 1.0f, 1.0f, 12, 1);
        gluDeleteQuadric(leftRing);
        glPopMatrix();
        
        // Right ring
        glPushMatrix();
        glTranslatef(0.16f, y, 0.42f);
        glRotatef(90, 0, 1, 0);
        glScalef(0.035f, 0.035f, 0.018f);
        GLUquadric* rightRing = gluNewQuadric();
        gluCylinder(rightRing, 1.0f, 1.0f, 1.0f, 12, 1);
        gluDeleteQuadric(rightRing);
        glPopMatrix();
    }

    drawSpeedHooks();

    // --- ENHANCED HERITAGE LACING with depth variations ---
    glDisable(GL_LIGHTING);
    glLineWidth(5.5f);
    
    // Standard lacing pattern with varying depths
    for (int i = 0; i < 4; i++) {
        float y1 = 0.4f + i * 0.2f;
        float y2 = 0.4f + (i + 1) * 0.2f;
        float heightFactor = (float)i / 3.0f;
        
        // Vary lacing darkness based on height
        if (heightFactor > 0.6f) {
            glColor3f(0.18f, 0.10f, 0.06f); // Lighter upper lacing
        } else if (heightFactor < 0.3f) {
            glColor3f(0.12f, 0.06f, 0.04f); // Darker lower lacing
        } else {
            glColor3f(0.15f, 0.08f, 0.05f); // Mid-tone lacing
        }
        
        glBegin(GL_LINES);
        glVertex3f(-0.16f, y1, 0.44f);
        glVertex3f(0.16f, y2, 0.44f);
        glVertex3f(0.16f, y1, 0.44f);
        glVertex3f(-0.16f, y2, 0.44f);
        glEnd();
    }
    
    // Speed hook lacing with depth
    for (int i = 0; i < 3; i++) {
        float y1 = 1.6f + i * 0.25f;
        float y2 = 1.6f + (i + 1) * 0.25f;
        float heightFactor = (float)i / 2.0f;
        
        if (heightFactor > 0.5f) {
            glColor3f(0.22f, 0.14f, 0.09f); // Lighter upper speed lacing
        } else {
            glColor3f(0.16f, 0.09f, 0.06f); // Darker lower speed lacing
        }
        
        glBegin(GL_LINES);
        glVertex3f(-0.18f, y1, 0.37f);
        glVertex3f(0.18f, y2, 0.37f);
        glVertex3f(0.18f, y1, 0.37f);
        glVertex3f(-0.18f, y2, 0.37f);
        glEnd();
    }
    
    // Decorative lacing with gradient
    glLineWidth(3.5f);
    
    // Decorative cross-lacing with depth variation
    for (int i = 0; i < 5; i++) {
        float y = 0.4f + i * 0.2f;
        float heightFactor = (float)i / 4.0f;
        
        if (heightFactor > 0.6f) {
            glColor3f(0.14f, 0.07f, 0.05f); // Lighter decorative
        } else {
            glColor3f(0.10f, 0.05f, 0.03f); // Darker decorative
        }
        
        glBegin(GL_LINES);
        glVertex3f(-0.16f, y, 0.45f);
        glVertex3f(0.16f, y, 0.45f);
        glEnd();
    }
    
    // Upper boot decorative lacing
    for (int i = 0; i < 4; i++) {
        float y = 1.6f + i * 0.25f;
        float heightFactor = (float)i / 3.0f;
        
        if (heightFactor > 0.5f) {
            glColor3f(0.16f, 0.09f, 0.06f); // Lighter upper decorative
        } else {
            glColor3f(0.12f, 0.06f, 0.04f); // Darker lower decorative
        }
        
        glBegin(GL_LINES);
        glVertex3f(-0.18f, y, 0.38f);
        glVertex3f(0.18f, y, 0.38f);
        glEnd();
    }
    
    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);

    // --- ADD ENHANCED BROGUE DETAILING with depth variations ---
    GLfloat brogueBase[] = { 0.35f, 0.22f, 0.15f, 1.0f };
    GLfloat brogueLight[] = { 0.42f, 0.28f, 0.18f, 1.0f };
    GLfloat brogueDeep[] = { 0.28f, 0.16f, 0.10f, 1.0f };
    
    // Enhanced toe cap perforations with depth variation
    for (int i = 0; i < 15; i++) {
        float angle = (i - 7) * 0.08f;
        float x = sinf(angle) * 0.35f;
        float z = cosf(angle) * 0.2f + 0.45f;
        
        // Vary perforation colors based on position
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(brogueLight);
        } else if (lightFactor < 0.3f) {
            glColor3fv(brogueDeep);
        } else {
            glColor3fv(brogueBase);
        }
        
        glPushMatrix();
        glTranslatef(x, -0.08f, z);
        glScalef(0.025f, 0.025f, 0.025f);
        GLUquadric* perforation = gluNewQuadric();
        gluSphere(perforation, 1.0f, 8, 8);
        gluDeleteQuadric(perforation);
        glPopMatrix();
    }
}

// Function to draw realistic historical boot sole
void drawRealisticBootSole() {
    // Realistic dark leather sole colors
    GLfloat soleBase[] = { 0.12f, 0.08f, 0.06f, 1.0f };        // Dark brown leather sole
    GLfloat soleWorn[] = { 0.18f, 0.12f, 0.08f, 1.0f };        // Worn areas
    GLfloat soleEdge[] = { 0.08f, 0.05f, 0.03f, 1.0f };        // Dark edges
    
    glColor3fv(soleBase);
    
    // Main sole - realistic boot foot shape
    glPushMatrix();
    glTranslatef(0.0f, -0.85f, 0.0f);
    glScalef(0.7f, 0.1f, 2.2f);
    GLUquadric* sole = gluNewQuadric();
    gluSphere(sole, 0.5, 24, 24);
    gluDeleteQuadric(sole);
    glPopMatrix();
    
    // Heel section - realistic low heel
    glColor3fv(soleEdge);
    glPushMatrix();
    glTranslatef(0.0f, -0.75f, -0.9f);
    glScalef(0.6f, 0.25f, 0.4f);
    GLUquadric* heel = gluNewQuadric();
    gluSphere(heel, 0.5, 16, 16);
    gluDeleteQuadric(heel);
    glPopMatrix();
    
    // Worn areas on sole
    glColor3fv(soleWorn);
    glPushMatrix();
    glTranslatef(0.1f, -0.82f, 0.3f);  // Toe wear
    glScalef(0.3f, 0.05f, 0.6f);
    GLUquadric* toeWear = gluNewQuadric();
    gluSphere(toeWear, 0.5, 12, 12);
    gluDeleteQuadric(toeWear);
    glPopMatrix();
    
    glPushMatrix();
    glTranslatef(0.0f, -0.82f, -0.7f);  // Heel wear
    glScalef(0.4f, 0.05f, 0.3f);
    GLUquadric* heelWear = gluNewQuadric();
    gluSphere(heelWear, 0.5, 12, 12);
    gluDeleteQuadric(heelWear);
    glPopMatrix();
}

// Function to draw realistic boot foot section
void drawRealisticBootFoot() {
    // Realistic boot leather colors
    GLfloat leatherBase[] = { 0.25f, 0.18f, 0.12f, 1.0f };     // Dark brown leather
    GLfloat leatherMid[] = { 0.32f, 0.24f, 0.16f, 1.0f };      // Mid-tone leather
    GLfloat leatherLight[] = { 0.38f, 0.28f, 0.20f, 1.0f };    // Lighter worn areas
    GLfloat leatherDeep[] = { 0.18f, 0.12f, 0.08f, 1.0f };     // Deep creases
    
    // Main foot section - more realistic proportions
    glColor3fv(leatherBase);
    
    // Toe section
    glPushMatrix();
    glTranslatef(0.0f, -0.25f, 0.6f);
    glScalef(0.65f, 0.5f, 0.7f);
    GLUquadric* toe = gluNewQuadric();
    gluSphere(toe, 0.5, 20, 20);
    gluDeleteQuadric(toe);
    glPopMatrix();
    
    // Mid foot
    glColor3fv(leatherMid);
    glPushMatrix();
    glTranslatef(0.0f, -0.15f, 0.0f);
    glScalef(0.7f, 0.55f, 0.9f);
    GLUquadric* midFoot = gluNewQuadric();
    gluSphere(midFoot, 0.5, 20, 20);
    gluDeleteQuadric(midFoot);
    glPopMatrix();
    
    // Heel section
    glColor3fv(leatherBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.1f, -0.6f);
    glScalef(0.65f, 0.6f, 0.6f);
    GLUquadric* heelSection = gluNewQuadric();
    gluSphere(heelSection, 0.5, 20, 20);
    gluDeleteQuadric(heelSection);
    glPopMatrix();
    
    // Add realistic leather creases and wear marks
    glColor3fv(leatherDeep);
    
    // Toe crease
    glPushMatrix();
    glTranslatef(0.0f, -0.1f, 0.35f);
    glScalef(0.6f, 0.1f, 0.15f);
    GLUquadric* toeCrease = gluNewQuadric();
    gluSphere(toeCrease, 0.5, 16, 8);
    gluDeleteQuadric(toeCrease);
    glPopMatrix();
    
    // Side creases
    for (int side = -1; side <= 1; side += 2) {
        glPushMatrix();
        glTranslatef(side * 0.3f, -0.05f, 0.1f);
        glScalef(0.1f, 0.15f, 0.4f);
        GLUquadric* sideCrease = gluNewQuadric();
        gluSphere(sideCrease, 0.5, 12, 8);
        gluDeleteQuadric(sideCrease);
        glPopMatrix();
    }
}

// Function to draw realistic tall boot shaft
void drawRealisticBootShaft() {
    // Realistic boot shaft colors - darker and more muted
    GLfloat shaftBase[] = { 0.22f, 0.16f, 0.11f, 1.0f };       // Base shaft color
    GLfloat shaftMid[] = { 0.28f, 0.20f, 0.14f, 1.0f };        // Mid-tone areas
    GLfloat shaftLight[] = { 0.35f, 0.25f, 0.18f, 1.0f };      // Light wear areas
    GLfloat shaftDeep[] = { 0.16f, 0.11f, 0.07f, 1.0f };       // Deep creases
    
    glColor3fv(shaftBase);
    
    // Main tall shaft - realistic height (knee-high)
    int segments = 24;
    float angleStep = 2.0f * PI / segments;
    float shaftHeight = 3.2f;  // Realistic tall boot height
    
    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);
        
        // Create realistic lighting variation
        float lightFactor = (cosf(angle + PI * 0.25f) + 1.0f) * 0.5f;
        if (lightFactor > 0.7f) {
            glColor3fv(shaftLight);     // Highlighted areas
        } else if (lightFactor > 0.4f) {
            glColor3fv(shaftMid);       // Mid-tone areas
        } else if (lightFactor > 0.2f) {
            glColor3fv(shaftBase);      // Base color
        } else {
            glColor3fv(shaftDeep);      // Shadow areas
        }
        
        // Bottom of shaft (wider at ankle)
        float bottomRadius = 0.48f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, 0.3f, z * bottomRadius * 0.85f);
        
        // Top of shaft (gradually narrower toward knee)
        float topRadius = 0.42f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, shaftHeight, z * topRadius * 0.9f);
    }
    glEnd();
    
    // Add realistic vertical seam lines
    glDisable(GL_LIGHTING);
    glColor3f(0.15f, 0.10f, 0.06f); // Dark seam color
    glLineWidth(2.0f);
    
    // Back seam
    glBegin(GL_LINES);
    glVertex3f(0.0f, 0.3f, -0.41f);
    glVertex3f(0.0f, shaftHeight, -0.38f);
    glEnd();
    
    // Inner seam (subtle)
    glBegin(GL_LINES);
    glVertex3f(-0.42f, 0.3f, 0.0f);
    glVertex3f(-0.38f, shaftHeight, 0.0f);
    glEnd();
    
    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);
}

// Function to draw realistic folded boot cuff (like in the reference images)
void drawRealisticBootCuff() {
    GLfloat cuffBase[] = { 0.20f, 0.14f, 0.09f, 1.0f };        // Slightly darker cuff
    GLfloat cuffFold[] = { 0.26f, 0.18f, 0.12f, 1.0f };        // Fold highlight
    GLfloat cuffShadow[] = { 0.14f, 0.09f, 0.06f, 1.0f };      // Fold shadow
    
    float cuffHeight = 3.2f;
    float foldHeight = 0.35f;  // Height of the folded portion
    
    // Main cuff cylinder
    glColor3fv(cuffBase);
    glPushMatrix();
    glTranslatef(0.0f, cuffHeight, 0.0f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.44f, 0.4f, foldHeight);
    GLUquadric* cuffMain = gluNewQuadric();
    gluCylinder(cuffMain, 1.0f, 1.1f, 1.0f, 24, 1);  // Slightly flared
    gluDeleteQuadric(cuffMain);
    glPopMatrix();
    
    // Folded edge (like the reference images)
    glColor3fv(cuffFold);
    glPushMatrix();
    glTranslatef(0.0f, cuffHeight + foldHeight * 0.5f, 0.0f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.46f, 0.42f, 0.08f);
    GLUquadric* cuffFoldEdge = gluNewQuadric();
    gluCylinder(cuffFoldEdge, 1.0f, 1.0f, 1.0f, 24, 1);
    gluDeleteQuadric(cuffFoldEdge);
    glPopMatrix();
    
    // Inner fold shadow
    glColor3fv(cuffShadow);
    glPushMatrix();
    glTranslatef(0.0f, cuffHeight + 0.02f, 0.0f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.42f, 0.38f, 0.06f);
    GLUquadric* cuffShadowRing = gluNewQuadric();
    gluCylinder(cuffShadowRing, 1.0f, 1.0f, 1.0f, 24, 1);
    gluDeleteQuadric(cuffShadowRing);
    glPopMatrix();
    
    // Cuff top cap
    glColor3fv(cuffBase);
    glPushMatrix();
    glTranslatef(0.0f, cuffHeight + foldHeight, 0.0f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.46f, 0.42f, 0.02f);
    GLUquadric* cuffTop = gluNewQuadric();
    gluDisk(cuffTop, 0.0f, 1.0f, 24, 1);
    gluDeleteQuadric(cuffTop);
    glPopMatrix();
}

// Function to draw realistic side lacing (like in reference image 3)
void drawRealisticSideLacing() {
    GLfloat lacingColor[] = { 0.12f, 0.08f, 0.05f, 1.0f };     // Dark brown lacing
    GLfloat eyeletColor[] = { 0.18f, 0.14f, 0.10f, 1.0f };     // Eyelet reinforcement
    
    // Side lacing panel area
    glColor3fv(eyeletColor);
    glPushMatrix();
    glTranslatef(0.0f, 1.8f, 0.38f);  // Front-side position
    glScalef(0.25f, 1.4f, 0.1f);
    GLUquadric* lacingPanel = gluNewQuadric();
    gluSphere(lacingPanel, 0.5, 16, 16);
    gluDeleteQuadric(lacingPanel);
    glPopMatrix();
    
    // Side eyelets for lacing
    glColor3fv(eyeletColor);
    for (int i = 0; i < 8; i++) {  // 8 eyelets like in reference
        float y = 1.0f + i * 0.25f;
        
        // Left side eyelets
        glPushMatrix();
        glTranslatef(-0.1f, y, 0.40f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* leftEyelet = gluNewQuadric();
        gluSphere(leftEyelet, 1.0f, 8, 8);
        gluDeleteQuadric(leftEyelet);
        glPopMatrix();
        
        // Right side eyelets
        glPushMatrix();
        glTranslatef(0.1f, y, 0.40f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* rightEyelet = gluNewQuadric();
        gluSphere(rightEyelet, 1.0f, 8, 8);
        gluDeleteQuadric(rightEyelet);
        glPopMatrix();
    }
    
    // Realistic criss-cross lacing pattern
    glDisable(GL_LIGHTING);
    glColor3f(0.08f, 0.05f, 0.03f); // Very dark lacing
    glLineWidth(3.0f);
    
    for (int i = 0; i < 7; i++) {
        float y1 = 1.0f + i * 0.25f;
        float y2 = 1.0f + (i + 1) * 0.25f;
        
        // Criss-cross pattern
        glBegin(GL_LINES);
        glVertex3f(-0.1f, y1, 0.41f);
        glVertex3f(0.1f, y2, 0.41f);
        glVertex3f(0.1f, y1, 0.41f);
        glVertex3f(-0.1f, y2, 0.41f);
        glEnd();
    }
    
    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);
}

// Function to draw realistic button details (like in reference images)
void drawRealisticBootButtons() {
    GLfloat buttonColor[] = { 0.15f, 0.12f, 0.08f, 1.0f };     // Dark button color
    GLfloat buttonHighlight[] = { 0.22f, 0.18f, 0.12f, 1.0f }; // Button highlight
    
    // Buttons on the outer side of the boot (like reference images)
    for (int i = 0; i < 4; i++) {
        float y = 1.5f + i * 0.4f;
        
        // Main button
        glColor3fv(buttonColor);
        glPushMatrix();
        glTranslatef(0.42f, y, 0.0f);  // Outer side position
        glScalef(0.04f, 0.04f, 0.02f);
        GLUquadric* button = gluNewQuadric();
        gluSphere(button, 1.0f, 12, 12);
        gluDeleteQuadric(button);
        glPopMatrix();
        
        // Button highlight
        glColor3fv(buttonHighlight);
        glPushMatrix();
        glTranslatef(0.43f, y + 0.01f, 0.01f);
        glScalef(0.02f, 0.02f, 0.01f);
        GLUquadric* buttonHigh = gluNewQuadric();
        gluSphere(buttonHigh, 1.0f, 8, 8);
        gluDeleteQuadric(buttonHigh);
        glPopMatrix();
    }
}

// Function to draw realistic leather texture and wear patterns
void drawRealisticLeatherTexture() {
    glDisable(GL_LIGHTING);
    glPointSize(1.0f);
    
    // Create realistic leather grain texture
    glBegin(GL_POINTS);
    for (int i = 0; i < 400; i++) {
        float x = ((i * 17) % 200 - 100) * 0.006f;
        float y = ((i * 23) % 300 - 50) * 0.012f;
        float z = ((i * 31) % 180 - 90) * 0.006f;
        
        // Only place texture on boot surface
        if (x*x + z*z < 0.45f && y > -0.5f && y < 3.5f) {
            // Create natural leather color variation
            float variation = sinf(x * 50.0f) * cosf(z * 30.0f) * 0.05f;
            float baseColor = 0.2f + variation;
            glColor3f(baseColor * 0.8f, baseColor * 0.6f, baseColor * 0.4f);
            glVertex3f(x, y, z);
        }
    }
    glEnd();
    
    glPointSize(1.0f);
    glEnable(GL_LIGHTING);
}

// Main function to draw complete realistic historical boot
void drawRealisticHistoricalBoot(bool isLeft) {
    glPushMatrix();
    
    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }
    
    // Draw realistic boot components in proper order
    drawRealisticBootSole();
    drawRealisticBootFoot();
    drawRealisticBootShaft();
    drawRealisticBootCuff();
    drawRealisticSideLacing();
    drawRealisticBootButtons();
    drawRealisticLeatherTexture();
    
    glPopMatrix();
}

// Enhanced function to draw complete Black Myth Wukong character
void drawBlackMythWukongCharacter(bool isLeft) {
    glPushMatrix();
    
    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }
    
    // Draw Wukong's enhanced muscular leg anatomy
    drawWukongMuscularLeg(isLeft);
    
    // Draw the original armored pants (now as inner layer)
    drawHighContrastArmoredPants(3.5f);
    
    // Draw the new ornate outer armor layer
    drawWukongOuterArmorLayer(3.5f);
    
    glPopMatrix();
}

// --- APPLICATION FRAMEWORK ---

void setupLighting() {
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_COLOR_MATERIAL);

    GLfloat lightPos0[] = { 4.0f, 5.0f, 6.0f, 1.0f };
    GLfloat lightAmbient0[] = { 0.3f, 0.25f, 0.2f, 1.0f };
    GLfloat lightDiffuse0[] = { 0.95f, 0.9f, 0.8f, 1.0f };
    GLfloat lightSpecular0[] = { 0.4f, 0.35f, 0.25f, 1.0f };

    glLightfv(GL_LIGHT0, GL_POSITION, lightPos0);
    glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmbient0);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiffuse0);
    glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpecular0);

    GLfloat matShininess[] = { 12.0f };
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, matShininess);

    glEnable(GL_NORMALIZE);
    glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
}

LRESULT WINAPI WindowProcedure(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_ESCAPE: PostQuitMessage(0); break;
        case VK_LEFT:   rotationY -= 5.0f; break;
        case VK_RIGHT:  rotationY += 5.0f; break;
        case VK_UP:     rotationX -= 5.0f; break;
        case VK_DOWN:   rotationX += 5.0f; break;
        case 'W':       zoom += 0.5f; break;
        case 'S':       zoom -= 0.5f; break;
        }
        break;

    default:
        break;
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

bool initPixelFormat(HDC hdc) {
    PIXELFORMATDESCRIPTOR pfd;
    ZeroMemory(&pfd, sizeof(PIXELFORMATDESCRIPTOR));
    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 32;
    pfd.cDepthBits = 24;
    pfd.cStencilBits = 0;
    pfd.iLayerType = PFD_MAIN_PLANE;
    int n = ChoosePixelFormat(hdc, &pfd);
    return SetPixelFormat(hdc, n, &pfd);
}

void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    // Camera setup optimized for the mighty Wukong
    glTranslatef(0.0f, -4.0f, zoom);
    glRotatef(rotationX, 1.0f, 0.0f, 0.0f);
    glRotatef(rotationY, 0.0f, 1.0f, 0.0f);

    // Enhanced Wukong skin tones with depth variations for waist and hip
    GLfloat wukongSkinBase[] = { 0.85f, 0.7f, 0.45f, 1.0f };     // Base skin tone
    GLfloat wukongSkinLight[] = { 0.92f, 0.78f, 0.52f, 1.0f };   // Highlighted areas
    GLfloat wukongSkinMid[] = { 0.78f, 0.63f, 0.38f, 1.0f };     // Mid-tone areas
    GLfloat muscleDefinition[] = { 0.58f, 0.43f, 0.23f, 1.0f };  // Deep muscle definition
    GLfloat muscleHighlight[] = { 0.88f, 0.73f, 0.48f, 1.0f };   // Muscle highlights
    
    // Enhanced hip area with depth variation
    glColor3fv(wukongSkinBase);
    glPushMatrix();
    glTranslatef(0.0f, 7.2f, 0.0f);
    glScalef(1.0f, 0.8f, 0.7f);
    GLUquadric* hip = gluNewQuadric();
    gluSphere(hip, 0.5, 20, 20);
    gluDeleteQuadric(hip);
    glPopMatrix();
    
    // Add hip highlights
    glColor3fv(wukongSkinLight);
    glPushMatrix();
    glTranslatef(0.15f, 7.25f, 0.1f);  // Front-right highlight
    glScalef(0.4f, 0.3f, 0.25f);
    GLUquadric* hipHighlight = gluNewQuadric();
    gluSphere(hipHighlight, 0.5, 16, 16);
    gluDeleteQuadric(hipHighlight);
    glPopMatrix();
    
    // Add hip shadows
    glColor3fv(muscleDefinition);
    glPushMatrix();
    glTranslatef(-0.15f, 7.15f, 0.1f);  // Back-left shadow
    glScalef(0.35f, 0.25f, 0.2f);
    GLUquadric* hipShadow = gluNewQuadric();
    gluSphere(hipShadow, 0.5, 16, 16);
    gluDeleteQuadric(hipShadow);
    glPopMatrix();
    
    // Lower back muscles with enhanced depth
    glColor3fv(muscleHighlight);  // Highlighted muscle
    glPushMatrix();
    glTranslatef(0.0f, 7.0f, -0.3f);
    glScalef(0.7f, 0.4f, 0.3f);
    GLUquadric* lowerBack = gluNewQuadric();
    gluSphere(lowerBack, 0.5, 16, 16);
    gluDeleteQuadric(lowerBack);
    glPopMatrix();
    
    // Add lower back definition
    glColor3fv(muscleDefinition);
    glPushMatrix();
    glTranslatef(0.0f, 6.95f, -0.35f);  // Deeper muscle groove
    glScalef(0.5f, 0.2f, 0.15f);
    GLUquadric* backDefinition = gluNewQuadric();
    gluSphere(backDefinition, 0.5, 12, 12);
    gluDeleteQuadric(backDefinition);
    glPopMatrix();
    
    // Side oblique muscles with depth variations
    for (int side = -1; side <= 1; side += 2) {
        // Main oblique muscle
        if (side == -1) {
            glColor3fv(wukongSkinMid);    // Left side mid-tone
        } else {
            glColor3fv(wukongSkinLight);  // Right side highlighted
        }
        
        glPushMatrix();
        glTranslatef(side * 0.4f, 7.1f, 0.0f);
        glScalef(0.2f, 0.5f, 0.3f);
        GLUquadric* oblique = gluNewQuadric();
        gluSphere(oblique, 0.5, 14, 14);
        gluDeleteQuadric(oblique);
        glPopMatrix();
        
        // Add oblique definition
        glColor3fv(muscleDefinition);
        glPushMatrix();
        glTranslatef(side * 0.42f, 7.05f, -0.05f);
        glScalef(0.12f, 0.3f, 0.18f);
        GLUquadric* obliqueDefinition = gluNewQuadric();
        gluSphere(obliqueDefinition, 0.5, 12, 12);
        gluDeleteQuadric(obliqueDefinition);
        glPopMatrix();
        
        // Add oblique highlights
        if (side == 1) {  // Only add highlight to the right side for asymmetry
            glColor3fv(muscleHighlight);
            glPushMatrix();
            glTranslatef(side * 0.38f, 7.15f, 0.05f);
            glScalef(0.08f, 0.2f, 0.12f);
            GLUquadric* obliqueHighlight = gluNewQuadric();
            gluSphere(obliqueHighlight, 0.5, 10, 10);
            gluDeleteQuadric(obliqueHighlight);
            glPopMatrix();
        }
    }

    // Draw left leg with Black Myth Wukong styling
    glPushMatrix();
    glTranslatef(-0.7f, 0.0f, 0.0f);
    drawBlackMythWukongCharacter(true);
    
    // Position and draw left enhanced heritage combat boot
    glPushMatrix();
    glTranslatef(0.0f, 1.6f, 0.0f);
    glScalef(1.1f, 1.2f, 1.1f);
    drawEnhancedHeritageBootWithContrast(true);
    glPopMatrix();
    glPopMatrix();

    // Draw right leg with Black Myth Wukong styling
    glPushMatrix();
    glTranslatef(0.7f, 0.0f, 0.0f);
    drawBlackMythWukongCharacter(false);
    
    // Position and draw right enhanced heritage combat boot
    glPushMatrix();
    glTranslatef(0.0f, 1.6f, 0.0f);
    glScalef(1.1f, 1.2f, 1.1f);
    drawEnhancedHeritageBootWithContrast(false);
    glPopMatrix();
    glPopMatrix();
}

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR, int nCmdShow) {
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(WNDCLASSEX));
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpfnWndProc = WindowProcedure;
    wc.lpszClassName = WINDOW_TITLE;
    wc.style = CS_HREDRAW | CS_VREDRAW;
    if (!RegisterClassEx(&wc)) return false;

    HWND hWnd = CreateWindow(WINDOW_TITLE, WINDOW_TITLE, WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 1024, 768,
        NULL, NULL, wc.hInstance, NULL);

    HDC hdc = GetDC(hWnd);
    initPixelFormat(hdc);
    HGLRC hglrc = wglCreateContext(hdc);
    if (!wglMakeCurrent(hdc, hglrc)) return false;

    ShowWindow(hWnd, nCmdShow);

    // Initialize OpenGL
    glEnable(GL_DEPTH_TEST);
    setupLighting();
    glMatrixMode(GL_PROJECTION);
    gluPerspective(45.0f, 1024.0f / 768.0f, 0.1f, 100.0f);
    glMatrixMode(GL_MODELVIEW);
    glClearColor(0.2f, 0.15f, 0.15f, 1.0f); // Dark brown background

    MSG msg;
    ZeroMemory(&msg, sizeof(msg));

    while (true) {
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) break;
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        display();
        SwapBuffers(hdc);
    }

    wglMakeCurrent(NULL, NULL);
    wglDeleteContext(hglrc);
    ReleaseDC(hWnd, hdc);
    UnregisterClass(WINDOW_TITLE, wc.hInstance);

    return (int)msg.wParam;
}