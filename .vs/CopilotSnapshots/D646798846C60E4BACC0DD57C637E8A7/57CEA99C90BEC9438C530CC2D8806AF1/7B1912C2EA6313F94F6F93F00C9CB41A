    #include <Windows.h>
    #include <gl/GL.h>
    #include <gl/GLU.h>
    #include <math.h>
    #include <stdlib.h>
    #pragma comment (lib, "OpenGL32.lib")
    #pragma comment (lib, "GLU32.lib")
#define _USE_MATH_DEFINES
#include <math.h>
#define PI 3.14159f

// Global variables for camera control
float rotationX = 10.0f;
float rotationY = 0.0f;
float zoom = -15.0f;// Animation variables for realistic tail movement
float animationTime = 0.0f;

// Forward declarations
void drawMonkeyTail();
void drawSimpleLegs();
void drawSimpleLeg(bool isLeft);
void drawSimpleFoot(bool isLeft);
void drawSimpleToe(float length, float width);
void drawFurStrand(float length, float thickness, float curvature);
void drawMuscleDefinition(float radius, float length, float t);
void drawUpperBody();
void drawMuscularUpperTorso();
void drawSimpleHead();



// Function to draw Wukong-style muscular leg anatomy with enhanced color variations
void drawWukongMuscularLeg(bool isLeft) {
    glPushMatrix();

    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }

    // Enhanced skin tones for Wukong with depth variations
    GLfloat wukongSkinBase[] = { 0.85f, 0.7f, 0.45f, 1.0f };           // Base golden-brown
    GLfloat wukongSkinLight[] = { 0.92f, 0.78f, 0.52f, 1.0f };         // Lighter highlights
    GLfloat wukongSkinMid[] = { 0.78f, 0.63f, 0.38f, 1.0f };           // Mid-tone areas
    GLfloat wukongSkinDeep[] = { 0.68f, 0.53f, 0.28f, 1.0f };          // Deeper shadows
    GLfloat muscleDefinition[] = { 0.58f, 0.43f, 0.23f, 1.0f };        // Deep muscle definition
    GLfloat muscleHighlight[] = { 0.88f, 0.73f, 0.48f, 1.0f };         // Muscle highlights

    // --- ENHANCED UPPER THIGH (Much Larger and More Muscular) ---
    glColor3fv(wukongSkinBase);

    // Main upper thigh muscle mass
    glPushMatrix();
    glTranslatef(0.0f, 6.2f, 0.0f);
    glScalef(0.85f, 1.4f, 0.85f);
    GLUquadric* upperThigh = gluNewQuadric();
    gluSphere(upperThigh, 0.5, 20, 20);
    gluDeleteQuadric(upperThigh);
    glPopMatrix();

    // Quadriceps muscle definition with varying depths
    for (int i = 0; i < 3; i++) {
        float angle = (i - 1) * 0.3f;
        // Vary colors based on position for depth
        if (i == 0) glColor3fv(muscleDefinition);      // Deepest
        else if (i == 1) glColor3fv(wukongSkinMid);    // Mid-tone
        else glColor3fv(muscleHighlight);              // Highlighted

        glPushMatrix();
        glTranslatef(sinf(angle) * 0.25f, 6.1f, cosf(angle) * 0.15f + 0.2f);
        glScalef(0.15f, 0.6f, 0.2f);
        GLUquadric* quad = gluNewQuadric();
        gluSphere(quad, 0.5, 16, 16);
        gluDeleteQuadric(quad);
        glPopMatrix();
    }

    // --- ENHANCED MID THIGH (Larger and More Defined) ---
    glColor3fv(wukongSkinLight);  // Lighter tone for prominence
    glPushMatrix();
    glTranslatef(0.0f, 5.2f, 0.0f);
    glScalef(0.8f, 1.2f, 0.8f);
    GLUquadric* midThigh = gluNewQuadric();
    gluSphere(midThigh, 0.5, 20, 20);
    gluDeleteQuadric(midThigh);
    glPopMatrix();

    // Hamstring muscle definition
    glColor3fv(wukongSkinDeep);  // Deeper shadow tone
    glPushMatrix();
    glTranslatef(0.0f, 5.1f, -0.3f);
    glScalef(0.6f, 0.8f, 0.25f);
    GLUquadric* hamstring = gluNewQuadric();
    gluSphere(hamstring, 0.5, 16, 16);
    gluDeleteQuadric(hamstring);
    glPopMatrix();

    // --- ENHANCED KNEE AREA ---
    glColor3fv(wukongSkinMid);  // Mid-tone for natural transition
    glPushMatrix();
    glTranslatef(0.0f, 4.3f, 0.0f);
    glScalef(0.65f, 0.4f, 0.65f);
    GLUquadric* knee = gluNewQuadric();
    gluSphere(knee, 0.5, 16, 16);
    gluDeleteQuadric(knee);
    glPopMatrix();

    // --- ENHANCED CALF MUSCLES (Much More Defined) ---
    glColor3fv(wukongSkinBase);

    // Main calf muscle
    glPushMatrix();
    glTranslatef(0.0f, 3.8f, 0.1f);
    glScalef(0.55f, 0.9f, 0.7f);
    GLUquadric* calf = gluNewQuadric();
    gluSphere(calf, 0.5, 18, 18);
    gluDeleteQuadric(calf);
    glPopMatrix();

    // Gastrocnemius muscle definition with highlights
    glColor3fv(muscleHighlight);  // Highlighted muscle
    glPushMatrix();
    glTranslatef(0.0f, 3.7f, 0.2f);
    glScalef(0.35f, 0.7f, 0.4f);
    GLUquadric* gastrocnemius = gluNewQuadric();
    gluSphere(gastrocnemius, 0.5, 14, 14);
    gluDeleteQuadric(gastrocnemius);
    glPopMatrix();

    // Soleus muscle
    glColor3fv(muscleDefinition);  // Deep muscle definition
    glPushMatrix();
    glTranslatef(0.0f, 3.5f, -0.1f);
    glScalef(0.4f, 0.5f, 0.3f);
    GLUquadric* soleus = gluNewQuadric();
    gluSphere(soleus, 0.5, 14, 14);
    gluDeleteQuadric(soleus);
    glPopMatrix();

    // --- ENHANCED SHIN AREA ---
    glColor3fv(wukongSkinMid);
    glPushMatrix();
    glTranslatef(0.0f, 3.2f, 0.3f);
    glScalef(0.35f, 0.6f, 0.25f);
    GLUquadric* shin = gluNewQuadric();
    gluSphere(shin, 0.5, 14, 14);
    gluDeleteQuadric(shin);
    glPopMatrix();

    glPopMatrix();
}

// Enhanced function to draw high-contrast armored combat pants with depth variations
void drawHighContrastArmoredPants(float legHeight) {
    // Enhanced armored pants colors with depth variations
    GLfloat pantsBase[] = { 0.08f, 0.06f, 0.04f, 1.0f };           // Base very dark fabric
    GLfloat pantsHighlight[] = { 0.12f, 0.09f, 0.06f, 1.0f };      // Subtle highlights
    GLfloat pantsDeep[] = { 0.05f, 0.03f, 0.02f, 1.0f };           // Deepest shadows
    GLfloat armorBase[] = { 0.50f, 0.50f, 0.53f, 1.0f };           // Base steel gray
    GLfloat armorLight[] = { 0.62f, 0.62f, 0.65f, 1.0f };          // Lighter armor highlights
    GLfloat armorDeep[] = { 0.38f, 0.38f, 0.41f, 1.0f };           // Deeper armor shadows
    GLfloat rivetBase[] = { 0.40f, 0.40f, 0.42f, 1.0f };           // Base rivet color
    GLfloat rivetHighlight[] = { 0.52f, 0.52f, 0.54f, 1.0f };      // Highlighted rivets
    GLfloat rivetShadow[] = { 0.28f, 0.28f, 0.30f, 1.0f };         // Shadow rivets

    float pantsBottom = 4.2f;
    float pantsTop = pantsBottom + legHeight;

    // Draw main armored pants with depth variation
    int segments = 24;
    float angleStep = 2.0f * PI / segments;

    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        // Vary color based on position for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;  // 0 to 1 based on angle
        if (lightFactor > 0.6f) {
            glColor3fv(pantsHighlight);  // Highlighted areas
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(pantsDeep);       // Shadow areas
        }
        else {
            glColor3fv(pantsBase);       // Base areas
        }

        float bottomRadius = 0.26f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, pantsBottom, z * bottomRadius);

        float topRadius = 0.55f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, pantsTop, z * topRadius);
    }
    glEnd();

    // --- ENHANCED KNEE ARMOR PLATE with depth variations ---
    glColor3fv(armorBase);
    glPushMatrix();
    glTranslatef(0.0f, 5.2f, 0.18f);
    glScalef(0.35f, 0.25f, 0.12f);
    GLUquadric* kneePlate = gluNewQuadric();
    gluSphere(kneePlate, 1.0, 20, 16);
    gluDeleteQuadric(kneePlate);
    glPopMatrix();

    // Add armor highlights and shadows
    glColor3fv(armorLight);
    glPushMatrix();
    glTranslatef(0.05f, 5.25f, 0.22f);  // Slightly offset for highlight
    glScalef(0.15f, 0.12f, 0.06f);
    GLUquadric* kneeHighlight = gluNewQuadric();
    gluSphere(kneeHighlight, 1.0, 12, 8);
    gluDeleteQuadric(kneeHighlight);
    glPopMatrix();

    glColor3fv(armorDeep);
    glPushMatrix();
    glTranslatef(-0.05f, 5.15f, 0.16f);  // Shadow area
    glScalef(0.12f, 0.10f, 0.05f);
    GLUquadric* kneeShadow = gluNewQuadric();
    gluSphere(kneeShadow, 1.0, 12, 8);
    gluDeleteQuadric(kneeShadow);
    glPopMatrix();

    // Enhanced knee armor rivets with varied depth
    for (int i = 0; i < 10; i++) {
        float angle = i * 2.0f * PI / 10.0f;
        float x = sinf(angle) * 0.28f;
        float y = 5.2f + cosf(angle) * 0.18f;

        // Vary rivet colors for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(rivetHighlight);
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(rivetShadow);
        }
        else {
            glColor3fv(rivetBase);
        }

        glPushMatrix();
        glTranslatef(x, y, 0.23f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* rivet = gluNewQuadric();
        gluSphere(rivet, 1.0f, 8, 8);
        gluDeleteQuadric(rivet);
        glPopMatrix();
    }
}

// Function to draw Wukong-style outer armor layer with enhanced depth variations
void drawWukongOuterArmorLayer(float legHeight) {
    // Enhanced Wukong armor colors with rich depth variations
    GLfloat goldenBase[] = { 0.80f, 0.65f, 0.20f, 1.0f };         // Base golden armor
    GLfloat goldenLight[] = { 0.95f, 0.78f, 0.28f, 1.0f };        // Bright golden highlights
    GLfloat goldenMid[] = { 0.72f, 0.58f, 0.15f, 1.0f };          // Mid-tone golden
    GLfloat goldenDeep[] = { 0.58f, 0.45f, 0.10f, 1.0f };         // Deep golden shadows
    GLfloat bronzeBase[] = { 0.70f, 0.45f, 0.15f, 1.0f };         // Base bronze
    GLfloat bronzeLight[] = { 0.82f, 0.55f, 0.22f, 1.0f };        // Light bronze highlights
    GLfloat bronzeDeep[] = { 0.55f, 0.32f, 0.08f, 1.0f };         // Deep bronze shadows
    GLfloat darkMetalBase[] = { 0.15f, 0.12f, 0.10f, 1.0f };      // Base dark metal
    GLfloat darkMetalLight[] = { 0.22f, 0.18f, 0.15f, 1.0f };     // Lighter dark metal
    GLfloat jadeBase[] = { 0.20f, 0.60f, 0.30f, 1.0f };           // Base jade
    GLfloat jadeLight[] = { 0.28f, 0.75f, 0.40f, 1.0f };          // Light jade
    GLfloat jadeDeep[] = { 0.12f, 0.45f, 0.20f, 1.0f };           // Deep jade
    GLfloat redBase[] = { 0.80f, 0.20f, 0.10f, 1.0f };            // Base red
    GLfloat redLight[] = { 0.95f, 0.35f, 0.20f, 1.0f };           // Light red
    GLfloat redDeep[] = { 0.60f, 0.12f, 0.05f, 1.0f };            // Deep red

    float armorBottom = 3.8f;
    float armorTop = armorBottom + legHeight + 1.5f;

    // --- MAIN OUTER ARMOR SHELL with depth gradients ---
    int segments = 28;
    float angleStep = 2.0f * PI / segments;

    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        // Create depth through lighting simulation
        float lightFactor = (cosf(angle + PI * 0.3f) + 1.0f) * 0.5f;
        if (lightFactor > 0.7f) {
            glColor3fv(goldenLight);     // Bright highlights
        }
        else if (lightFactor > 0.4f) {
            glColor3fv(goldenBase);      // Mid tones
        }
        else if (lightFactor > 0.2f) {
            glColor3fv(goldenMid);       // Darker mid tones
        }
        else {
            glColor3fv(goldenDeep);      // Deep shadows
        }

        float bottomRadius = 0.4f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, armorBottom, z * bottomRadius);

        float topRadius = 0.7f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, armorTop, z * topRadius);
    }
    glEnd();

    // --- SEGMENTED ARMOR PLATES with rich depth variations ---
    for (int segment = 0; segment < 6; segment++) {
        float segmentHeight = armorBottom + 0.8f + (segment * 0.7f);
        float heightFactor = (float)segment / 5.0f;  // 0 to 1 from bottom to top

        // Vary golden armor based on height and position
        if (heightFactor > 0.6f) {
            glColor3fv(goldenLight);     // Upper segments brighter
        }
        else if (heightFactor > 0.3f) {
            glColor3fv(goldenBase);      // Middle segments
        }
        else {
            glColor3fv(goldenMid);       // Lower segments more subdued
        }

        glPushMatrix();
        glTranslatef(0.0f, segmentHeight, 0.0f);
        glRotatef(90, 1, 0, 0);
        glScalef(0.42f + (segment * 0.05f), 0.42f + (segment * 0.05f), 0.08f);
        GLUquadric* armorRing = gluNewQuadric();
        gluCylinder(armorRing, 1.0f, 1.0f, 1.0f, segments, 1);
        gluDeleteQuadric(armorRing);
        glPopMatrix();

        // Bronze decorative trim with depth variations
        if (segment % 2 == 0) {
            glColor3fv(bronzeLight);     // Alternating bright bronze
        }
        else {
            glColor3fv(bronzeBase);      // Alternating standard bronze
        }

        glPushMatrix();
        glTranslatef(0.0f, segmentHeight + 0.04f, 0.0f);
        glRotatef(90, 1, 0, 0);
        glScalef(0.44f + (segment * 0.05f), 0.44f + (segment * 0.05f), 0.02f);
        GLUquadric* trim = gluNewQuadric();
        gluCylinder(trim, 1.0f, 1.0f, 1.0f, segments, 1);
        gluDeleteQuadric(trim);
        glPopMatrix();
    }

    // --- ENHANCED KNEE ARMOR with rich depth ---
    glColor3fv(goldenBase);
    glPushMatrix();
    glTranslatef(0.0f, 4.8f, 0.3f);
    glScalef(0.5f, 0.35f, 0.18f);
    GLUquadric* kneeArmor = gluNewQuadric();
    gluSphere(kneeArmor, 1.0, 28, 24);
    gluDeleteQuadric(kneeArmor);
    glPopMatrix();

    // Add knee armor highlights
    glColor3fv(goldenLight);
    glPushMatrix();
    glTranslatef(0.08f, 4.85f, 0.35f);
    glScalef(0.2f, 0.15f, 0.08f);
    GLUquadric* kneeHighlight = gluNewQuadric();
    gluSphere(kneeHighlight, 1.0, 16, 12);
    gluDeleteQuadric(kneeHighlight);
    glPopMatrix();

    // Add knee armor shadows
    glColor3fv(goldenDeep);
    glPushMatrix();
    glTranslatef(-0.08f, 4.75f, 0.28f);
    glScalef(0.15f, 0.12f, 0.06f);
    GLUquadric* kneeShadow = gluNewQuadric();
    gluSphere(kneeShadow, 1.0, 16, 12);
    gluDeleteQuadric(kneeShadow);
    glPopMatrix();

    // Jade accents with depth variations
    for (int i = 0; i < 8; i++) {
        float angle = i * 2.0f * PI / 8.0f;
        float x = sinf(angle) * 0.35f;
        float z = cosf(angle) * 0.12f + 0.35f;

        // Vary jade colors for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(jadeLight);
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(jadeDeep);
        }
        else {
            glColor3fv(jadeBase);
        }

        glPushMatrix();
        glTranslatef(x, 4.8f, z);
        glScalef(0.03f, 0.03f, 0.03f);
        GLUquadric* jadeStud = gluNewQuadric();
        gluSphere(jadeStud, 1.0f, 10, 10);
        gluDeleteQuadric(jadeStud);
        glPopMatrix();
    }

    // --- DECORATIVE SIDE PANELS with enhanced depth ---
    for (int side = -1; side <= 1; side += 2) {
        // Main side panel with gradient
        if (side == -1) {
            glColor3fv(bronzeBase);      // Left side base bronze
        }
        else {
            glColor3fv(bronzeLight);     // Right side lighter bronze
        }

        glPushMatrix();
        glTranslatef(side * 0.45f, 5.5f, 0.1f);
        glScalef(0.15f, 1.8f, 0.3f);
        GLUquadric* sidePanel = gluNewQuadric();
        gluSphere(sidePanel, 1.0f, 20, 20);
        gluDeleteQuadric(sidePanel);
        glPopMatrix();

        // Decorative studs with varied depth
        for (int i = 0; i < 5; i++) {
            float y = 4.8f + i * 0.3f;
            float heightFactor = (float)i / 4.0f;

            // Vary red accents based on height
            if (heightFactor > 0.6f) {
                glColor3fv(redLight);
            }
            else if (heightFactor < 0.3f) {
                glColor3fv(redDeep);
            }
            else {
                glColor3fv(redBase);
            }

            glPushMatrix();
            glTranslatef(side * 0.45f, y, 0.2f);
            glScalef(0.04f, 0.04f, 0.04f);
            GLUquadric* stud = gluNewQuadric();
            gluSphere(stud, 1.0f, 12, 12);
            gluDeleteQuadric(stud);
            glPopMatrix();
        }
    }

    // --- DECORATIVE ENGRAVINGS with enhanced golden variations ---
    glDisable(GL_LIGHTING);
    glLineWidth(2.5f);

    // Cloud pattern engravings with depth variation
    for (int layer = 0; layer < 4; layer++) {
        float y = 4.5f + layer * 0.8f;
        float layerFactor = (float)layer / 3.0f;

        // Vary engraving brightness based on layer
        if (layerFactor > 0.6f) {
            glColor3f(0.98f, 0.85f, 0.35f);     // Brightest top layers
        }
        else if (layerFactor > 0.3f) {
            glColor3f(0.90f, 0.80f, 0.30f);     // Medium layers
        }
        else {
            glColor3f(0.82f, 0.72f, 0.25f);     // Deeper bottom layers
        }

        glBegin(GL_LINE_STRIP);
        for (int i = 0; i <= 20; i++) {
            float angle = i * 2.0f * PI / 20.0f;
            float radius = 0.3f + sinf(angle * 3.0f) * 0.05f;
            float x = cosf(angle) * radius;
            float z = sinf(angle) * radius * 0.7f + 0.2f;
            glVertex3f(x, y, z);
        }
        glEnd();
    }

    // Dragon scale pattern with depth variation
    for (int ring = 0; ring < 3; ring++) {
        float y = 5.2f + ring * 0.7f;
        float ringFactor = (float)ring / 2.0f;

        if (ringFactor > 0.6f) {
            glColor3f(0.95f, 0.82f, 0.32f);     // Bright upper scales
        }
        else {
            glColor3f(0.85f, 0.75f, 0.28f);     // Deeper lower scales
        }

        for (int scale = 0; scale < 12; scale++) {
            float angle = scale * 2.0f * PI / 12.0f;
            float x = cosf(angle) * 0.38f;
            float z = sinf(angle) * 0.25f + 0.15f;

            glBegin(GL_LINE_LOOP);
            for (int i = 0; i < 6; i++) {
                float scaleAngle = i * PI / 3.0f;
                float dx = cosf(scaleAngle) * 0.03f;
                float dz = sinf(scaleAngle) * 0.02f;
                glVertex3f(x + dx, y, z + dz);
            }
            glEnd();
        }
    }

    glLineWidth(1.0f);
    glEnable(GL_LIGHTING);
}

// Function to draw realistic 3D shoelaces with proper X-pattern overlapping
void drawRealistic3DShoelaces() {
    // Enhanced lace colors with realistic variations
    GLfloat laceBase[] = { 0.18f, 0.12f, 0.07f, 1.0f };        // Rich dark leather base
    GLfloat laceHighlight[] = { 0.28f, 0.20f, 0.12f, 1.0f };   // Highlighted areas
    GLfloat laceShadow[] = { 0.12f, 0.08f, 0.04f, 1.0f };      // Shadow areas
    GLfloat laceOver[] = { 0.22f, 0.15f, 0.09f, 1.0f };        // Overlapping sections

    // Eyelet positions (6 pairs, from bottom to top)
    const int numEyelets = 6;
    float eyeletPositions[numEyelets];
    for (int i = 0; i < numEyelets; i++) {
        eyeletPositions[i] = 0.4f + i * 0.28f;
    }

    float eyeletLeftX = -0.18f;
    float eyeletRightX = 0.18f;
    float eyeletZ = 0.45f;
    float laceThickness = 0.022f;
    int laceResolution = 10;

    // Helper function to draw a single lace segment with proper 3D orientation
    for (int segmentType = 0; segmentType < 4; segmentType++) {

        if (segmentType == 0) {
            // === BOTTOM TO TOP DIAGONAL LACES (LEFT TO RIGHT) ===
            for (int i = 0; i < numEyelets - 1; i++) {
                float startX = eyeletLeftX;
                float startY = eyeletPositions[i];
                float startZ = eyeletZ;
                float endX = eyeletRightX;
                float endY = eyeletPositions[i + 1];
                float endZ = eyeletZ;
                float zOffset = 0.0f;

                glColor3fv(laceBase);

                // Calculate direction vector and length
                float dx = endX - startX;
                float dy = endY - startY;
                float dz = endZ - startZ;
                float length = sqrtf(dx * dx + dy * dy + dz * dz);

                if (length > 0.001f) {
                    glPushMatrix();

                    // Position at start point with Z offset for layering
                    glTranslatef(startX, startY, startZ + zOffset);

                    // Calculate rotation angles for proper orientation
                    float angleY = atan2f(dx, dz) * 180.0f / PI;
                    float angleX = -atan2f(dy, sqrtf(dx * dx + dz * dz)) * 180.0f / PI;

                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    // Draw the main lace cylinder
                    GLUquadric* lace = gluNewQuadric();
                    gluQuadricOrientation(lace, GLU_OUTSIDE);
                    gluQuadricNormals(lace, GLU_SMOOTH);
                    gluCylinder(lace, laceThickness, laceThickness, length, laceResolution, 1);

                    // Add end caps for complete cylinder
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPushMatrix();
                    glTranslatef(0.0f, 0.0f, length);
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPopMatrix();

                    gluDeleteQuadric(lace);
                    glPopMatrix();

                    // Add highlight stripe along the lace for realism
                    glColor3fv(laceHighlight);
                    glPushMatrix();
                    glTranslatef(startX + dx * 0.1f, startY + dy * 0.1f, startZ + dz * 0.1f + zOffset + 0.01f);
                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    GLUquadric* highlight = gluNewQuadric();
                    gluQuadricOrientation(highlight, GLU_OUTSIDE);
                    gluCylinder(highlight, laceThickness * 0.3f, laceThickness * 0.3f, length * 0.8f, 6, 1);
                    gluDeleteQuadric(highlight);
                    glPopMatrix();
                }
            }
        }
        else if (segmentType == 1) {
            // === TOP TO BOTTOM DIAGONAL LACES (RIGHT TO LEFT) ===
            for (int i = 0; i < numEyelets - 1; i++) {
                float startX = eyeletRightX;
                float startY = eyeletPositions[i];
                float startZ = eyeletZ;
                float endX = eyeletLeftX;
                float endY = eyeletPositions[i + 1];
                float endZ = eyeletZ;
                float zOffset = 0.03f; // Higher Z for overlapping effect

                glColor3fv(laceOver);

                // Calculate direction vector and length
                float dx = endX - startX;
                float dy = endY - startY;
                float dz = endZ - startZ;
                float length = sqrtf(dx * dx + dy * dy + dz * dz);

                if (length > 0.001f) {
                    glPushMatrix();

                    // Position at start point with Z offset for layering
                    glTranslatef(startX, startY, startZ + zOffset);

                    // Calculate rotation angles for proper orientation
                    float angleY = atan2f(dx, dz) * 180.0f / PI;
                    float angleX = -atan2f(dy, sqrtf(dx * dx + dz * dz)) * 180.0f / PI;

                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    // Draw the main lace cylinder
                    GLUquadric* lace = gluNewQuadric();
                    gluQuadricOrientation(lace, GLU_OUTSIDE);
                    gluQuadricNormals(lace, GLU_SMOOTH);
                    gluCylinder(lace, laceThickness, laceThickness, length, laceResolution, 1);

                    // Add end caps for complete cylinder
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPushMatrix();
                    glTranslatef(0.0f, 0.0f, length);
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPopMatrix();

                    gluDeleteQuadric(lace);
                    glPopMatrix();

                    // Add highlight stripe along the lace for realism
                    glColor3fv(laceHighlight);
                    glPushMatrix();
                    glTranslatef(startX + dx * 0.1f, startY + dy * 0.1f, startZ + dz * 0.1f + zOffset + 0.01f);
                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    GLUquadric* highlight = gluNewQuadric();
                    gluQuadricOrientation(highlight, GLU_OUTSIDE);
                    gluCylinder(highlight, laceThickness * 0.3f, laceThickness * 0.3f, length * 0.8f, 6, 1);
                    gluDeleteQuadric(highlight);
                    glPopMatrix();
                }
            }
        }
        else if (segmentType == 2) {
            // === HORIZONTAL CONNECTING SEGMENTS ===
            // These represent the lace going through eyelets horizontally
            for (int i = 1; i < numEyelets - 1; i += 2) { // Every other eyelet pair
                float startX = eyeletLeftX;
                float startY = eyeletPositions[i];
                float startZ = eyeletZ;
                float endX = eyeletRightX;
                float endY = eyeletPositions[i];
                float endZ = eyeletZ;
                float zOffset = 0.015f;

                glColor3fv(laceBase);

                // Calculate direction vector and length
                float dx = endX - startX;
                float dy = endY - startY;
                float dz = endZ - startZ;
                float length = sqrtf(dx * dx + dy * dy + dz * dz);

                if (length > 0.001f) {
                    glPushMatrix();

                    // Position at start point with Z offset for layering
                    glTranslatef(startX, startY, startZ + zOffset);

                    // Calculate rotation angles for proper orientation
                    float angleY = atan2f(dx, dz) * 180.0f / PI;
                    float angleX = -atan2f(dy, sqrtf(dx * dx + dz * dz)) * 180.0f / PI;

                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    // Draw the main lace cylinder
                    GLUquadric* lace = gluNewQuadric();
                    gluQuadricOrientation(lace, GLU_OUTSIDE);
                    gluQuadricNormals(lace, GLU_SMOOTH);
                    gluCylinder(lace, laceThickness, laceThickness, length, laceResolution, 1);

                    // Add end caps for complete cylinder
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPushMatrix();
                    glTranslatef(0.0f, 0.0f, length);
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPopMatrix();

                    gluDeleteQuadric(lace);
                    glPopMatrix();
                }
            }
        }
        else if (segmentType == 3) {
            // === REALISTIC INTERSECTION POINTS ===
            // Add small cylindrical intersections where laces cross
            for (int i = 0; i < numEyelets - 2; i++) {
                for (int j = i + 1; j < numEyelets - 1; j++) {
                    // Calculate intersection points of crossing diagonals
                    float y1_start = eyeletPositions[i];
                    float y1_end = eyeletPositions[i + 1];
                    float y2_start = eyeletPositions[j];
                    float y2_end = eyeletPositions[j + 1];

                    // Parametric intersection calculation
                    float denom = ((y1_end - y1_start) - (y2_end - y2_start));
                    if (fabsf(denom) > 0.001f) {
                        float t = (y2_start - y1_start) / denom;

                        if (t > 0.1f && t < 0.9f) { // Only draw if intersection is in middle of segments
                            float intersectX = eyeletLeftX + t * (eyeletRightX - eyeletLeftX);
                            float intersectY = y1_start + t * (y1_end - y1_start);

                            // Draw small intersection cylinder
                            glColor3fv(laceShadow);
                            glPushMatrix();
                            glTranslatef(intersectX, intersectY, eyeletZ + 0.025f);
                            GLUquadric* intersection = gluNewQuadric();
                            gluSphere(intersection, laceThickness * 1.2f, 8, 8);
                            gluDeleteQuadric(intersection);
                            glPopMatrix();
                        }
                    }
                }
            }
        }
    }

    // === CURVED LACE SEGMENTS AROUND EYELETS ===
    // Add small curved segments where laces bend around eyelets
    for (int i = 0; i < numEyelets; i++) {
        float y = eyeletPositions[i];

        // Left and right eyelet curves
        glColor3fv(laceBase);
        for (int side = 0; side < 2; side++) { // 0=left, 1=right
            float x = (side == 0) ? eyeletLeftX : eyeletRightX;

            glPushMatrix();
            glTranslatef(x, y, eyeletZ + 0.02f);

            // Create a small curved segment
            GLUquadric* curve = gluNewQuadric();
            gluQuadricOrientation(curve, GLU_OUTSIDE);

            // Draw quarter-circle curves
            for (int angle = 0; angle < 180; angle += 20) {
                float rad = angle * PI / 180.0f;
                float curveX = cosf(rad) * 0.03f;
                float curveY = sinf(rad) * 0.03f;

                glPushMatrix();
                glTranslatef(curveX, curveY, 0.0f);
                gluSphere(curve, laceThickness * 0.7f, 6, 6);
                glPopMatrix();
            }

            gluDeleteQuadric(curve);
            glPopMatrix();
        }
    }

    // === LOOSE LACE ENDS LEADING TO BOW ===
    // Two lace ends coming from top eyelets
    for (int side = 0; side < 2; side++) {
        float x = (side == 0) ? eyeletLeftX : eyeletRightX;
        float topY = eyeletPositions[numEyelets - 1];

        glColor3fv(laceBase);
        glPushMatrix();
        glTranslatef(x, topY, eyeletZ);

        // Angle the lace end upward toward the bow
        glRotatef(70.0f + (side * 20.0f), 1, 0, 0); // 70-90 degrees upward
        glRotatef((side == 0) ? -10.0f : 10.0f, 0, 0, 1); // Slight inward angle

        // Draw tapered lace end
        GLUquadric* laceEnd = gluNewQuadric();
        gluQuadricOrientation(laceEnd, GLU_OUTSIDE);
        gluCylinder(laceEnd, laceThickness, laceThickness * 0.6f, 0.25f, laceResolution, 1);
        gluDisk(laceEnd, 0.0f, laceThickness, laceResolution, 1);
        gluDeleteQuadric(laceEnd);
        glPopMatrix();

        // Add highlight to lace end
        glColor3fv(laceHighlight);
        glPushMatrix();
        glTranslatef(x + 0.01f, topY + 0.01f, eyeletZ + 0.01f);
        glRotatef(70.0f + (side * 20.0f), 1, 0, 0);
        glRotatef((side == 0) ? -10.0f : 10.0f, 0, 0, 1);

        GLUquadric* endHighlight = gluNewQuadric();
        gluCylinder(endHighlight, laceThickness * 0.3f, laceThickness * 0.2f, 0.2f, 6, 1);
        gluDeleteQuadric(endHighlight);
        glPopMatrix();
    }

    // === AGLET TIPS (PLASTIC/METAL LACE TIPS) ===
    // Add small metallic tips to lace ends for realism
    GLfloat agletColor[] = { 0.4f, 0.4f, 0.42f, 1.0f }; // Metallic gray

    for (int side = 0; side < 2; side++) {
        float x = (side == 0) ? eyeletLeftX : eyeletRightX;
        float topY = eyeletPositions[numEyelets - 1];

        glColor3fv(agletColor);
        glPushMatrix();
        glTranslatef(x, topY + 0.15f, eyeletZ + 0.12f);
        glRotatef(70.0f + (side * 20.0f), 1, 0, 0);
        glRotatef((side == 0) ? -10.0f : 10.0f, 0, 0, 1);

        // Draw small metallic aglet
        GLUquadric* aglet = gluNewQuadric();
        gluQuadricOrientation(aglet, GLU_OUTSIDE);
        gluCylinder(aglet, laceThickness * 1.1f, laceThickness * 0.8f, 0.04f, 8, 1);

        // Add end cap
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.04f);
        gluSphere(aglet, laceThickness * 0.8f, 6, 6);
        glPopMatrix();

        gluDeleteQuadric(aglet);
        glPopMatrix();
    }
}

// Function to draw a decorative bow/knot at the top of the lacing area
void drawDecorativeBowKnot() {
    // Colors for the bow
    GLfloat bowBase[] = { 0.18f, 0.10f, 0.05f, 1.0f };          // Rich dark leather
    GLfloat bowLight[] = { 0.25f, 0.15f, 0.08f, 1.0f };         // Highlight areas
    GLfloat bowDeep[] = { 0.12f, 0.06f, 0.03f, 1.0f };          // Shadow areas

    // Center knot - the main part that ties the loops together
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, 0.0f);
    glScalef(0.08f, 0.04f, 0.04f);
    GLUquadric* bowCenter = gluNewQuadric();
    gluSphere(bowCenter, 1.0f, 16, 16);
    gluDeleteQuadric(bowCenter);
    glPopMatrix();

    // Add highlight to the center knot
    glColor3fv(bowLight);
    glPushMatrix();
    glTranslatef(0.02f, 0.01f, 0.01f);
    glScalef(0.03f, 0.02f, 0.02f);
    GLUquadric* knobHighlight = gluNewQuadric();
    gluSphere(knobHighlight, 1.0f, 12, 12);
    gluDeleteQuadric(knobHighlight);
    glPopMatrix();

    // Left bow loop
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(-0.10f, 0.0f, 0.0f);
    glRotatef(30.0f, 0.0f, 0.0f, 1.0f);  // Tilt slightly
    glRotatef(15.0f, 0.0f, 1.0f, 0.0f);  // Rotate a bit forward
    glScalef(0.12f, 0.06f, 0.025f);
    GLUquadric* leftLoop = gluNewQuadric();
    gluSphere(leftLoop, 1.0f, 16, 16);
    gluDeleteQuadric(leftLoop);
    glPopMatrix();

    // Add highlight to left loop
    glColor3fv(bowLight);
    glPushMatrix();
    glTranslatef(-0.12f, 0.01f, 0.01f);
    glRotatef(30.0f, 0.0f, 0.0f, 1.0f);
    glScalef(0.05f, 0.03f, 0.015f);
    GLUquadric* leftHighlight = gluNewQuadric();
    gluSphere(leftHighlight, 1.0f, 12, 12);
    gluDeleteQuadric(leftHighlight);
    glPopMatrix();

    // Add shadow to left loop
    glColor3fv(bowDeep);
    glPushMatrix();
    glTranslatef(-0.08f, -0.01f, -0.01f);
    glRotatef(30.0f, 0.0f, 0.0f, 1.0f);
    glScalef(0.04f, 0.02f, 0.015f);
    GLUquadric* leftShadow = gluNewQuadric();
    gluSphere(leftShadow, 1.0f, 12, 12);
    gluDeleteQuadric(leftShadow);
    glPopMatrix();

    // Right bow loop
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(0.10f, 0.0f, 0.0f);
    glRotatef(-30.0f, 0.0f, 0.0f, 1.0f);  // Tilt slightly (mirror of left)
    glRotatef(15.0f, 0.0f, 1.0f, 0.0f);   // Rotate a bit forward
    glScalef(0.12f, 0.06f, 0.025f);
    GLUquadric* rightLoop = gluNewQuadric();
    gluSphere(rightLoop, 1.0f, 16, 16);
    gluDeleteQuadric(rightLoop);
    glPopMatrix();

    // Add highlight to right loop
    glColor3fv(bowLight);
    glPushMatrix();
    glTranslatef(0.12f, 0.01f, 0.01f);
    glRotatef(-30.0f, 0.0f, 0.0f, 1.0f);
    glScalef(0.05f, 0.03f, 0.015f);
    GLUquadric* rightHighlight = gluNewQuadric();
    gluSphere(rightHighlight, 1.0f, 12, 12);
    gluDeleteQuadric(rightHighlight);
    glPopMatrix();

    // Add shadow to right loop
    glColor3fv(bowDeep);
    glPushMatrix();
    glTranslatef(0.08f, -0.01f, -0.01f);
    glRotatef(-30.0f, 0.0f, 0.0f, 1.0f);
    glScalef(0.04f, 0.02f, 0.015f);
    GLUquadric* rightShadow = gluNewQuadric();
    gluSphere(rightShadow, 1.0f, 12, 12);
    gluDeleteQuadric(rightShadow);
    glPopMatrix();

    // Lower left tail of the bow
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(-0.06f, -0.05f, -0.005f);
    glRotatef(-15.0f, 0.0f, 0.0f, 1.0f);
    glRotatef(-10.0f, 1.0f, 0.0f, 0.0f);
    glScalef(0.05f, 0.10f, 0.02f);
    GLUquadric* leftTail = gluNewQuadric();
    gluSphere(leftTail, 1.0f, 14, 14);
    gluDeleteQuadric(leftTail);
    glPopMatrix();

    // Lower right tail of the bow
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(0.06f, -0.05f, -0.005f);
    glRotatef(15.0f, 0.0f, 0.0f, 1.0f);
    glRotatef(-10.0f, 1.0f, 0.0f, 0.0f);
    glScalef(0.05f, 0.10f, 0.02f);
    GLUquadric* rightTail = gluNewQuadric();
    gluSphere(rightTail, 1.0f, 14, 14);
    gluDeleteQuadric(rightTail);
    glPopMatrix();
}

// Enhanced function to draw smooth polygon shoes with complete coverage like real shoes
void drawEnhancedHeritageBootWithContrast(bool isLeft) {
    // Enhanced colors for realistic shoe appearance
    GLfloat soleBase[] = { 0.08f, 0.06f, 0.04f, 1.0f };           // Dark sole base
    GLfloat soleLight[] = { 0.12f, 0.09f, 0.06f, 1.0f };          // Sole highlights
    GLfloat soleDeep[] = { 0.04f, 0.02f, 0.01f, 1.0f };           // Deep sole shadows

    // Premium leather colors for smooth appearance
    GLfloat leatherBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };        // Rich leather base
    GLfloat leatherLight[] = { 0.58f, 0.42f, 0.28f, 1.0f };       // Leather highlights
    GLfloat leatherMid[] = { 0.40f, 0.25f, 0.15f, 1.0f };         // Mid-tone leather
    GLfloat leatherDeep[] = { 0.28f, 0.16f, 0.08f, 1.0f };        // Deep leather shadows

    // Smooth upper materials
    GLfloat upperBase[] = { 0.35f, 0.22f, 0.15f, 1.0f };          // Upper material base
    GLfloat upperLight[] = { 0.45f, 0.32f, 0.22f, 1.0f };         // Upper highlights
    GLfloat upperDeep[] = { 0.25f, 0.14f, 0.08f, 1.0f };          // Upper shadows

    // Metal accents
    GLfloat metalBase[] = { 0.45f, 0.45f, 0.47f, 1.0f };          // Metal base
    GLfloat metalLight[] = { 0.62f, 0.62f, 0.65f, 1.0f };         // Metal highlights
    GLfloat metalDeep[] = { 0.28f, 0.28f, 0.30f, 1.0f };          // Metal shadows

    glPushMatrix();

    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }

    // === SEAMLESS SOLE CONSTRUCTION (COMPLETELY CLOSED LIKE REAL SHOES) ===

    // MAIN CONTINUOUS SOLE - Single seamless piece
    glColor3fv(soleBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.75f, 0.1f);
    glScalef(0.9f, 0.25f, 2.8f);  // Larger for complete coverage
    GLUquadric* continuousSole = gluNewQuadric();
    gluSphere(continuousSole, 0.5, 48, 48);  // High resolution for smoothness
    gluDeleteQuadric(continuousSole);
    glPopMatrix();

    // PERFECTLY FLAT BOTTOM - No gaps or openings
    glColor3fv(soleDeep);
    glPushMatrix();
    glTranslatef(0.0f, -0.95f, 0.1f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.92f, 2.85f, 0.05f);
    GLUquadric* flatBottom = gluNewQuadric();
    gluDisk(flatBottom, 0.0f, 0.5f, 48, 1);  // Completely sealed bottom
    gluDeleteQuadric(flatBottom);
    glPopMatrix();

    // SEAMLESS SOLE EDGE - Continuous rim with no breaks
    glColor3fv(soleLight);
    glPushMatrix();
    glTranslatef(0.0f, -0.85f, 0.1f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.91f, 2.82f, 0.08f);
    GLUquadric* soleEdge = gluNewQuadric();
    gluCylinder(soleEdge, 0.5, 0.5, 1.0, 48, 1);  // Smooth continuous edge
    gluDeleteQuadric(soleEdge);
    glPopMatrix();

    // === SEAMLESS UPPER CONSTRUCTION ===
    int segments = 48;  // High resolution for smooth appearance
    float angleStep = 2.0f * PI / segments;

    // MAIN UPPER BODY - Single seamless piece
    glColor3fv(leatherBase);
    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        float lightFactor = (cosf(angle + PI * 0.25f) + 1.0f) * 0.5f;
        if (lightFactor > 0.7f) glColor3fv(leatherLight);
        else if (lightFactor > 0.3f) glColor3fv(leatherBase);
        else glColor3fv(leatherDeep);

        glNormal3f(x, 0, z);
        glVertex3f(x * 0.52f, -0.6f, z * 0.45f + 0.1f);  // Sole connection
        glVertex3f(x * 0.48f, 2.9f, z * 0.4f);           // Top opening
    }
    glEnd();

    // TOP CLOSURE - Complete seal
    glColor3fv(leatherMid);
    glPushMatrix();
    glTranslatef(0.0f, 2.9f, 0.0f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.48f, 0.4f, 0.08f);
    GLUquadric* topClosure = gluNewQuadric();
    gluDisk(topClosure, 0.0f, 1.0f, segments, 1);
    gluDeleteQuadric(topClosure);
    glPopMatrix();

    // SEAMLESS TOE CAP
    glColor3fv(leatherBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.25f, 0.85f);
    glScalef(0.72f, 0.65f, 0.9f);
    GLUquadric* seamlessToe = gluNewQuadric();
    gluSphere(seamlessToe, 0.5, 32, 32);
    gluDeleteQuadric(seamlessToe);
    glPopMatrix();

    // SEAMLESS HEEL
    glColor3fv(leatherBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.25f, -0.45f);
    glScalef(0.7f, 0.7f, 0.8f);
    GLUquadric* seamlessHeel = gluNewQuadric();
    gluSphere(seamlessHeel, 0.5, 32, 32);
    gluDeleteQuadric(seamlessHeel);
    glPopMatrix();

    // CONTINUOUS WELT
    glColor3fv(upperBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.65f, 0.1f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.87f, 2.75f, 0.08f);
    GLUquadric* continuousWelt = gluNewQuadric();
    gluCylinder(continuousWelt, 0.5, 0.5, 1.0, 48, 1);
    gluDeleteQuadric(continuousWelt);
    glPopMatrix();

    // SIMPLE EYELETS
    glColor3fv(metalBase);
    for (int i = 0; i < 6; i++) {
        float y = 0.4f + i * 0.28f;
        if (i % 2 == 0) glColor3fv(metalLight);
        else glColor3fv(metalBase);

        glPushMatrix();
        glTranslatef(-0.18f, y, 0.45f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* leftEyelet = gluNewQuadric();
        gluSphere(leftEyelet, 1.0f, 12, 12);
        gluDeleteQuadric(leftEyelet);
        glPopMatrix();

        glPushMatrix();
        glTranslatef(0.18f, y, 0.45f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* rightEyelet = gluNewQuadric();
        gluSphere(rightEyelet, 1.0f, 12, 12);
        gluDeleteQuadric(rightEyelet);
        glPopMatrix();
    }

    // Draw realistic 3D shoelaces with X-pattern overlapping
    drawRealistic3DShoelaces();

    // COLLAR
    glColor3fv(upperBase);
    glPushMatrix();
    glTranslatef(0.0f, 2.7f, 0.0f);
    glScalef(0.5f, 0.18f, 0.42f);
    GLUquadric* collar = gluNewQuadric();
    gluSphere(collar, 1.0f, 24, 24);
    gluDeleteQuadric(collar);
    glPopMatrix();

    // MINIMAL TREAD
    glDisable(GL_LIGHTING);
    glColor3f(0.06f, 0.04f, 0.02f);
    glLineWidth(1.0f);

    for (int i = 0; i < 12; i++) {
        float z = -1.2f + (i * 0.2f);
        glBegin(GL_LINES);
        for (int j = 0; j < 8; j++) {
            float x = -0.3f + (j * 0.075f);
            glVertex3f(x, -0.93f, z);
            glVertex3f(x + 0.05f, -0.93f, z);
        }
        glEnd();
    }

    glEnable(GL_LIGHTING);

    // NEW: DECORATIVE BOW KNOT AT TOP OF LACING
    glPushMatrix();
    glTranslatef(0.0f, 2.0f, 0.48f); // Position at the top of the lacing area
    drawDecorativeBowKnot();
    glPopMatrix();

    glPopMatrix();
}




// Enhanced function to draw complete Black Myth Wukong character
void drawBlackMythWukongCharacter(bool isLeft) {
}
    #define WINDOW_TITLE "Wukong Arms - Controllable with Fur"

    // Animation and control variables - Left and Right arms
    float shoulderAngle[2] = {0.0f, 0.0f};
    float elbowAngle[2] = {0.0f, 0.0f};
    float wristAngle[2] = {0.0f, 0.0f};

    // Finger control - each finger has 3 joints for both arms
    float thumbAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    float indexAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    float middleAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    float ringAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    float pinkyAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};

    // Control state
    int activeArm = 0; // 0 = left, 1 = right

    // Camera control
    float cameraAngleX = 0.0f;
    float cameraAngleY = 0.0f;
    float cameraDistance = 30.0f;

    // Key states
    bool keys[256] = {false};
#include <vector>   // add this near your other includes
    float armSwingAngle[2] = { 0.0f, -0.0f }; // left arm forward, right arm back
    int armSwingDir[2] = { -1, 1 };             // opposite swing directions

    bool isWalking = false;

    // ... (existing includes unchanged)

    struct FurPatch {
        float x, y, z;
        float nx, ny, nz;   // outward direction
        float length;
    };
    // Precomputed fur arrays for parts (per arm where relevant)
    std::vector<FurPatch> upperArmFur[2];
    std::vector<FurPatch> forearmFur[2];
    std::vector<FurPatch> shoulderFur[2];
    std::vector<FurPatch> palmFur[2];

    // Utility forward declarations
    void generateFurForCylinder(std::vector<FurPatch>& out, float radius, float height, int furCount);
    void generateFurForSphere(std::vector<FurPatch>& out, float radius, int furCount);
    void drawFurFromArray(const std::vector<FurPatch>& arr);
    void precomputeAllFur();


    GLuint loadTexture(const char* filename) {
        GLuint textureID;
        int width, height;
        unsigned char* data;

        FILE* file;
        fopen_s(&file, filename, "rb");
        if (file == NULL) return 0;

        // Read BMP header
        unsigned char header[54];
        fread(header, 1, 54, file);
        width = *(int*)&(header[18]);
        height = *(int*)&(header[22]);
        int imageSize = 3 * width * height;

        data = new unsigned char[imageSize];
        fread(data, 1, imageSize, file);
        fclose(file);

        // Flip BGR -> RGB
        for (int i = 0; i < imageSize; i += 3) {
            unsigned char tmp = data[i];
            data[i] = data[i + 2];
            data[i + 2] = tmp;
        }

        // Create texture
        glGenTextures(1, &textureID);
        glBindTexture(GL_TEXTURE_2D, textureID);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height,
            0, GL_RGB, GL_UNSIGNED_BYTE, data);

        delete[] data;
        return textureID;
    }

    LRESULT WINAPI WindowProcedure(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        switch (msg)
        {
        case WM_KEYDOWN:
            switch (wParam)
            {
            case VK_UP:
                cameraAngleX += 1.0f;
                if (cameraAngleX > 89.0f) cameraAngleX = 89.0f;
                break;

            case VK_DOWN:
                cameraAngleX -= 1.0f;
                if (cameraAngleX < -89.0f) cameraAngleX = -89.0f;
                break;

            case VK_LEFT:
                cameraAngleY += 1.0f;
                break;

            case VK_RIGHT:
                cameraAngleY -= 1.0f;
                break;

            case 'Z':  // zoom in
                cameraDistance -= 0.2f;
                if (cameraDistance < 3.0f) cameraDistance = 3.0f;
                break;

            case 'X':  // zoom out
                cameraDistance += 0.2f;
                if (cameraDistance > 40.0f) cameraDistance = 40.0f;
                break;

            case 'W':  // toggle walking
                isWalking = true;
                break;

            case 'Q':  // toggle walking
                isWalking = false ;
                break;

            case VK_ESCAPE: // quit app
                PostQuitMessage(0);
                break;
            }
            break;


        default:
            break;
        }
        return DefWindowProc(hWnd, msg, wParam, lParam);
    }

    bool initPixelFormat(HDC hdc)
    {
        PIXELFORMATDESCRIPTOR pfd;
        ZeroMemory(&pfd, sizeof(PIXELFORMATDESCRIPTOR));
        pfd.cAlphaBits = 8;
        pfd.cColorBits = 32;
        pfd.cDepthBits = 24;
        pfd.cStencilBits = 0;
        pfd.dwFlags = PFD_DOUBLEBUFFER | PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;
        pfd.iLayerType = PFD_MAIN_PLANE;
        pfd.iPixelType = PFD_TYPE_RGBA;
        pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
        pfd.nVersion = 1;

        int n = ChoosePixelFormat(hdc, &pfd);
        if (SetPixelFormat(hdc, n, &pfd))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    void drawCylinder(float radius, float height, int slices)
    {
        GLUquadricObj* quadric = gluNewQuadric();
        gluQuadricNormals(quadric, GLU_SMOOTH);  // <-- add normals
        gluCylinder(quadric, radius, radius, height, slices, 1);
        gluDeleteQuadric(quadric);
    }

    void drawSphere(float radius, int slices, int stacks)
    {
        GLUquadricObj* quadric = gluNewQuadric();
        gluQuadricNormals(quadric, GLU_SMOOTH);  // <-- add normals
        gluSphere(quadric, radius, slices, stacks);
        gluDeleteQuadric(quadric);
    }


  

    void drawFurPatch(float x, float y, float z, float size, float angleX, float angleY, float angleZ)
    {
        glPushMatrix();
            glTranslatef(x, y, z);
            glRotatef(angleX, 1, 0, 0);
            glRotatef(angleY, 0, 1, 0);
            glRotatef(angleZ, 0, 0, 1);
            glScalef(size, size * 0.3f, size * 2.0f);
            glColor3f(0.4f, 0.3f, 0.2f); // Dark brown fur
            drawSphere(0.05f, 6, 6);
        glPopMatrix();
    }

    //void drawFurOnCylinder(float radius, float height, int furCount)
    //{
    //    for (int i = 0; i < furCount; i++) {
    //        float angle = (float)i / furCount * 6.28f; // 2 * PI
    //        float heightPos = (rand() % 100) / 100.0f * height;
    //        float radiusOffset = radius + (rand() % 20 - 10) / 200.0f;
    //    
    //        float x = cos(angle) * radiusOffset;
    //        float y = sin(angle) * radiusOffset;
    //        float z = heightPos;
    //    
    //        float furAngleX = (rand() % 60 - 30);
    //        float furAngleY = angle * 180.0f / 3.14159f;
    //        float furAngleZ = (rand() % 40 - 20);
    //        float furSize = 0.8f + (rand() % 40) / 100.0f;
    //    
    //        drawFurPatch(x, y, z, furSize, furAngleX, furAngleY, furAngleZ);
    //    }
  
    GLuint myTexture;
    // old drawFurOnCylinder/drawFurOnSphere removed ?replaced by drawFurFromArray
    void drawFurFromArray(const std::vector<FurPatch>& arr)
    {
        glBindTexture(GL_TEXTURE_2D, myTexture);
        glBegin(GL_QUADS);
        for (auto& patch : arr) {
            float s = 0.05f; // small quad size
            glTexCoord2f(0, 0); glVertex3f(patch.x - s, patch.y, patch.z);
            glTexCoord2f(1, 0); glVertex3f(patch.x + s, patch.y, patch.z);
            glTexCoord2f(1, 1); glVertex3f(patch.x + s, patch.y, patch.z + patch.length);
            glTexCoord2f(0, 1); glVertex3f(patch.x - s, patch.y, patch.z + patch.length);
        }
        glEnd();
    }

    void generateFurForCylinder(std::vector<FurPatch>& patches, float radius, float height, int density)
    {
        for (int i = 0; i < density; i++) {
            float angle = (rand() % 360) * M_PI / 180.0f;
            float z = ((float)rand() / RAND_MAX) * height;

            // Base position on surface
            float x = cosf(angle) * radius;
            float y = sinf(angle) * radius;

            // Normal points outward
            float nx = cosf(angle);
            float ny = sinf(angle);
            float nz = 0.0f;

            // Push base point slightly outward
            float offset = 0.05f;
            x += nx * offset;
            y += ny * offset;

            // Fur patch
            FurPatch patch;
            patch.x = x;
            patch.y = y;
            patch.z = z;
            patch.nx = nx;
            patch.ny = ny;
            patch.nz = nz;
            patch.length = 0.3f + ((rand() % 100) / 500.0f); // 0.3?.5 length
            patches.push_back(patch);
        }
    }


    void generateFurForSphere(std::vector<FurPatch>& patches, float radius, int density)
    {
        for (int i = 0; i < density; i++) {
            float theta = ((float)rand() / RAND_MAX) * M_PI;
            float phi = ((float)rand() / RAND_MAX) * 2 * M_PI;

            // Base point on sphere
            float x = radius * sinf(theta) * cosf(phi);
            float y = radius * sinf(theta) * sinf(phi);
            float z = radius * cosf(theta);

            // Normal = same as position (pointing outward)
            float nx = x, ny = y, nz = z;
            float len = sqrtf(nx * nx + ny * ny + nz * nz);
            nx /= len; ny /= len; nz /= len;

            // Push base outward
            float offset = 0.05f;
            x += nx * offset;
            y += ny * offset;
            z += nz * offset;

            FurPatch patch;
            patch.x = x;
            patch.y = y;
            patch.z = z;
            patch.nx = nx;
            patch.ny = ny;
            patch.nz = nz;
            patch.length = 0.1f + ((rand() % 100) / 500.0f);
            patches.push_back(patch);
        }
    }


    void precomputeAllFur()
    {

        // Example counts ?match the counts you used previously (or tune)
        for (int arm = 0; arm < 2; ++arm) {
            generateFurForCylinder(upperArmFur[arm], 0.6f, 3.0f, 35);
            generateFurForCylinder(forearmFur[arm], 0.5f, 2.5f, 28);
            generateFurForSphere(shoulderFur[arm], 0.8f, 20);
            generateFurForSphere(palmFur[arm], 0.8f, 15);
            // If you have other joints with separate fur density, precompute them similarly
        }
    }


    void drawFinger(int armIndex, float* angles, float baseWidth, float length1, float length2, float length3)
    {

        drawFurFromArray(palmFur[armIndex]);

        // First joint (base)
        glPushMatrix();
            glRotatef(angles[0], 1, 0, 0);
            glColor3f(0.8f, 0.6f, 0.4f); // Monkey skin color
            drawCylinder(baseWidth, length1, 12);
            //drawFurOnCylinder(baseWidth, length1, 8); // Add fur
            drawFurFromArray(palmFur[0]);
            // Joint sphere
            glTranslatef(0, 0, length1);
            glColor3f(0.7f, 0.5f, 0.3f);
            drawSphere(baseWidth * 1.1f, 8, 8);
            //drawFurOnSphere(baseWidth * 1.1f, 4);
        
            // Second joint
            glPushMatrix();
                glRotatef(angles[1], 1, 0, 0);
                glColor3f(0.8f, 0.6f, 0.4f);
                drawCylinder(baseWidth * 0.9f, length2, 12);
                //drawFurOnCylinder(baseWidth * 0.9f, length2, 6);
            
                // Joint sphere
                glTranslatef(0, 0, length2);
                glColor3f(0.7f, 0.5f, 0.3f);
                drawSphere(baseWidth * 0.9f, 8, 8);
                //drawFurOnSphere(baseWidth * 0.9f, 3);
            
                // Third joint (fingertip)
                glPushMatrix();
                    glRotatef(angles[2], 1, 0, 0);
                    glColor3f(0.8f, 0.6f, 0.4f);
                    drawCylinder(baseWidth * 0.8f, length3, 12);
                    //drawFurOnCylinder(baseWidth * 0.8f, length3, 4);
                
                    // Fingertip
                    glTranslatef(0, 0, length3);
                    glColor3f(0.75f, 0.55f, 0.35f);
                    drawSphere(baseWidth * 0.8f, 8, 8);
                    //drawFurOnSphere(baseWidth * 0.8f, 3);
                glPopMatrix();
            glPopMatrix();
        glPopMatrix();
    }
    void drawHand(int armIndex)
    {
        // Palm
        glPushMatrix();
        glColor3f(0.8f, 0.6f, 0.4f); // Monkey skin color
        glScalef(1.5f, 0.8f, 2.5f);
        drawSphere(0.8f, 16, 16);
        drawFurFromArray(palmFur[armIndex]);
        glPopMatrix();

        // Thumb
        glPushMatrix();
        glTranslatef(-1.0f, 0.3f, 0.5f);
        glRotatef(-30, 0, 1, 0);
        glRotatef(45, 0, 0, 1);
        drawFinger(armIndex, thumbAngles[armIndex], 0.25f, 0.8f, 0.6f, 0.5f);
        glPopMatrix();

        // Index finger
        glPushMatrix();
        glTranslatef(-0.6f, 0.0f, 2.0f);
        drawFinger(armIndex, indexAngles[armIndex], 0.2f, 1.0f, 0.8f, 0.6f);
        glPopMatrix();

        // Middle finger
        glPushMatrix();
        glTranslatef(-0.2f, 0.0f, 2.0f);
        drawFinger(armIndex, middleAngles[armIndex], 0.22f, 1.1f, 0.9f, 0.7f);
        glPopMatrix();

        // Ring finger
        glPushMatrix();
        glTranslatef(0.2f, 0.0f, 2.0f);
        drawFinger(armIndex, ringAngles[armIndex], 0.2f, 1.0f, 0.8f, 0.6f);
        glPopMatrix();

        // Pinky finger
        glPushMatrix();
        glTranslatef(0.6f, 0.0f, 1.8f);
        drawFinger(armIndex, pinkyAngles[armIndex], 0.18f, 0.8f, 0.6f, 0.5f);
        glPopMatrix();
    }

    void drawArm(int armIndex)
    {

        drawSphere(0.8f, 16, 16);
        drawFurFromArray(shoulderFur[armIndex]);

        // --- Apply walking swing (forward/back rotation)
        glRotatef(armSwingAngle[armIndex], 1, 0, 0);  // rotate around X-axis


        // Mirror the right arm
        if (armIndex == 1) {
            glScalef(-1.0f, 1.0f, 1.0f);
        }
    
        // Shoulder joint
        glPushMatrix();
            // Color coding for active arm
            if (armIndex == activeArm) {
                glColor3f(0.9f, 0.7f, 0.3f); // Golden highlight for active Wukong arm
            } else {
                glColor3f(0.7f, 0.5f, 0.3f); // Monkey skin color
            }
            drawSphere(0.8f, 16, 16);
          

            //drawFurOnSphere(0.8f, 20); // Dense fur on shoulder

            //if (armIndex == 0) {
            //    glRotatef(90, 0, 0, 1);   // left arm
            //}
            //else {
            //    glRotatef(-90, 0, 0, 1);  // right arm
            //}
            glRotatef(-90, 0, 0, 1);   // left arm

            // Now apply the swing forward/back
            glRotatef(armSwingAngle[armIndex], 1, 0, 0);

        
            // Upper arm
            glPushMatrix();
                glColor3f(0.8f, 0.6f, 0.4f); // Monkey skin
                drawCylinder(0.6f, 3.0f, 16);
                //drawFurOnCylinder(0.6f, 3.0f, 35); // Dense fur on upper arm
            
                // Muscle definition with fur
                glTranslatef(0, 0, 1.5f);
                glColor3f(0.75f, 0.55f, 0.35f);
                drawSphere(0.7f, 12, 12);
                //drawFurOnSphere(0.7f, 18);
            glPopMatrix();

            // draw upper arm fur
            drawFurFromArray(upperArmFur[armIndex]);
        
            // Move to elbow
            glTranslatef(0, 0, 3.0f);
        
            // Elbow joint
            if (armIndex == activeArm) {
                glColor3f(0.9f, 0.7f, 0.3f); // Golden highlight
            } else {
                glColor3f(0.7f, 0.5f, 0.3f);
            }
            drawSphere(0.7f, 16, 16);
            //drawFurOnSphere(0.7f, 15);
           
            // Forearm rotation
            glRotatef(elbowAngle[armIndex], 1, 0, 0);
        
            // Forearm
            glPushMatrix();
                glColor3f(0.8f, 0.6f, 0.4f);
                drawCylinder(0.5f, 2.5f, 16);

                //drawFurOnCylinder(0.5f, 2.5f, 28); // Fur on forearm
            glPopMatrix();
            drawFurFromArray(palmFur[armIndex]);

            // Move to wrist
            glTranslatef(0, 0, 2.5f);
            drawFurFromArray(forearmFur[armIndex]);
            // Wrist joint
            if (armIndex == activeArm) {
                glColor3f(0.9f, 0.7f, 0.3f); // Golden highlight
            } else {
                glColor3f(0.7f, 0.5f, 0.3f);
            }
            drawSphere(0.5f, 12, 12);
            //drawFurOnSphere(0.5f, 10);
        
            // Wrist rotation
            glRotatef(wristAngle[armIndex], 0, 1, 0);
        
            // Hand
            drawHand(armIndex);
        glPopMatrix();
    }

    void handleInput()
    {
        // Camera rotation
        if (GetAsyncKeyState(VK_UP) & 0x8000) {
            cameraAngleX += 1.0f;
            if (cameraAngleX < -89.0f) cameraAngleX = -89.0f; // limit looking straight down
        }
        if (GetAsyncKeyState(VK_DOWN) & 0x8000) {
            cameraAngleX -= 1.0f;
            if (cameraAngleX > 89.0f) cameraAngleX = 89.0f; // limit looking straight up
        }
        if (GetAsyncKeyState(VK_LEFT) & 0x8000) {
            cameraAngleY += 1.0f;
        }
        if (GetAsyncKeyState(VK_RIGHT) & 0x8000) {
            cameraAngleY -= 1.0f;
        }

        // Camera zoom
        if (GetAsyncKeyState('Z') & 0x8000) {
            cameraDistance -= 0.2f;
            if (cameraDistance < 3.0f) cameraDistance = 3.0f;
        }
        if (GetAsyncKeyState('X') & 0x8000) {
            cameraDistance += 0.2f;
            if (cameraDistance > 40.0f) cameraDistance = 40.0f;
        }
        if (GetAsyncKeyState('W') & 0x8000) {
            isWalking = !isWalking;
        }

    }

    void display()
    {
        //handleInput();

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glLoadIdentity();

        // Set up camera
        glTranslatef(0, 0, -cameraDistance);
        glRotatef(cameraAngleX, 1, 0, 0);
        glRotatef(cameraAngleY, 0, 1, 0);
        // Enable lighting system
        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);
        glEnable(GL_LIGHT1);

        // Light 0 - main white light from top right
        GLfloat lightPos0[] = { 5.0f, 5.0f, 5.0f, 1.0f };
        GLfloat lightDiffuse0[] = { 0.8f, 0.8f, 0.8f, 1.0f };
        GLfloat lightSpec0[] = { 1.0f, 1.0f, 1.0f, 1.0f };
        GLfloat lightAmb0[] = { 0.2f, 0.2f, 0.2f, 1.0f };

        glLightfv(GL_LIGHT0, GL_POSITION, lightPos0);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiffuse0);
        glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec0);
        glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb0);

        // Light 1 - warm fill from front
        GLfloat lightPos1[] = { -3.0f, 2.0f, 6.0f, 1.0f };
        GLfloat lightDiffuse1[] = { 0.8f, 0.6f, 0.4f, 1.0f }; // warm tone
        GLfloat lightSpec1[] = { 0.5f, 0.3f, 0.2f, 1.0f };
        GLfloat lightAmb1[] = { 0.1f, 0.05f, 0.05f, 1.0f };

        glLightfv(GL_LIGHT1, GL_POSITION, lightPos1);
        glLightfv(GL_LIGHT1, GL_DIFFUSE, lightDiffuse1);
        glLightfv(GL_LIGHT1, GL_SPECULAR, lightSpec1);
        glLightfv(GL_LIGHT1, GL_AMBIENT, lightAmb1);

        // Global material properties
        GLfloat matAmbient[] = { 0.3f, 0.2f, 0.15f, 1.0f };
        GLfloat matDiffuse[] = { 0.7f, 0.5f, 0.3f, 1.0f };
        GLfloat matSpecular[] = { 0.3f, 0.3f, 0.3f, 1.0f };
        GLfloat matShininess = 32.0f;

        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, matAmbient);
        glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, matDiffuse);
        glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, matSpecular);
        glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, matShininess);
        glEnable(GL_LIGHT2);
        GLfloat spotPos[] = { 0.0f, 8.0f, 5.0f, 1.0f };
        GLfloat spotDir[] = { 0.0f, -1.0f, -0.3f };
        glLightfv(GL_LIGHT2, GL_POSITION, spotPos);
        glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, spotDir);
        glLightf(GL_LIGHT2, GL_SPOT_CUTOFF, 40.0f);
        glLightf(GL_LIGHT2, GL_SPOT_EXPONENT, 20.0f);


        // Draw both arms
        glPushMatrix();
        glTranslatef(-3.0f, 0, 0); // Position left arm
        drawArm(0); // Left arm
        glPopMatrix();

        glPushMatrix();
        glTranslatef(3.0f, 0, 0); // Position right arm
        drawArm(1); // Right arm
        glPopMatrix();


        if (isWalking) {
            for (int i = 0; i < 2; i++) {
                armSwingAngle[i] += armSwingDir[i] * 1.0f;  // speed

                if (armSwingAngle[i] > 30.0f) {
                    armSwingAngle[i] = 30.0f;
                    armSwingDir[i] = -1;
                }
                if (armSwingAngle[i] < -30.0f) {
                    armSwingAngle[i] = -30.0f;
                    armSwingDir[i] = 1;
                }
            }

        }

            // Camera setup for viewing the monkey tail and vertical legs
            glTranslatef(0.0f, -0.5f, zoom);  // Adjusted for vertical leg positioning
            glRotatef(rotationX, 1.0f, 0.0f, 0.0f);
            glRotatef(rotationY, 0.0f, 1.0f, 0.0f);

            glScalef(2.5f, 2.5f, 2.5f);  // Adjust size for integration

            glTranslatef(0.0f, -2.0f, 5.75);  // Adjust position for integration

            // Draw the simple head
            drawSimpleHead();

            // Draw the muscular upper torso above the middle body
            drawMuscularUpperTorso();

            // Draw the simple upper body to connect tail and legs
            drawUpperBody();

            // Draw the simple legs with proper vertical orientation
            drawSimpleLegs();

            // Draw the monkey tail
            drawMonkeyTail();

            glDisable(GL_LIGHTING);
            glFlush();
        
    }

    int WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR, int nCmdShow)
    {
        WNDCLASSEX wc;
        myTexture = loadTexture("fur.bmp");

        ZeroMemory(&wc, sizeof(WNDCLASSEX));
        wc.cbSize = sizeof(WNDCLASSEX);
        wc.hInstance = GetModuleHandle(NULL);
        wc.lpfnWndProc = WindowProcedure;
        wc.lpszClassName = WINDOW_TITLE;
        wc.style = CS_HREDRAW | CS_VREDRAW;
        if (!RegisterClassEx(&wc)) return false;

        HWND hWnd = CreateWindow(WINDOW_TITLE, WINDOW_TITLE, WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, 1024, 768,
            NULL, NULL, wc.hInstance, NULL);

        HDC hdc = GetDC(hWnd);
        initPixelFormat(hdc);
        HGLRC hglrc = wglCreateContext(hdc);
        if (!wglMakeCurrent(hdc, hglrc)) return false;

        // OpenGL initialization
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_TEXTURE_2D);
        glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

        glEnable(GL_COLOR_MATERIAL);
        glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
        glEnable(GL_NORMALIZE);
        glClearColor(0.05f, 0.05f, 0.1f, 1.0f); // Darker background for Wukong
       

        // Initialize random seed for fur generation
        srand(12345); // Fixed seed for consistent fur pattern
        precomputeAllFur();

        // Set up perspective projection
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(45.0, 1024.0/768.0, 0.1, 100.0);
        glMatrixMode(GL_MODELVIEW);

        ShowWindow(hWnd, nCmdShow);
    
        MSG msg;
        ZeroMemory(&msg, sizeof(msg));
        while (true)
        {
            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (msg.message == WM_QUIT) break;
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            display();
            SwapBuffers(hdc);
            Sleep(16); // ~60 FPS
        }

        UnregisterClass(WINDOW_TITLE, wc.hInstance);
        return true;
    }


/// BOTTOm

// Function to draw simple legs like the image
    void drawSimpleLegs() {
        // Use the same authentic monkey fur colors from the tail
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights  
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows
        GLfloat furUnderside[] = { 0.75f, 0.55f, 0.35f, 1.0f };    // Lighter underside
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };        // Pink skin patches

        // Draw left leg - positioned to the left
        glPushMatrix();
        glTranslatef(-0.6f, 0.0f, 0.0f);  // Position left leg
        drawSimpleLeg(true);
        glPopMatrix();

        // Draw right leg - positioned to the right
        glPushMatrix();
        glTranslatef(0.6f, 0.0f, 0.0f);   // Position right leg
        drawSimpleLeg(false);
        glPopMatrix();
    }

    // Function to draw a single realistic human-like leg
    void drawSimpleLeg(bool isLeft) {
        // Enhanced colors with more variation for realistic skin/fur tones
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };
        GLfloat jointColor[] = { 0.40f, 0.25f, 0.15f, 1.0f };
        GLfloat muscleHighlight[] = { 0.55f, 0.35f, 0.22f, 1.0f };
        GLfloat muscleDefinition[] = { 0.35f, 0.22f, 0.12f, 1.0f };

        glPushMatrix();

        // === REALISTIC UPPER LEG (THIGH) === - Human-like muscular structure
        glColor3fv(furBase);

        // Main thigh muscle mass - larger and more defined
        glPushMatrix();
        glTranslatef(0.0f, 0.3f, 0.0f);  // Adjusted Y position for better connection
        glScalef(0.35f, 0.9f, 0.35f);  // Extended height for overlap
        GLUquadric* mainThigh = gluNewQuadric();
        gluQuadricNormals(mainThigh, GLU_SMOOTH);
        gluSphere(mainThigh, 1.0f, 24, 24);  // Higher resolution
        gluDeleteQuadric(mainThigh);
        glPopMatrix();

        // Quadriceps muscle definition (front)
        glColor3fv(muscleHighlight);
        for (int i = 0; i < 3; i++) {
            float angle = (i - 1) * 0.4f;
            glPushMatrix();
            glTranslatef(sinf(angle) * 0.12f, 0.2f, cosf(angle) * 0.08f + 0.25f); // Adjusted Y
            glScalef(0.08f, 0.7f, 0.12f);  // Extended height
            GLUquadric* quad = gluNewQuadric();
            gluQuadricNormals(quad, GLU_SMOOTH);
            gluSphere(quad, 1.0f, 16, 16);
            gluDeleteQuadric(quad);
            glPopMatrix();
        }

        // Hamstring muscles (back)
        glColor3fv(muscleDefinition);
        for (int i = 0; i < 2; i++) {
            float sideOffset = (i == 0) ? -0.08f : 0.08f;
            glPushMatrix();
            glTranslatef(sideOffset, 0.1f, -0.2f);  // Adjusted Y
            glScalef(0.1f, 0.8f, 0.15f);  // Extended height
            GLUquadric* hamstring = gluNewQuadric();
            gluQuadricNormals(hamstring, GLU_SMOOTH);
            gluSphere(hamstring, 1.0f, 16, 16);
            gluDeleteQuadric(hamstring);
            glPopMatrix();
        }

        // Outer thigh muscle (vastus lateralis)
        glColor3fv(furLight);
        glPushMatrix();
        glTranslatef(0.25f, 0.0f, 0.05f);  // Adjusted Y
        glScalef(0.12f, 0.9f, 0.2f);  // Extended height
        GLUquadric* outerThigh = gluNewQuadric();
        gluQuadricNormals(outerThigh, GLU_SMOOTH);
        gluSphere(outerThigh, 1.0f, 16, 16);
        gluDeleteQuadric(outerThigh);
        glPopMatrix();

        // Inner thigh muscle (adductors)
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(-0.2f, -0.1f, 0.1f);  // Adjusted Y
        glScalef(0.15f, 1.0f, 0.18f);  // Extended height
        GLUquadric* innerThigh = gluNewQuadric();
        gluQuadricNormals(innerThigh, GLU_SMOOTH);
        gluSphere(innerThigh, 1.0f, 16, 16);
        gluDeleteQuadric(innerThigh);
        glPopMatrix();

        // === SEAMLESS THIGH-TO-KNEE TRANSITION === - Bridge connecting upper and lower leg
        glColor3fv(jointColor);
        glPushMatrix();
        glTranslatef(0.0f, -0.5f, 0.0f);  // Positioned between thigh and knee
        glScalef(0.28f, 0.4f, 0.28f);  // Large transition area
        GLUquadric* thighKneeConnector = gluNewQuadric();
        gluQuadricNormals(thighKneeConnector, GLU_SMOOTH);
        gluSphere(thighKneeConnector, 1.0f, 20, 20);
        gluDeleteQuadric(thighKneeConnector);
        glPopMatrix();

        // === ENHANCED KNEE JOINT === - More realistic knee structure with overlap
        glPushMatrix();
        glTranslatef(0.0f, -0.8f, 0.0f);  // Moved up for better connection
        glColor3fv(jointColor);

        // Main knee joint - larger for seamless connection
        GLUquadric* knee = gluNewQuadric();
        gluQuadricNormals(knee, GLU_SMOOTH);
        gluSphere(knee, 0.26f, 20, 20);  // Larger for better overlap
        gluDeleteQuadric(knee);

        // Kneecap (patella)
        glColor3fv(furLight);
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.2f);
        glScalef(0.14f, 0.17f, 0.1f);
        GLUquadric* kneecap = gluNewQuadric();
        gluQuadricNormals(kneecap, GLU_SMOOTH);
        gluSphere(kneecap, 1.0f, 16, 16);
        gluDeleteQuadric(kneecap);
        glPopMatrix();
        glPopMatrix();

        // === SEAMLESS KNEE-TO-CALF CONNECTOR === - Eliminates gap between knee and lower leg
        glColor3fv(muscleHighlight);
        glPushMatrix();
        glTranslatef(0.0f, -1.1f, 0.0f);  // Between knee and calf
        glScalef(0.24f, 0.3f, 0.24f);  // Connecting bridge
        GLUquadric* kneeCalfConnector = gluNewQuadric();
        gluQuadricNormals(kneeCalfConnector, GLU_SMOOTH);
        gluSphere(kneeCalfConnector, 1.0f, 18, 18);
        gluDeleteQuadric(kneeCalfConnector);
        glPopMatrix();

        // === REALISTIC LOWER LEG (CALF AND SHIN) === - Human-like structure with seamless connection

        // Main calf muscle (gastrocnemius) - back of leg, extended upward
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -1.3f, -0.05f);  // Moved up for connection
        glScalef(0.25f, 0.9f, 0.3f);  // Extended height for overlap
        GLUquadric* mainCalf = gluNewQuadric();
        gluQuadricNormals(mainCalf, GLU_SMOOTH);
        gluSphere(mainCalf, 1.0f, 20, 20);
        gluDeleteQuadric(mainCalf);
        glPopMatrix();

        // Split gastrocnemius heads (medial and lateral) - extended upward
        glColor3fv(muscleHighlight);
        for (int i = 0; i < 2; i++) {
            float sideOffset = (i == 0) ? -0.08f : 0.08f;
            glPushMatrix();
            glTranslatef(sideOffset, -1.2f, 0.1f);  // Moved up
            glScalef(0.1f, 0.7f, 0.15f);  // Extended height
            GLUquadric* calfHead = gluNewQuadric();
            gluQuadricNormals(calfHead, GLU_SMOOTH);
            gluSphere(calfHead, 1.0f, 16, 16);
            gluDeleteQuadric(calfHead);
            glPopMatrix();
        }

        // Soleus muscle (deeper calf muscle) - extended upward
        glColor3fv(muscleDefinition);
        glPushMatrix();
        glTranslatef(0.0f, -1.5f, -0.1f);  // Moved up
        glScalef(0.18f, 0.6f, 0.2f);  // Extended height
        GLUquadric* soleus = gluNewQuadric();
        gluQuadricNormals(soleus, GLU_SMOOTH);
        gluSphere(soleus, 1.0f, 16, 16);
        gluDeleteQuadric(soleus);
        glPopMatrix();

        // Shin area (tibia) - front of lower leg, extended upward
        glColor3fv(furLight);
        glPushMatrix();
        glTranslatef(0.0f, -1.4f, 0.25f);  // Moved up
        glScalef(0.15f, 0.8f, 0.12f);  // Extended height
        GLUquadric* shin = gluNewQuadric();
        gluQuadricNormals(shin, GLU_SMOOTH);
        gluSphere(shin, 1.0f, 16, 16);
        gluDeleteQuadric(shin);
        glPopMatrix();

        // Fibula (outer lower leg bone area) - extended upward
        glColor3fv(furDark);
        glPushMatrix();
        glTranslatef(0.15f, -1.3f, 0.1f);  // Moved up
        glScalef(0.08f, 0.9f, 0.1f);  // Extended height
        GLUquadric* fibula = gluNewQuadric();
        gluQuadricNormals(fibula, GLU_SMOOTH);
        gluSphere(fibula, 1.0f, 12, 12);
        gluDeleteQuadric(fibula);
        glPopMatrix();

        // === COMPLETE LEG MUSCLE COVERAGE === - Fill any remaining gaps
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -0.9f, 0.0f);  // Mid-leg coverage
        glScalef(0.22f, 0.5f, 0.22f);  // Complete coverage
        GLUquadric* midLegFill = gluNewQuadric();
        gluQuadricNormals(midLegFill, GLU_SMOOTH);
        gluSphere(midLegFill, 1.0f, 16, 16);
        gluDeleteQuadric(midLegFill);
        glPopMatrix();

        // === ENHANCED ANKLE AREA === - More realistic ankle structure
        glPushMatrix();
        glTranslatef(0.0f, -2.1f, 0.0f);  // Moved up for better connection
        glColor3fv(jointColor);

        // Main ankle joint - larger for better connection
        GLUquadric* ankle = gluNewQuadric();
        gluQuadricNormals(ankle, GLU_SMOOTH);
        gluSphere(ankle, 0.20f, 18, 18);  // Larger for overlap
        gluDeleteQuadric(ankle);

        // Ankle bones (malleoli) - inner and outer ankle bones
        glColor3fv(furLight);
        for (int i = 0; i < 2; i++) {
            float sideOffset = (i == 0) ? -0.12f : 0.12f;
            glPushMatrix();
            glTranslatef(sideOffset, 0.0f, 0.0f);
            glScalef(0.06f, 0.08f, 0.06f);
            GLUquadric* malleolus = gluNewQuadric();
            gluQuadricNormals(malleolus, GLU_SMOOTH);
            gluSphere(malleolus, 1.0f, 12, 12);
            gluDeleteQuadric(malleolus);
            glPopMatrix();
        }
        glPopMatrix();

        // === SEAMLESS ANKLE CONNECTOR === - Enhanced bridge for perfect foot connection
        glPushMatrix();
        glTranslatef(0.0f, -2.2f, 0.0f);  // Positioned to overlap with both ankle and foot
        glColor3fv(jointColor);
        GLUquadric* ankleConnector = gluNewQuadric();
        gluQuadricNormals(ankleConnector, GLU_SMOOTH);
        gluCylinder(ankleConnector, 0.19f, 0.17f, 0.3f, 20, 1);  // Larger bridge cylinder

        // Add connector caps for complete sealing
        GLUquadric* connectorTop = gluNewQuadric();
        gluQuadricOrientation(connectorTop, GLU_INSIDE);
        gluDisk(connectorTop, 0.0f, 0.19f, 20, 1);
        gluDeleteQuadric(connectorTop);

        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.3f);
        GLUquadric* connectorBottom = gluNewQuadric();
        gluDisk(connectorBottom, 0.0f, 0.17f, 20, 1);
        gluDeleteQuadric(connectorBottom);
        glPopMatrix();
        gluDeleteQuadric(ankleConnector);
        glPopMatrix();

        // === ACHILLES TENDON === - Realistic tendon connection
        glColor3fv(furDark);
        glPushMatrix();
        glTranslatef(0.0f, -1.9f, -0.15f);  // Moved up for connection
        glScalef(0.06f, 0.5f, 0.08f);  // Extended height
        GLUquadric* achilles = gluNewQuadric();
        gluQuadricNormals(achilles, GLU_SMOOTH);
        gluSphere(achilles, 1.0f, 12, 12);
        gluDeleteQuadric(achilles);
        glPopMatrix();

        // === ENHANCED FOOT === - Positioned to COMPLETELY OVERLAP with ankle connector
        glPushMatrix();
        glTranslatef(0.0f, -2.35f, 0.0f);  // Adjusted for perfect overlap with connector
        drawSimpleFoot(isLeft);
        glPopMatrix();

        glPopMatrix();
    }

    // Function to draw a simple foot with five toes - Enhanced with seamless connections
    void drawSimpleFoot(bool isLeft) {
        // Same colors as the tail
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };
        GLfloat jointColor[] = { 0.40f, 0.25f, 0.15f, 1.0f };

        glPushMatrix();

        // === EXTENDED ANKLE OVERLAP === - Large overlap area to eliminate all gaps
        glColor3fv(jointColor);
        glPushMatrix();
        glTranslatef(0.0f, 0.1f, 0.0f);  // Large overlap with ankle connector
        GLUquadric* ankleOverlap = gluNewQuadric();
        gluQuadricNormals(ankleOverlap, GLU_SMOOTH);
        gluSphere(ankleOverlap, 0.15f, 16, 16);  // Larger overlap sphere
        gluDeleteQuadric(ankleOverlap);
        glPopMatrix();

        // === TRANSITION ZONE === - Smooth transition from ankle to foot
        glPushMatrix();
        glColor3fv(jointColor);
        glTranslatef(0.0f, 0.0f, 0.0f);
        glRotatef(-90, 1, 0, 0);  // Vertical orientation
        GLUquadric* transition = gluNewQuadric();
        gluQuadricNormals(transition, GLU_SMOOTH);
        gluCylinder(transition, 0.14f, 0.13f, 0.25f, 16, 1);  // Smooth transition

        // Add transition caps
        GLUquadric* transTop = gluNewQuadric();
        gluQuadricOrientation(transTop, GLU_INSIDE);
        gluDisk(transTop, 0.0f, 0.14f, 16, 1);
        gluDeleteQuadric(transTop);

        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.25f);
        GLUquadric* transBottom = gluNewQuadric();
        gluDisk(transBottom, 0.0f, 0.13f, 16, 1);
        gluDeleteQuadric(transBottom);
        glPopMatrix();
        gluDeleteQuadric(transition);
        glPopMatrix();

        // === MAIN FOOT BODY === - Enhanced shape and connection
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -0.2f, 0.3f);  // Positioned to overlap with transition
        glScalef(1.0f, 0.4f, 2.2f);  // Larger proportions for better coverage
        GLUquadric* footBody = gluNewQuadric();
        gluQuadricNormals(footBody, GLU_SMOOTH);
        gluSphere(footBody, 0.25f, 20, 16);
        gluDeleteQuadric(footBody);
        glPopMatrix();

        // === COMPLETELY SEAMLESS SOLE === - Covers entire bottom with overlaps
        glPushMatrix();
        glColor3fv(skinPink);
        glTranslatef(0.0f, -0.5f, 0.3f);  // Positioned to cover everything
        glRotatef(90, 1, 0, 0);
        glScalef(0.95f, 2.1f, 0.15f);  // Even larger and thicker sole
        GLUquadric* sole = gluNewQuadric();
        gluQuadricNormals(sole, GLU_SMOOTH);

        // Draw main sole disk - much larger
        gluDisk(sole, 0.0f, 0.3f, 24, 1);

        // Add thick sole edge for complete coverage
        gluQuadricOrientation(sole, GLU_OUTSIDE);
        gluCylinder(sole, 0.3f, 0.3f, 1.0f, 24, 1);

        // Add top sole cap for complete sealing
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 1.0f);
        gluDisk(sole, 0.0f, 0.3f, 24, 1);
        glPopMatrix();

        gluDeleteQuadric(sole);
        glPopMatrix();

        // === ENHANCED HEEL === - Better connection to foot body with overlap
        glPushMatrix();
        glColor3fv(furDark);
        glTranslatef(0.0f, -0.15f, -0.1f);  // Overlaps with foot body
        GLUquadric* heel = gluNewQuadric();
        gluQuadricNormals(heel, GLU_SMOOTH);
        gluSphere(heel, 0.25f, 16, 12);  // Larger for better coverage
        gluDeleteQuadric(heel);
        glPopMatrix();

        // === COMPLETE ARCH FILLING === - Fills all gaps between heel and main foot
        glPushMatrix();
        glColor3fv(furBase);
        glTranslatef(0.0f, -0.25f, 0.05f);
        glScalef(0.8f, 0.25f, 0.7f);
        GLUquadric* arch = gluNewQuadric();
        gluQuadricNormals(arch, GLU_SMOOTH);
        gluSphere(arch, 0.25f, 16, 12);
        gluDeleteQuadric(arch);
        glPopMatrix();

        // === SIDE COVERAGE === - Fills any remaining side gaps
        for (int side = -1; side <= 1; side += 2) {
            glPushMatrix();
            glColor3fv(furBase);
            glTranslatef(side * 0.2f, -0.2f, 0.15f);
            glScalef(0.15f, 0.3f, 0.6f);
            GLUquadric* sideFill = gluNewQuadric();
            gluQuadricNormals(sideFill, GLU_SMOOTH);
            gluSphere(sideFill, 0.25f, 12, 10);
            gluDeleteQuadric(sideFill);
            glPopMatrix();
        }

        // === ENHANCED FIVE TOES === - Better proportioned and positioned
        for (int toe = 0; toe < 5; toe++) {
            float toeX = (toe - 2) * 0.13f;  // Better spacing
            float toeLength = 0.18f - abs(toe - 2) * 0.025f;  // More natural variation
            float toeWidth = 0.06f - abs(toe - 2) * 0.008f;   // Better proportions

            glPushMatrix();
            glTranslatef(toeX, -0.15f, 0.85f);  // Better positioned on foot
            drawSimpleToe(toeLength, toeWidth);
            glPopMatrix();
        }

        // === COMPLETE TOP COVERAGE === - Ensures no gaps on top of foot
        glPushMatrix();
        glColor3fv(furBase);
        glTranslatef(0.0f, 0.05f, 0.2f);
        glScalef(0.7f, 0.2f, 1.0f);
        GLUquadric* topCoverage = gluNewQuadric();
        gluQuadricNormals(topCoverage, GLU_SMOOTH);
        gluSphere(topCoverage, 0.2f, 16, 12);
        gluDeleteQuadric(topCoverage);
        glPopMatrix();
    }

    // Function to draw a simple toe - Enhanced details
    void drawSimpleToe(float length, float width) {
        // Same colors as the tail
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };
        GLfloat furMid[] = { 0.55f, 0.35f, 0.22f, 1.0f };  // Mid-tone color for variety

        glPushMatrix();

        // === ENHANCED TOE BODY === - Better shape and connection
        glColor3fv(furBase);
        glPushMatrix();
        glScalef(width, width * 0.85f, length);
        GLUquadric* toeBody = gluNewQuadric();
        gluQuadricNormals(toeBody, GLU_SMOOTH);
        gluSphere(toeBody, 1.0f, 12, 10);
        gluDeleteQuadric(toeBody);
        glPopMatrix();

        // === TOE JOINT === - Mid-toe articulation
        glPushMatrix();
        glColor3fv(furMid);
        glTranslatef(0.0f, 0.0f, length * 0.6f);
        GLUquadric* toeJoint = gluNewQuadric();
        gluQuadricNormals(toeJoint, GLU_SMOOTH);
        gluSphere(toeJoint, width * 0.8f, 10, 8);
        gluDeleteQuadric(toeJoint);
        glPopMatrix();

        // === ENHANCED TOE TIP/NAIL === - Better positioned and shaped
        glPushMatrix();
        glColor3fv(skinPink);
        glTranslatef(0.0f, width * 0.2f, length * 0.9f);
        GLUquadric* toeTip = gluNewQuadric();
        gluQuadricNormals(toeTip, GLU_SMOOTH);
        gluSphere(toeTip, width * 0.35f, 8, 8);
        gluDeleteQuadric(toeTip);
        glPopMatrix();

        // === TOE KNUCKLE === - Adds realistic detail
        glPushMatrix();
        glColor3fv(furBase);
        glTranslatef(0.0f, width * 0.4f, length * 0.3f);
        GLUquadric* toeKnuckle = gluNewQuadric();
        gluQuadricNormals(toeKnuckle, GLU_SMOOTH);
        gluSphere(toeKnuckle, width * 0.6f, 8, 6);
        gluDeleteQuadric(toeKnuckle);
        glPopMatrix();

        glPopMatrix();
    }

    // Function to draw a simple rectangular upper body that connects tail and legs
    void drawUpperBody() {
        // Use the same authentic monkey fur colors from the tail and legs
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights  
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows
        GLfloat muscleHighlight[] = { 0.55f, 0.35f, 0.22f, 1.0f };  // Muscle definition

        glPushMatrix();

        // Position the upper body to connect with the legs at the top and tail at the back
        glTranslatef(0.0f, 1.2f, 0.0f);  // Positioned above the legs

        // === MAIN TORSO (PROPORTIONAL) === - Better proportioned rectangular shape
        glColor3fv(furBase);
        glPushMatrix();
        glScalef(1.1f, 1.2f, 0.7f);  // REDUCED: More proportional to legs
        GLUquadric* torso = gluNewQuadric();
        gluQuadricNormals(torso, GLU_SMOOTH);
        gluSphere(torso, 0.8f, 20, 16);  // Using sphere but scaled to be rectangular
        gluDeleteQuadric(torso);
        glPopMatrix();

        // === ENHANCED BACK MUSCLES === - Spine and back definition  
        glColor3fv(furDark);
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, -0.45f);  // Slightly reduced back extension
        glScalef(0.9f, 1.0f, 0.25f);  // Proportionally reduced back area
        GLUquadric* back = gluNewQuadric();
        gluQuadricNormals(back, GLU_SMOOTH);
        gluSphere(back, 0.8f, 16, 12);
        gluDeleteQuadric(back);
        glPopMatrix();

        // === TAIL CONNECTION AREA === - Specific area where tail attaches
        glColor3fv(furBase);
        glPushMatrix();
        // Position to match tail base at (0.0f, 1.1f, -0.8f) 
        glTranslatef(0.0f, -0.1f, -0.8f);  // Connect at tail attachment point
        GLUquadric* tailConnection = gluNewQuadric();
        gluQuadricNormals(tailConnection, GLU_SMOOTH);
        gluSphere(tailConnection, 0.25f, 20, 16);  // Connection point for tail
        gluDeleteQuadric(tailConnection);
        glPopMatrix();

        // === LOWER TORSO CONNECTION (PROPORTIONAL) === - Connects to the top of legs
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -0.8f, 0.0f);  // Lower part to connect with legs
        glScalef(1.0f, 0.5f, 0.45f);  // Proportionally reduced lower torso
        GLUquadric* lowerTorso = gluNewQuadric();
        gluQuadricNormals(lowerTorso, GLU_SMOOTH);
        gluSphere(lowerTorso, 0.8f, 16, 12);
        gluDeleteQuadric(lowerTorso);
        glPopMatrix();

        // === LEG CONNECTION POINTS (PROPORTIONAL) === - Seamless connection to legs
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(muscleHighlight);
            glPushMatrix();
            glTranslatef(side * 0.35f, -1.0f, 0.0f);  // Slightly closer hip connections
            GLUquadric* hipConnection = gluNewQuadric();
            gluQuadricNormals(hipConnection, GLU_SMOOTH);
            gluSphere(hipConnection, 0.28f, 16, 12);  // Slightly smaller hip connections
            gluDeleteQuadric(hipConnection);
            glPopMatrix();
        }

        // === NECK AREA (PROPORTIONAL) === - Simple neck connection point for potential head
        glColor3fv(furLight);
        glPushMatrix();
        glTranslatef(0.0f, 0.9f, 0.0f);  // Slightly lower position
        GLUquadric* neck = gluNewQuadric();
        gluQuadricNormals(neck, GLU_SMOOTH);
        gluSphere(neck, 0.18f, 12, 10);  // Slightly smaller neck
        gluDeleteQuadric(neck);
        glPopMatrix();

        // === ENHANCED SPINAL CONNECTION === - Better connection to tail
        glColor3fv(furDark);
        glPushMatrix();
        glTranslatef(0.0f, 0.4f, -0.55f);  // Adjusted spinal area leading to tail
        glScalef(0.12f, 0.7f, 0.35f);  // Proportionally adjusted spine ridge
        GLUquadric* spine = gluNewQuadric();
        gluQuadricNormals(spine, GLU_SMOOTH);
        gluSphere(spine, 0.8f, 12, 10);
        gluDeleteQuadric(spine);
        glPopMatrix();

        // === SIDE MUSCLES (PROPORTIONAL) === - Enhanced side muscle definition
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(muscleHighlight);
            glPushMatrix();
            glTranslatef(side * 0.6f, 0.0f, 0.08f);  // Adjusted side muscle placement
            glScalef(0.22f, 0.85f, 0.35f);  // Proportionally reduced side muscles
            GLUquadric* sideMuscle = gluNewQuadric();
            gluQuadricNormals(sideMuscle, GLU_SMOOTH);
            gluSphere(sideMuscle, 0.8f, 14, 12);
            gluDeleteQuadric(sideMuscle);
            glPopMatrix();
        }

        glPopMatrix();
    }

    // Function to draw a detailed muscular upper torso above the middle body
    void drawMuscularUpperTorso() {
        // Enhanced authentic colors for gym-fit physique with six-pack focus
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights  
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows
        GLfloat muscleHighlight[] = { 0.55f, 0.35f, 0.22f, 1.0f };  // Muscle definition
        GLfloat muscleDefinition[] = { 0.35f, 0.22f, 0.12f, 1.0f }; // Deep muscle definition
        GLfloat jointColor[] = { 0.40f, 0.25f, 0.15f, 1.0f };      // Joint definition
        GLfloat veins[] = { 0.25f, 0.15f, 0.08f, 1.0f };           // Vascular definition
        GLfloat abColor[] = { 0.60f, 0.40f, 0.25f, 1.0f };         // Enhanced ab color

        // Enhanced breathing motion for realistic muscle movement
        float breathingMotion = sinf(animationTime * 0.3f) * 0.08f;
        float musclePump = sinf(animationTime * 0.2f) * 0.05f + 0.95f; // Muscle pump cycle

        glPushMatrix();

        // Position the upper torso above the current middle body
        glTranslatef(0.0f, 2.8f, 0.0f);  // Positioned well above the middle body

        // === MAIN UPPER TORSO === - Athletic proportions without being oversized
        glColor3fv(furBase);
        glPushMatrix();
        glScalef(1.3f * musclePump, 1.9f + breathingMotion, 0.8f);  // REDUCED: More proportional athletic build
        GLUquadric* upperTorso = gluNewQuadric();
        gluQuadricNormals(upperTorso, GLU_SMOOTH);
        gluSphere(upperTorso, 0.8f, 28, 24);  // Ultra-high resolution for detail
        gluDeleteQuadric(upperTorso);
        glPopMatrix();

        // === ENHANCED SIX-PACK ABDOMINAL MUSCLES === - Gym-fit definition
        // Main six-pack structure (3 rows ?2 columns = 6 pack)
        for (int row = 0; row < 3; row++) {
            for (int col = -1; col <= 1; col += 2) {
                glColor3fv(abColor);
                glPushMatrix();
                glTranslatef(col * 0.16f, 0.4f - row * 0.22f, 0.42f);  // Slightly adjusted positioning
                glScalef(0.13f + breathingMotion * 0.15f, 0.13f + breathingMotion * 0.08f, 0.11f);  // Proportionally reduced
                GLUquadric* ab = gluNewQuadric();
                gluQuadricNormals(ab, GLU_SMOOTH);
                gluSphere(ab, 0.9f, 20, 18);
                gluDeleteQuadric(ab);
                glPopMatrix();
            }
        }

        // Enhanced abdominal definition with deeper cuts
        for (int i = 0; i < 3; i++) {
            // Vertical separation (linea alba) - deeper and more prominent
            glColor3fv(veins);
            glPushMatrix();
            glTranslatef(0.0f, 0.35f - i * 0.22f, 0.41f);  // Adjusted positioning
            glScalef(0.025f, 0.18f, 0.07f);  // Proportionally adjusted
            GLUquadric* abSep = gluNewQuadric();
            gluQuadricNormals(abSep, GLU_SMOOTH);
            gluSphere(abSep, 0.9f, 14, 12);
            gluDeleteQuadric(abSep);
            glPopMatrix();

            // Horizontal separations between rows
            if (i < 2) {
                glPushMatrix();
                glTranslatef(0.0f, 0.23f - i * 0.22f, 0.41f);  // Adjusted positioning
                glScalef(0.3f, 0.02f, 0.07f);  // Proportionally adjusted
                GLUquadric* abHorizSep = gluNewQuadric();
                gluQuadricNormals(abHorizSep, GLU_SMOOTH);
                gluSphere(abHorizSep, 0.9f, 14, 12);
                gluDeleteQuadric(abHorizSep);
                glPopMatrix();
            }
        }

        // Additional ab muscle detail for each individual ab
        for (int row = 0; row < 3; row++) {
            for (int col = -1; col <= 1; col += 2) {
                // Individual ab muscle fibers
                glColor3fv(muscleDefinition);
                for (int fiber = 0; fiber < 3; fiber++) {
                    glPushMatrix();
                    glTranslatef(col * (0.14f + fiber * 0.008f), 0.38f - row * 0.22f + fiber * 0.015f, 0.43f);  // Adjusted
                    glScalef(0.035f, 0.035f, 0.018f);  // Proportionally reduced
                    GLUquadric* abFiber = gluNewQuadric();
                    gluQuadricNormals(abFiber, GLU_SMOOTH);
                    gluSphere(abFiber, 0.8f, 12, 10);
                    gluDeleteQuadric(abFiber);
                    glPopMatrix();
                }
            }
        }

        // === OBLIQUE MUSCLES === - Side ab definition
        for (int side = -1; side <= 1; side += 2) {
            for (int i = 0; i < 4; i++) {
                glColor3fv(muscleHighlight);
                glPushMatrix();
                glTranslatef(side * (0.35f + i * 0.04f), 0.25f - i * 0.13f, 0.35f);  // Proportionally adjusted
                glScalef(0.07f, 0.08f, 0.07f);  // Proportionally reduced
                GLUquadric* oblique = gluNewQuadric();
                gluQuadricNormals(oblique, GLU_SMOOTH);
                gluSphere(oblique, 0.9f, 16, 14);
                gluDeleteQuadric(oblique);
                glPopMatrix();
            }
        }

        // === PROPORTIONAL DELTOID MUSCLES === - Well-developed but not oversized
        for (int side = -1; side <= 1; side += 2) {
            // Main deltoid mass
            glColor3fv(muscleHighlight);
            glPushMatrix();
            glTranslatef(side * 0.85f, 0.5f, 0.0f);  // Slightly closer
            GLUquadric* mainDeltoid = gluNewQuadric();
            gluQuadricNormals(mainDeltoid, GLU_SMOOTH);
            gluSphere(mainDeltoid, 0.42f * musclePump, 24, 20);  // REDUCED: More proportional deltoids
            gluDeleteQuadric(mainDeltoid);
            glPopMatrix();

            // Three deltoid heads with good definition
            for (int i = 0; i < 3; i++) {
                float deltaAngle = (i - 1) * 1.0f; // Front, middle, back deltoid

                // Varying colors and sizes for each deltoid head
                if (i == 0) {
                    glColor3fv(furLight);          // Anterior (front) - largest
                }
                else if (i == 1) {
                    glColor3fv(muscleHighlight);   // Medial (middle) - peaked
                }
                else {
                    glColor3fv(muscleDefinition);  // Posterior (back) - deep
                }

                glPushMatrix();
                glTranslatef(side * 0.72f, 0.42f + i * 0.07f, sinf(deltaAngle) * 0.22f);  // Proportionally adjusted
                glScalef(0.22f + i * 0.04f, 0.3f + i * 0.08f, 0.26f + i * 0.04f);  // Proportionally reduced
                GLUquadric* deltoidPart = gluNewQuadric();
                gluQuadricNormals(deltoidPart, GLU_SMOOTH);
                gluSphere(deltoidPart, 0.9f, 20, 16);
                gluDeleteQuadric(deltoidPart);
                glPopMatrix();
            }

            // Deltoid striations (muscle fibers)
            for (int j = 0; j < 4; j++) {
                glColor3fv(veins);
                glPushMatrix();
                glTranslatef(side * (0.76f + j * 0.018f), 0.35f + j * 0.08f, j * 0.04f);  // Proportionally adjusted
                glScalef(0.07f, 0.17f, 0.08f);  // Proportionally reduced
                GLUquadric* deltoidStriation = gluNewQuadric();
                gluQuadricNormals(deltoidStriation, GLU_SMOOTH);
                gluSphere(deltoidStriation, 0.8f, 16, 12);
                gluDeleteQuadric(deltoidStriation);
                glPopMatrix();
            }
        }

        // === PROPORTIONAL LATISSIMUS DORSI === - V-taper but not extreme
        for (int side = -1; side <= 1; side += 2) {
            // Main lat muscle (creates the V-shape)
            glColor3fv(furDark);
            glPushMatrix();
            glTranslatef(side * 0.6f, -0.08f, -0.3f);  // Proportionally adjusted
            glScalef(0.38f * musclePump, 1.0f, 0.35f);  // REDUCED: More proportional V-taper
            glRotatef(side * 22, 0, 0, 1); // Moderate V-angle
            GLUquadric* mainLat = gluNewQuadric();
            gluQuadricNormals(mainLat, GLU_SMOOTH);
            gluSphere(mainLat, 0.8f, 22, 18);
            gluDeleteQuadric(mainLat);
            glPopMatrix();

            // Lat muscle fibers (creates the wing effect)
            for (int i = 0; i < 3; i++) {
                glColor3fv(i == 0 ? veins : (i == 1 ? muscleDefinition : muscleHighlight));
                glPushMatrix();
                glTranslatef(side * (0.5f + i * 0.1f), -0.17f + i * 0.12f, -0.26f);  // Proportionally adjusted
                glScalef(0.15f + i * 0.04f, 0.42f + i * 0.17f, 0.17f);  // Proportionally reduced
                GLUquadric* latFiber = gluNewQuadric();
                gluQuadricNormals(latFiber, GLU_SMOOTH);
                gluSphere(latFiber, 0.8f, 18, 14);
                gluDeleteQuadric(latFiber);
                glPopMatrix();
            }

            // Lower lat insertions
            glColor3fv(muscleDefinition);
            glPushMatrix();
            glTranslatef(side * 0.42f, -0.5f, -0.22f);  // Proportionally adjusted
            glScalef(0.22f, 0.26f, 0.13f);  // Proportionally reduced
            GLUquadric* latInsertion = gluNewQuadric();
            gluQuadricNormals(latInsertion, GLU_SMOOTH);
            gluSphere(latInsertion, 0.8f, 16, 12);
            gluDeleteQuadric(latInsertion);
            glPopMatrix();
        }

        // === PROPORTIONAL TRAPEZIUS MUSCLES === - Well-developed traps
        glColor3fv(muscleHighlight);
        glPushMatrix();
        glTranslatef(0.0f, 0.75f, -0.26f);  // Proportionally adjusted
        glScalef(1.0f * musclePump, 0.5f + breathingMotion, 0.35f);  // REDUCED: More proportional traps
        GLUquadric* mainTrap = gluNewQuadric();
        gluQuadricNormals(mainTrap, GLU_SMOOTH);
        gluSphere(mainTrap, 0.8f, 22, 18);
        gluDeleteQuadric(mainTrap);
        glPopMatrix();

        // Upper trap peaks (controlled size)
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furLight);
            glPushMatrix();
            glTranslatef(side * 0.26f, 0.9f, -0.22f);  // Proportionally adjusted
            glScalef(0.17f, 0.33f + breathingMotion * 0.15f, 0.13f);  // Proportionally reduced
            GLUquadric* trapPeak = gluNewQuadric();
            gluQuadricNormals(trapPeak, GLU_SMOOTH);
            gluSphere(trapPeak, 0.8f, 16, 14);
            gluDeleteQuadric(trapPeak);
            glPopMatrix();

            // Middle trap fibers
            for (int i = 0; i < 3; i++) {
                glColor3fv(i % 2 == 0 ? muscleDefinition : muscleHighlight);
                glPushMatrix();
                glTranslatef(side * (0.22f + i * 0.07f), 0.72f + i * 0.04f, -0.19f);  // Proportionally adjusted
                glScalef(0.07f, 0.13f, 0.07f);  // Proportionally reduced
                GLUquadric* trapFiber = gluNewQuadric();
                gluQuadricNormals(trapFiber, GLU_SMOOTH);
                gluSphere(trapFiber, 0.8f, 14, 12);
                gluDeleteQuadric(trapFiber);
                glPopMatrix();
            }
        }

        // === PROPORTIONAL CONNECTION TO MIDDLE BODY === - Seamless athletic transition
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -1.3f, 0.0f);  // Adjusted connection point
        glScalef(1.1f * musclePump, 0.65f, 0.65f);  // REDUCED: Proportional connection area
        GLUquadric* connection = gluNewQuadric();
        gluQuadricNormals(connection, GLU_SMOOTH);
        gluSphere(connection, 0.8f, 20, 18);
        gluDeleteQuadric(connection);
        glPopMatrix();

        // Proportional connection bridge for seamless attachment
        glColor3fv(jointColor);
        glPushMatrix();
        glTranslatef(0.0f, -1.0f, 0.0f);  // Adjusted positioning
        glRotatef(-90, 1, 0, 0); // Vertical orientation
        GLUquadric* bridge = gluNewQuadric();
        gluQuadricNormals(bridge, GLU_SMOOTH);
        gluCylinder(bridge, 0.28f * musclePump, 0.32f, 0.45f, 20, 3);  // REDUCED: Proportional bridge

        // Enhanced bridge caps
        gluQuadricOrientation(bridge, GLU_INSIDE);
        gluDisk(bridge, 0.0f, 0.28f * musclePump, 20, 1);

        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.45f);
        GLUquadric* bridgeBottom = gluNewQuadric();
        gluQuadricOrientation(bridgeBottom, GLU_OUTSIDE);
        gluDisk(bridgeBottom, 0.0f, 0.32f, 20, 1);
        glPopMatrix();
        gluDeleteQuadric(bridge);
        glPopMatrix();

        glPopMatrix();
    }

    // Function to draw the human-like head with fierce features
    void drawSimpleHead() {
        // Use the SAME COLORS AS TAIL for consistency
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base - SAME AS TAIL
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights - SAME AS TAIL
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows - SAME AS TAIL
        GLfloat furTip[] = { 0.25f, 0.15f, 0.08f, 1.0f };          // Very dark tip - SAME AS TAIL
        GLfloat furUnderside[] = { 0.75f, 0.55f, 0.35f, 1.0f };    // Lighter underside - SAME AS TAIL
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };        // Pink skin patches - SAME AS TAIL
        GLfloat muscleRidge[] = { 0.35f, 0.22f, 0.12f, 1.0f };     // Muscle definition - SAME AS TAIL
        GLfloat vertebraeColor[] = { 0.38f, 0.25f, 0.15f, 1.0f };  // Vertebrae bumps - SAME AS TAIL

        // Enhanced eye and mouth colors for visibility
        GLfloat eyeWhite[] = { 0.95f, 0.95f, 0.95f, 1.0f };        // Bright eye whites
        GLfloat eyeBlue[] = { 0.2f, 0.4f, 0.8f, 1.0f };            // Blue iris
        GLfloat eyeBlack[] = { 0.05f, 0.05f, 0.05f, 1.0f };        // Black pupils
        GLfloat mouthRed[] = { 0.8f, 0.3f, 0.2f, 1.0f };           // Bright red mouth interior
        GLfloat lipColor[] = { 0.6f, 0.35f, 0.25f, 1.0f };         // Natural lip color
        GLfloat teethWhite[] = { 0.95f, 0.95f, 0.90f, 1.0f };      // Teeth color

        // Subtle head animation - breathing and slight movement
        float headBob = sinf(animationTime * 0.4f) * 0.03f;
        float headTilt = sinf(animationTime * 0.3f) * 1.5f;
        float eyeBlink = fabs(sinf(animationTime * 0.8f)) > 0.95f ? 0.3f : 0.0f; // Blinking

        glPushMatrix();

        // Position the head above the muscular upper torso
        glTranslatef(0.0f, 4.2f + headBob, 0.2f);
        glRotatef(headTilt, 0, 0, 1);

        // === MAIN HEAD SHAPE (MONKEY-HUMAN HYBRID) ===
        glColor3fv(furBase);  // Use tail color for base
        glPushMatrix();
        glScalef(0.9f, 1.1f, 0.85f);  // Human-like oval head proportions
        GLUquadric* mainHead = gluNewQuadric();
        gluQuadricNormals(mainHead, GLU_SMOOTH);
        gluSphere(mainHead, 0.6f, 28, 28);
        gluDeleteQuadric(mainHead);
        glPopMatrix();

        // === HUMAN FACIAL STRUCTURE === - Central face area
        glColor3fv(furLight);  // Use tail light color for central face
        glPushMatrix();
        glTranslatef(0.0f, -0.1f, 0.35f);
        glScalef(0.75f, 0.8f, 0.4f);
        GLUquadric* faceStructure = gluNewQuadric();
        gluQuadricNormals(faceStructure, GLU_SMOOTH);
        gluSphere(faceStructure, 0.6f, 24, 24);
        gluDeleteQuadric(faceStructure);
        glPopMatrix();

        // === ENHANCED HUMAN-LIKE EYES ===
        for (int side = -1; side <= 1; side += 2) {
            // Eye socket - deeper and more defined
            glColor3fv(furDark);  // Use tail dark color
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.18f, 0.42f);
            glScalef(0.18f, 0.12f, 0.08f);
            GLUquadric* eyeSocket = gluNewQuadric();
            gluQuadricNormals(eyeSocket, GLU_SMOOTH);
            gluSphere(eyeSocket, 1.0f, 20, 16);
            gluDeleteQuadric(eyeSocket);
            glPopMatrix();

            // Eye white - larger human-like almond shape
            glColor3fv(eyeWhite);
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.18f, 0.48f);
            glScalef(0.16f, 0.09f - eyeBlink, 0.06f);  // Larger eyes with blinking
            GLUquadric* eyeWhitePart = gluNewQuadric();
            gluQuadricNormals(eyeWhitePart, GLU_SMOOTH);
            gluSphere(eyeWhitePart, 1.0f, 20, 16);
            gluDeleteQuadric(eyeWhitePart);
            glPopMatrix();

            // Iris - blue colored human iris
            glColor3fv(eyeBlue);
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.18f, 0.52f);
            GLUquadric* iris = gluNewQuadric();
            gluQuadricNormals(iris, GLU_SMOOTH);
            gluSphere(iris, 0.07f, 16, 16);  // Slightly larger iris
            gluDeleteQuadric(iris);
            glPopMatrix();

            // Pupil - with subtle tracking movement
            float eyeMove = sinf(animationTime * 0.15f + side) * 0.008f;
            glColor3fv(eyeBlack);
            glPushMatrix();
            glTranslatef(side * 0.22f + eyeMove, 0.18f, 0.54f);
            GLUquadric* pupil = gluNewQuadric();
            gluQuadricNormals(pupil, GLU_SMOOTH);
            gluSphere(pupil, 0.03f, 16, 16);
            gluDeleteQuadric(pupil);
            glPopMatrix();

            // Eye highlights for realism
            glColor3fv(eyeWhite);
            glPushMatrix();
            glTranslatef(side * 0.21f, 0.19f, 0.55f);
            GLUquadric* eyeHighlight = gluNewQuadric();
            gluQuadricNormals(eyeHighlight, GLU_SMOOTH);
            gluSphere(eyeHighlight, 0.015f, 12, 10);
            gluDeleteQuadric(eyeHighlight);
            glPopMatrix();

            // Upper eyelid
            glColor3fv(furBase);  // Use tail base color
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.22f, 0.47f);
            glScalef(0.16f, 0.04f, 0.08f);
            GLUquadric* upperEyelid = gluNewQuadric();
            gluQuadricNormals(upperEyelid, GLU_SMOOTH);
            gluSphere(upperEyelid, 1.0f, 16, 12);
            gluDeleteQuadric(upperEyelid);
            glPopMatrix();

            // Lower eyelid
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.14f, 0.47f);
            glScalef(0.16f, 0.03f, 0.08f);
            GLUquadric* lowerEyelid = gluNewQuadric();
            gluQuadricNormals(lowerEyelid, GLU_SMOOTH);
            gluSphere(lowerEyelid, 1.0f, 16, 12);
            gluDeleteQuadric(lowerEyelid);
            glPopMatrix();
        }

        // === FIERCE EYEBROWS ===
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furTip);  // Use tail tip color for dark eyebrows

            // Main eyebrow ridge - angled for fierce look
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.28f, 0.45f);
            glRotatef(side * -15.0f, 0, 0, 1);  // Angled for fierce expression
            glScalef(0.2f, 0.06f, 0.08f);  // Thicker eyebrows
            GLUquadric* eyebrow = gluNewQuadric();
            gluQuadricNormals(eyebrow, GLU_SMOOTH);
            gluSphere(eyebrow, 1.0f, 16, 12);
            gluDeleteQuadric(eyebrow);
            glPopMatrix();
        }

        // === HUMAN-LIKE NOSE ===
        glColor3fv(furUnderside);  // Use tail underside color for nose
        glPushMatrix();
        glTranslatef(0.0f, 0.05f, 0.52f);

        // Nose bridge
        glPushMatrix();
        glTranslatef(0.0f, 0.1f, -0.02f);
        glScalef(0.06f, 0.15f, 0.08f);
        GLUquadric* noseBridge = gluNewQuadric();
        gluQuadricNormals(noseBridge, GLU_SMOOTH);
        gluSphere(noseBridge, 1.0f, 16, 16);
        gluDeleteQuadric(noseBridge);
        glPopMatrix();

        // Nose tip
        glPushMatrix();
        glScalef(0.08f, 0.06f, 0.1f);
        GLUquadric* noseTip = gluNewQuadric();
        gluQuadricNormals(noseTip, GLU_SMOOTH);
        gluSphere(noseTip, 1.0f, 16, 16);
        gluDeleteQuadric(noseTip);
        glPopMatrix();

        // Nostrils - human-like shape
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furDark);  // Use tail dark color for nostril holes
            glPushMatrix();
            glTranslatef(side * 0.025f, -0.015f, 0.04f);
            glScalef(0.02f, 0.015f, 0.03f);
            GLUquadric* nostril = gluNewQuadric();
            gluQuadricNormals(nostril, GLU_SMOOTH);
            gluSphere(nostril, 1.0f, 12, 10);
            gluDeleteQuadric(nostril);
            glPopMatrix();
        }
        glPopMatrix();

        // === ENHANCED VISIBLE MOUTH ===
        glPushMatrix();
        glTranslatef(0.0f, -0.15f, 0.48f);

        // MOUTH OPENING - VERY VISIBLE interior
        glColor3fv(mouthRed);  // Bright red interior for visibility
        glPushMatrix();
        glTranslatef(0.0f, -0.01f, 0.02f);
        glScalef(0.14f, 0.06f, 0.09f);  // Larger mouth opening for visibility
        GLUquadric* mouthInterior = gluNewQuadric();
        gluQuadricNormals(mouthInterior, GLU_SMOOTH);
        gluSphere(mouthInterior, 1.0f, 16, 12);
        gluDeleteQuadric(mouthInterior);
        glPopMatrix();

        // Upper lip - clearly defined
        glColor3fv(lipColor);
        glPushMatrix();
        glTranslatef(0.0f, 0.02f, 0.01f);
        glScalef(0.16f, 0.03f, 0.05f);  // Wider and more visible
        GLUquadric* upperLip = gluNewQuadric();
        gluQuadricNormals(upperLip, GLU_SMOOTH);
        gluSphere(upperLip, 1.0f, 16, 12);
        gluDeleteQuadric(upperLip);
        glPopMatrix();

        // Lower lip - fuller for human appearance
        glPushMatrix();
        glTranslatef(0.0f, -0.03f, 0.005f);
        glScalef(0.18f, 0.04f, 0.04f);  // Wider and more visible
        GLUquadric* lowerLip = gluNewQuadric();
        gluQuadricNormals(lowerLip, GLU_SMOOTH);
        gluSphere(lowerLip, 1.0f, 16, 12);
        gluDeleteQuadric(lowerLip);
        glPopMatrix();

        // VISIBLE TEETH for better mouth definition
        glColor3fv(teethWhite);
        for (int i = 0; i < 6; i++) {
            float x = (i - 2.5f) * 0.04f;
            glPushMatrix();
            glTranslatef(x, 0.01f, 0.04f);
            glScalef(0.02f, 0.03f, 0.025f);
            GLUquadric* tooth = gluNewQuadric();
            gluQuadricNormals(tooth, GLU_SMOOTH);
            gluSphere(tooth, 1.0f, 12, 10);
            gluDeleteQuadric(tooth);
            glPopMatrix();
        }

        // Lip line separation - more prominent
        glColor3fv(furDark);  // Use tail dark color
        glPushMatrix();
        glScalef(0.17f, 0.01f, 0.025f);  // Wider and more visible
        GLUquadric* lipLine = gluNewQuadric();
        gluQuadricNormals(lipLine, GLU_SMOOTH);
        gluSphere(lipLine, 1.0f, 16, 10);
        gluDeleteQuadric(lipLine);
        glPopMatrix();

        // Mouth corners - well defined
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furBase);  // Use tail base color
            glPushMatrix();
            glTranslatef(side * 0.15f, -0.005f, 0.01f);  // Wider positioning
            glScalef(0.03f, 0.025f, 0.03f);
            GLUquadric* mouthCorner = gluNewQuadric();
            gluQuadricNormals(mouthCorner, GLU_SMOOTH);
            gluSphere(mouthCorner, 1.0f, 12, 10);
            gluDeleteQuadric(mouthCorner);
            glPopMatrix();
        }
        glPopMatrix();

        // === HUMAN-LIKE EARS (ONLY ONE PAIR) ===
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furBase);  // Use tail base color
            glPushMatrix();
            glTranslatef(side * 0.52f, 0.0f, 0.15f);
            glRotatef(side * 25, 0, 0, 1);  // Human-like ear angle

            // Outer ear (helix) - human proportions
            glScalef(0.08f, 0.15f, 0.12f);  // Human-like ear size
            GLUquadric* outerEar = gluNewQuadric();
            gluQuadricNormals(outerEar, GLU_SMOOTH);
            gluSphere(outerEar, 1.0f, 16, 14);
            gluDeleteQuadric(outerEar);

            // Inner ear (concha) - human structure
            glColor3fv(furDark);  // Use tail dark color
            glScalef(0.6f, 0.7f, 0.4f);
            GLUquadric* innerEar = gluNewQuadric();
            gluQuadricNormals(innerEar, GLU_SMOOTH);
            gluSphere(innerEar, 1.0f, 12, 10);
            gluDeleteQuadric(innerEar);

            // Earlobe - human characteristic
            glColor3fv(furLight);  // Use tail light color
            glPushMatrix();
            glTranslatef(0.0f, -0.8f, 0.0f);
            glScalef(0.8f, 0.5f, 0.8f);
            GLUquadric* earlobe = gluNewQuadric();
            gluQuadricNormals(earlobe, GLU_SMOOTH);
            gluSphere(earlobe, 1.0f, 12, 10);
            gluDeleteQuadric(earlobe);
            glPopMatrix();
            glPopMatrix();
        }

        // === STRONG JAWLINE ===
        glColor3fv(furBase);  // Use tail base color
        glPushMatrix();
        glTranslatef(0.0f, -0.25f, 0.25f);
        glScalef(0.4f, 0.15f, 0.25f);
        GLUquadric* jawline = gluNewQuadric();
        gluQuadricNormals(jawline, GLU_SMOOTH);
        gluSphere(jawline, 1.0f, 20, 16);
        gluDeleteQuadric(jawline);
        glPopMatrix();

        // Jaw muscles
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furLight);  // Use tail light color
            glPushMatrix();
            glTranslatef(side * 0.28f, -0.2f, 0.28f);
            glScalef(0.08f, 0.12f, 0.1f);
            GLUquadric* jawMuscle = gluNewQuadric();
            gluQuadricNormals(jawMuscle, GLU_SMOOTH);
            gluSphere(jawMuscle, 1.0f, 16, 12);
            gluDeleteQuadric(jawMuscle);
            glPopMatrix();
        }

        // === HAIR AND FUR BLEND ===
        glColor3fv(furTip);  // Use tail tip color for hair
        glPushMatrix();
        glTranslatef(0.0f, 0.25f, -0.1f);
        glScalef(0.8f, 0.6f, 0.7f);
        GLUquadric* hair = gluNewQuadric();
        gluQuadricNormals(hair, GLU_SMOOTH);
        gluSphere(hair, 0.65f, 24, 20);
        gluDeleteQuadric(hair);
        glPopMatrix();

        // === SEAMLESS NECK CONNECTION ===
        glColor3fv(furBase);  // Use tail base color
        glPushMatrix();
        glTranslatef(0.0f, -0.5f, 0.0f);
        GLUquadric* neckConnector = gluNewQuadric();
        gluQuadricNormals(neckConnector, GLU_SMOOTH);
        gluCylinder(neckConnector, 0.25f, 0.18f, 0.4f, 24, 3);

        // Add neck caps for seamless connection
        GLUquadric* neckTop = gluNewQuadric();
        gluQuadricOrientation(neckTop, GLU_INSIDE);
        gluDisk(neckTop, 0.0f, 0.25f, 24, 1);
        gluDeleteQuadric(neckTop);

        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.4f);
        GLUquadric* neckBottom = gluNewQuadric();
        gluQuadricOrientation(neckBottom, GLU_OUTSIDE);
        gluDisk(neckBottom, 0.0f, 0.18f, 24, 1);
        gluDeleteQuadric(neckBottom);
        glPopMatrix();
        gluDeleteQuadric(neckConnector);
        glPopMatrix();

        // === FACIAL EXPRESSION LINES ===
        glColor3fv(furDark);  // Use tail dark color

        // Frown lines between eyebrows
        for (int i = 0; i < 3; i++) {
            glPushMatrix();
            glTranslatef((i - 1.0f) * 0.03f, 0.25f, 0.47f);
            glRotatef(15.0f * (i - 1), 0, 0, 1);
            glScalef(0.02f, 0.1f, 0.025f);
            GLUquadric* frownLine = gluNewQuadric();
            gluQuadricNormals(frownLine, GLU_SMOOTH);
            gluSphere(frownLine, 1.0f, 12, 10);
            gluDeleteQuadric(frownLine);
            glPopMatrix();
        }

        // Nasolabial folds for character depth
        for (int side = -1; side <= 1; side += 2) {
            glPushMatrix();
            glTranslatef(side * 0.15f, -0.05f, 0.45f);
            glRotatef(side * 25.0f, 0, 0, 1);
            glScalef(0.012f, 0.14f, 0.035f);
            GLUquadric* nasolabial = gluNewQuadric();
            gluQuadricNormals(nasolabial, GLU_SMOOTH);
            gluSphere(nasolabial, 1.0f, 12, 10);
            gluDeleteQuadric(nasolabial);
            glPopMatrix();
        }

        glPopMatrix();
    }



    void drawMonkeyTail() {
        // Authentic monkey fur colors - based on real macaque and baboon patterns
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights  
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows
        GLfloat furTip[] = { 0.25f, 0.15f, 0.08f, 1.0f };          // Very dark tip
        GLfloat furUnderside[] = { 0.75f, 0.55f, 0.35f, 1.0f };    // Lighter underside
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };        // Pink skin patches
        GLfloat muscleRidge[] = { 0.35f, 0.22f, 0.12f, 1.0f };     // Muscle definition
        GLfloat vertebraeColor[] = { 0.38f, 0.25f, 0.15f, 1.0f };  // Vertebrae bumps

        // Enhanced monkey tail parameters - uniform thickness with improved movement
        const int tailSegments = 60;  // More segments for ultra-smooth motion
        float tailLength = 7.5f;       // Longer for dramatic movement
        float segmentLength = tailLength / tailSegments;

        // UNIFORM THICKNESS - Same radius throughout the entire tail
        float uniformRadius = 0.15f;  // Consistent thickness from base to tip

        // Enhanced movement patterns with improved functionality
        animationTime += 0.015f;
        float primaryWave = sinf(animationTime * 0.4f) * 0.8f;        // Main movement wave
        float secondaryWave = sinf(animationTime * 0.6f) * 0.4f;      // Secondary wave for complexity
        float spiralMotion = sinf(animationTime * 0.25f) * 1.2f;      // Spiral movement
        float whipMotion = sinf(animationTime * 0.8f) * 0.6f;        // Quick whip-like motion
        float breathingMotion = sinf(animationTime * 0.3f) * 0.05f;   // Subtle breathing

        glPushMatrix();

        // Position at anatomically correct monkey tail base
        glTranslatef(0.0f, 1.1f, -0.8f);
        glRotatef(-12.0f, 1.0f, 0.0f, 0.0f); // Optimized angle for movement display

        // Draw uniform thickness monkey tail with enhanced movement
        for (int i = 0; i < tailSegments; i++) {
            float t = (float)i / (tailSegments - 1);

            // Enhanced biomechanical movement with multi-directional capability
            float gravity = t * t * 0.4f;  // Natural hanging effect
            float flexibility = sinf(t * PI) * 0.8f;  // Maximum flexibility in middle

            // Multi-directional movement calculations
            float verticalMotion = primaryWave * flexibility * sinf(t * PI * 1.5f);
            float horizontalMotion = secondaryWave * flexibility * cosf(t * PI * 1.2f);
            float spiralX = spiralMotion * flexibility * sinf(t * PI * 2.0f + animationTime * 0.5f);
            float spiralZ = spiralMotion * flexibility * cosf(t * PI * 2.0f + animationTime * 0.5f);
            float whipEffect = whipMotion * t * t * sinf(animationTime * 1.5f + t * PI * 3.0f);

            // Combined step calculations for enhanced movement
            float stepY = -gravity * 0.15f + verticalMotion * 0.12f + breathingMotion * (1.0f - t * 0.5f);
            float stepX = horizontalMotion * 0.1f + spiralX * 0.08f + whipEffect * 0.06f;
            float stepZ = -t * 0.08f + spiralZ * 0.08f + whipEffect * 0.04f;

            // Uniform thickness throughout
            float currentRadius = uniformRadius;
            float nextRadius = uniformRadius;  // Always the same for uniform appearance

            // Enhanced fur color patterns with position-based variation
            float dorsalVentral = stepY + 1.0f;
            float colorVariation = (sinf(t * PI * 8.0f + animationTime) + 1.0f) * 0.5f;
            float lightExposure = (dorsalVentral + stepX + 2.0f) / 4.0f;

            // Dynamic coloration based on movement and position
            if (t > 0.85f) {
                glColor3fv(furTip);  // Darker tip for visual distinction
            }
            else if (dorsalVentral < 0.3f) {
                glColor3fv(furUnderside);  // Lighter underside
            }
            else if (lightExposure > 0.7f && colorVariation > 0.6f) {
                glColor3fv(furLight);  // Dynamic light areas
            }
            else if (lightExposure < 0.3f || colorVariation < 0.25f) {
                glColor3fv(furDark);   // Shadow areas
            }
            else {
                glColor3fv(furBase);   // Base color
            }

            glPushMatrix();

            // Apply movement transformations
            glTranslatef(stepX, stepY, stepZ);

            // Enhanced rotational movement for natural tail flexibility
            float rotationZ = primaryWave * t * 15.0f + secondaryWave * t * 8.0f;
            float rotationX = spiralMotion * t * t * 12.0f;
            float rotationY = whipEffect * t * 10.0f;

            glRotatef(rotationZ, 0, 0, 1);
            glRotatef(rotationX, 1, 0, 0);
            glRotatef(rotationY, 0, 1, 0);

            // Calculate orientation for natural flow
            if (i < tailSegments - 1) {
                float nextT = (float)(i + 1) / (tailSegments - 1);
                float nextGravity = nextT * nextT * 0.4f;
                float nextFlexibility = sinf(nextT * PI) * 0.8f;

                float nextVertical = primaryWave * nextFlexibility * sinf(nextT * PI * 1.5f);
                float nextHorizontal = secondaryWave * nextFlexibility * cosf(nextT * PI * 1.2f);
                float nextSpiralX = spiralMotion * nextFlexibility * sinf(nextT * PI * 2.0f + animationTime * 0.5f);
                float nextSpiralZ = spiralMotion * nextFlexibility * cosf(nextT * PI * 2.0f + animationTime * 0.5f);
                float nextWhip = whipMotion * nextT * nextT * sinf(animationTime * 1.5f + nextT * PI * 3.0f);

                float nextStepY = -nextGravity * 0.15f + nextVertical * 0.12f + breathingMotion * (1.0f - nextT * 0.5f);
                float nextStepX = nextHorizontal * 0.1f + nextSpiralX * 0.08f + nextWhip * 0.06f;
                float nextStepZ = -nextT * 0.08f + nextSpiralZ * 0.08f + nextWhip * 0.04f;

                float dirX = nextStepX - stepX;
                float dirY = nextStepY - stepY;
                float dirZ = nextStepZ - stepZ;

                if (dirX != 0 || dirY != 0 || dirZ != 0) {
                    float angleY = atan2f(dirX, dirZ) * 180.0f / PI;
                    float angleX = -atan2f(dirY, sqrtf(dirX * dirX + dirZ * dirZ)) * 180.0f / PI;

                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);
                }
            }

            // Draw main tail segment with uniform thickness
            GLUquadric* segment = gluNewQuadric();
            gluQuadricOrientation(segment, GLU_OUTSIDE);
            gluQuadricNormals(segment, GLU_SMOOTH);
            gluQuadricTexture(segment, GL_TRUE);
            gluCylinder(segment, currentRadius, nextRadius, segmentLength, 28, 1);  // Higher resolution

            // Perfect end caps for seamless connection
            if (i == 0) {
                GLUquadric* baseCap = gluNewQuadric();
                gluQuadricOrientation(baseCap, GLU_INSIDE);
                gluDisk(baseCap, 0.0f, currentRadius, 28, 1);
                gluDeleteQuadric(baseCap);
            }

            if (i == tailSegments - 1) {
                glPushMatrix();
                glTranslatef(0.0f, 0.0f, segmentLength);
                GLUquadric* endCap = gluNewQuadric();
                gluQuadricOrientation(endCap, GLU_OUTSIDE);
                gluDisk(endCap, 0.0f, nextRadius, 28, 1);
                gluDeleteQuadric(endCap);
                glPopMatrix();
            }

            gluDeleteQuadric(segment);

            // Enhanced fur patterns with movement-responsive density
            if (i % 2 == 0) {
                int furCount = (int)(18 - t * 6);  // Slightly less fur toward tip
                for (int j = 0; j < furCount; j++) {
                    float angle = j * 2.0f * PI / furCount;
                    float furOffset = (sinf(animationTime * 3.0f + j + i) + 1.0f) * 0.02f;  // Dynamic fur movement
                    float furRadius = currentRadius * (1.03f + furOffset);
                    float furX = cosf(angle) * furRadius;
                    float furY = sinf(angle) * furRadius;
                    float furZ = segmentLength * ((j % 5) * 0.2f + 0.1f);

                    // Dynamic fur coloration
                    if (furY < 0) {
                        glColor3fv(furUnderside);
                    }
                    else if (j % 4 == 0) {
                        glColor3fv(furLight);
                    }
                    else if (j % 7 == 0) {
                        glColor3fv(furDark);
                    }

                    glPushMatrix();
                    glTranslatef(furX, furY, furZ);

                    GLUquadric* furTuft = gluNewQuadric();
                    gluQuadricNormals(furTuft, GLU_SMOOTH);
                    float furSize = currentRadius * (0.09f + (j % 4) * 0.02f);
                    gluSphere(furTuft, furSize, 10, 10);
                    gluDeleteQuadric(furTuft);
                    glPopMatrix();
                }
            }

            // Enhanced vertebrae definition
            if (t < 0.8f && i % 3 == 0) {
                glColor3fv(vertebraeColor);
                for (int v = 0; v < 8; v++) {
                    float vertAngle = v * PI / 4.0f;
                    float vertX = cosf(vertAngle) * currentRadius * 1.02f;
                    float vertY = sinf(vertAngle) * currentRadius * 1.02f;

                    glPushMatrix();
                    glTranslatef(vertX, vertY, segmentLength * 0.5f);
                    GLUquadric* vertebra = gluNewQuadric();
                    gluSphere(vertebra, currentRadius * 0.05f, 10, 10);
                    gluDeleteQuadric(vertebra);
                    glPopMatrix();
                }
            }

            // Enhanced muscle definition
            if (t < 0.6f && i % 4 == 0) {
                glColor3fv(muscleRidge);
                for (int m = 0; m < 10; m++) {
                    float muscleAngle = m * PI / 5.0f;
                    float muscleX = cosf(muscleAngle) * currentRadius * 0.99f;
                    float muscleY = sinf(muscleAngle) * currentRadius * 0.99f;

                    glPushMatrix();
                    glTranslatef(muscleX, muscleY, segmentLength * 0.35f);
                    GLUquadric* muscle = gluNewQuadric();
                    gluSphere(muscle, currentRadius * 0.05f, 10, 10);
                    gluDeleteQuadric(muscle);
                    glPopMatrix();
                }
            }

            // Skin patches near tip
            if (t > 0.75f && i % 8 == 0) {
                glColor3fv(skinPink);
                for (int s = 0; s < 4; s++) {
                    float skinAngle = s * PI / 2.0f;
                    float skinX = cosf(skinAngle) * currentRadius * 0.88f;
                    float skinY = sinf(skinAngle) * currentRadius * 0.88f;

                    glPushMatrix();
                    glTranslatef(skinX, skinY, segmentLength * 0.6f);
                    GLUquadric* skinPatch = gluNewQuadric();
                    gluSphere(skinPatch, currentRadius * 0.025f, 10, 10);
                    gluDeleteQuadric(skinPatch);
                    glPopMatrix();
                }
            }

            glPopMatrix();

            // Move to next position for perfect continuity
            glTranslatef(stepX, stepY, stepZ);
        }

        // Enhanced tail tip with uniform thickness
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, segmentLength);

        // Larger tip pad maintaining uniform thickness
        glColor3fv(skinPink);
        GLUquadric* tipCore = gluNewQuadric();
        gluSphere(tipCore, uniformRadius * 0.8f, 24, 24);  // Proportional to uniform thickness
        gluDeleteQuadric(tipCore);

        // Enhanced ridges for better grip
        for (int r = 0; r < 10; r++) {
            float ridgeAngle = r * PI / 5.0f;
            float ridgeX = cosf(ridgeAngle) * uniformRadius * 0.6f;
            float ridgeY = sinf(ridgeAngle) * uniformRadius * 0.6f;

            glColor3fv(furTip);
            glPushMatrix();
            glTranslatef(ridgeX, ridgeY, uniformRadius * 0.3f);
            GLUquadric* ridge = gluNewQuadric();
            gluSphere(ridge, uniformRadius * 0.04f, 10, 10);
            gluDeleteQuadric(ridge);
            glPopMatrix();
        }

        // Enhanced fur tuft with dynamic movement
        for (int i = 0; i < 20; i++) {
            float angle = i * 2.0f * PI / 20.0f;
            float tufRadius = uniformRadius * (0.9f + (i % 6) * 0.1f);
            float dynamicMotion = sinf(animationTime * 2.0f + i) * 0.4f;
            float tufX = cosf(angle) * tufRadius * (0.9f + dynamicMotion);
            float tufY = sinf(angle) * tufRadius * (0.9f + cosf(animationTime * 2.0f + i) * 0.4f);
            float tufZ = (i % 6) * uniformRadius * 0.15f - uniformRadius * 0.1f;

            // Enhanced color variation
            if (i % 6 == 0) {
                glColor3fv(furTip);
            }
            else if (i % 6 == 1) {
                glColor3fv(furDark);
            }
            else if (i % 6 == 2) {
                glColor3fv(furBase);
            }
            else if (i % 6 == 3) {
                glColor3fv(furLight);
            }
            else if (i % 6 == 4) {
                glColor3fv(furUnderside);
            }
            else {
                glColor3fv(muscleRidge);
            }

            glPushMatrix();
            glTranslatef(tufX, tufY, tufZ);
            glRotatef((i % 8) * 12.0f + animationTime * 10.0f, 1, 1, 0);  // Dynamic curl

            GLUquadric* hairStrand = gluNewQuadric();
            gluQuadricNormals(hairStrand, GLU_SMOOTH);
            float strandLength = uniformRadius * (0.25f + (i % 6) * 0.08f);
            gluCylinder(hairStrand, uniformRadius * 0.02f, uniformRadius * 0.005f, strandLength, 8, 1);
            gluDeleteQuadric(hairStrand);
            glPopMatrix();
        }

        glPopMatrix();
        glPopMatrix();
    }

    void drawFurStrand(float length, float thickness, float curvature) {
        const int strandSegments = 3;  // Reduced for simplicity

        for (int i = 0; i < strandSegments; i++) {
            float t = (float)i / strandSegments;

            // Apply slight curvature
            float bend = sinf(t * PI * curvature) * length * 0.1f;

            glPushMatrix();
            glTranslatef(bend, 0, t * length);

            float currentThickness = thickness * (1.0f - t * 0.3f);

            GLUquadric* strand = gluNewQuadric();
            gluQuadricNormals(strand, GLU_SMOOTH);
            gluCylinder(strand, currentThickness, currentThickness * 0.9f, length / strandSegments, 6, 1);
            gluDeleteQuadric(strand);

            glPopMatrix();
        }
    }

    void drawMuscleDefinition(float radius, float length, float t) {
        // Subtle muscle definition using same base color, just slightly darker
        glColor3f(0.55f, 0.40f, 0.25f);  // Slightly darker version of main color

        for (int i = 0; i < 4; i++) {
            float angle = i * PI / 2.0f;
            float muscleX = cosf(angle) * radius * 0.95f;
            float muscleY = sinf(angle) * radius * 0.95f;

            glPushMatrix();
            glTranslatef(muscleX, muscleY, 0);

            GLUquadric* muscle = gluNewQuadric();
            gluSphere(muscle, radius * 0.05f, 6, 6);
            gluDeleteQuadric(muscle);

            glPopMatrix();
        }

        // Restore main tail color
        glColor3f(0.65f, 0.50f, 0.35f);
    }
