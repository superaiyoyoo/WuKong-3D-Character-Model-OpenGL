    #include <Windows.h>
    #include <gl/GL.h>
    #include <gl/GLU.h>
    #include <math.h>
    #include <stdlib.h>
    #pragma comment (lib, "OpenGL32.lib")
    #pragma comment (lib, "GLU32.lib")
    #define _USE_MATH_DEFINES
    #include <math.h>
    #define PI 3.14159f
    BITMAP BMP;
    HBITMAP hBMP = NULL;

// Global variables for camera control
float rotationX = 10.0f;
float rotationY = 0.0f;
float zoom = -15.0f;// Animation variables for realistic tail movement
float animationTime = 0.0f;
bool usePerspective = true;
GLUquadric* quad = nullptr;

GLuint  g_lavaTexture = 0;
bool    g_weaponFireTexture = false; // toggle for fire texture on weapon
GLuint  g_fireTexture = 0; // fire texture ID

// Flower field background variables
float flowerSway = 0.0f;
float flowerSwaySpeed = 0.01f;
float colorCycleTime = 0.0f;
bool flowerFieldEnabled = true; // toggle for flower field background

// Sky texture variables
GLuint skyTexture = 0;              // Sky texture ID
bool skyTextureEnabled = false;     // Toggle for sky texture

// Dynamic flower count cycling variables - CONTROLLED PROGRESSION (30-80 flowers)
float flowerCountCycle = 0.0f;      // Controls the flower count cycle
float flowerCountSpeed = 0.01f;     // Moderate cycling speed for smooth transitions
float currentFlowerProgress = 0.0f; // Progress from 0.0 (30 flowers) to 1.0 (80 flowers)

// Enhanced color brightness variables - PROGRESSIVE VIBRANCY with DRAMATIC BLINKING
float baseColorBrightness = 1.5f;   // Higher base brightness for better visibility
float maxColorBrightness = 3.2f;    // Maximum brightness for peak flowers
float colorSaturation = 2.2f;       // Higher base saturation
float maxColorSaturation = 3.8f;    // Maximum saturation at peak
float colorVibrancy = 1.8f;         // Higher base vibrancy boost

// Rainbow color cycling variables
float rainbowColorCycle = 0.0f;     // Controls rainbow color transitions
float rainbowSpeed = 0.01f;         // Speed of rainbow color changes
bool rainbowMode = true;            // Enable beautiful rainbow colors

void createQuad() {
    quad = gluNewQuadric();
    // ... other init
}

void deleteQuad() {
    if (quad) {
        gluDeleteQuadric(quad);
        quad = nullptr;
    }
}

bool    g_light0On = true;   // white directional
bool    g_light1On = true;   // red positional
float   g_angle = 0.0f;      // simple rotation
bool    g_showWeapon = false; // toggle for Ruyi Jingu Bang visibility
float   g_weaponGripAnimation = 0.0f; // 0.0 = open hand, 1.0 = closed grip
bool    g_weaponAnimating = false; // true when grip animation is in progress
bool    g_smashAttacking = false; // true when overhead smash attack is in progress
float   g_smashAngle = 0.0f; // current angle of the smash attack animation
int     g_smashPhase = 0; // 0 = not active, 1 = raising arm, 2 = slamming down
bool    g_wearingShoes = true; // toggle for wearing shoes

// Forward declarations
void drawMonkeyTail();
void drawSimpleLegs();
void drawSimpleLeg(bool isLeft);
void drawSimpleFoot(bool isLeft);
void drawSimpleShoes(bool isLeft);
void drawSimpleToe(float length, float width);
void drawFurStrand(float length, float thickness, float curvature);
void renderStatusText();
void drawMuscleDefinition(float radius, float length, float t);
void drawUpperBody();
void drawMuscularUpperTorso();
void drawSimpleHead();
void DrawRuyiJinguBangWithCustomTextures(float length, float radius);

// --------------------------------------------------------------------
void ResizeGL(int w, int h)
{
    // Set up perspective projection
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (usePerspective) {

        gluPerspective(60.0, w / h, 0.1, 100.0);
    }
    else {
        double aspect = (double)w / (double)h;

        glOrtho(-5 * aspect, 5 * aspect, -5, 5, 0.1, 100.0);

    }

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

GLuint loadTexture(LPCSTR filename) {

    //Take from step 1
    GLuint texture = 0;

    // Step 3: Initialize texture info
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    HBITMAP hBMP = (HBITMAP)LoadImage(GetModuleHandle(NULL),
        filename, IMAGE_BITMAP, 0, 0,
        LR_CREATEDIBSECTION | LR_LOADFROMFILE);
    GetObject(hBMP, sizeof(BMP), &BMP);

    //Step 4: Assign texture to polygon.
    glEnable(GL_TEXTURE_2D);
    glGenTextures(1, &texture);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, BMP.bmWidth, BMP.bmHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, BMP.bmBits);

    //Take from step 5
    DeleteObject(hBMP);
    return texture;
}

void DrawRuyiJinguBang(float length = 8.0f, float radius = 0.2f)
{
    createQuad();

    // 1. Gradient gold effect - shaft with gradient from base to tip
    float segments = 10;
    float segmentLength = length / segments;
    
    for (int i = 0; i < segments; i++) {
        // Gradient gold color from base to tip
        float t = (float)i / segments;
        glColor3f(1.0f, 0.84f + t * 0.16f, 0.0f + t * 0.5f); // Golden to brighter gold-white
        
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, i * segmentLength);
        gluCylinder(quad, radius, radius, segmentLength, 32, 1);
        glPopMatrix();
    }

    // 2. Decorative golden rings along the staff
    float rotationEffect = animationTime * 20.0f;
    int numRings = 5;
    
    for (int i = 1; i < numRings; i++) {
        float ringPos = length * i / numRings;
        
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, ringPos);
        
        // Ring with slightly brighter gold
        glColor3f(1.0f, 0.9f, 0.3f);
        
        // Draw the ring as a thin cylinder
        float ringThickness = radius * 0.15f;
        float ringRadius = radius * 1.3f;
        
        // Draw ring
        glPushMatrix();
        glRotatef(90.0f, 1.0f, 0.0f, 0.0f);
        gluCylinder(quad, ringRadius, ringRadius, ringThickness, 24, 1);
        
        // Cap the ring
        glColor3f(1.0f, 0.95f, 0.4f);
        gluDisk(quad, ringRadius - ringThickness, ringRadius, 24, 1);
        glTranslatef(0.0f, 0.0f, ringThickness);
        gluDisk(quad, ringRadius - ringThickness, ringRadius, 24, 1);
        glPopMatrix();
        
        // Add decorative elements around the ring
        glRotatef(rotationEffect + i * 30.0f, 0.0f, 0.0f, 1.0f);
        glColor3f(1.0f, 0.7f, 0.0f);
        for (int j = 0; j < 8; j++) {
            glPushMatrix();
            glRotatef(j * 45.0f, 0.0f, 0.0f, 1.0f);
            glTranslatef(ringRadius, 0.0f, 0.0f);
            gluSphere(quad, radius * 0.15f, 8, 8);
            glPopMatrix();
        }
        
        glPopMatrix();
    }

    // Cap at bottom
    glPushMatrix();
    glColor3f(0.8f, 0.0f, 0.0f); // red decorative ring
    gluDisk(quad, 0.0, radius * 1.2, 32, 1);
    glPopMatrix();

    // Cap at top
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, length);
    glColor3f(0.8f, 0.0f, 0.0f); // red decorative ring
    gluDisk(quad, 0.0, radius * 1.2, 32, 1);
    glPopMatrix();

    // Decorative red spheres at both ends
    glPushMatrix();
    glColor3f(0.8f, 0.0f, 0.0f);
    gluSphere(quad, radius * 1.2, 32, 16);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.0f, 0.0f, length);
    glColor3f(0.8f, 0.0f, 0.0f);
    gluSphere(quad, radius * 1.2, 32, 16);
    glPopMatrix();

    deleteQuad();
}

// --- CHANGED --- Renamed function for clarity
void DrawRuyiJinguBangWithCustomTextures(float length = 8.0f, float radius = 0.2f)
{
    createQuad();

    // Enable texturing
    glEnable(GL_TEXTURE_2D);

    // Set texture color to white to show textures properly
    glColor3f(1.0f, 1.0f, 1.0f);

    // ==========================================================
    // 1. Draw Main Shaft with Fire Texture
    // ==========================================================

    // --- BIND FIRE TEXTURE ---
    glBindTexture(GL_TEXTURE_2D, g_fireTexture);

    float segments = 10;
    float segmentLength = length / segments;

    for (int i = 0; i < segments; i++) {
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, i * segmentLength);
        gluQuadricTexture(quad, GL_TRUE);
        gluQuadricNormals(quad, GLU_SMOOTH);
        gluCylinder(quad, radius, radius, segmentLength, 32, 1);
        glPopMatrix();
    }

    // ==========================================================
    // 2. Draw Decorative Parts with Lava Texture
    // ==========================================================

    // --- CHANGED --- Switch to the lava texture for the gold parts
    glBindTexture(GL_TEXTURE_2D, g_lavaTexture);

    // Decorative rings along the staff
    float rotationEffect = animationTime * 20.0f;
    int numRings = 5;

    for (int i = 1; i < numRings; i++) {
        float ringPos = length * i / numRings;
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, ringPos);

        float ringThickness = radius * 0.15f;
        float ringRadius = radius * 1.3f;

        glPushMatrix();
        glRotatef(90.0f, 1.0f, 0.0f, 0.0f);
        gluQuadricTexture(quad, GL_TRUE);
        gluCylinder(quad, ringRadius, ringRadius, ringThickness, 24, 1);
        gluDisk(quad, ringRadius - ringThickness, ringRadius, 24, 1);
        glTranslatef(0.0f, 0.0f, ringThickness);
        gluDisk(quad, ringRadius - ringThickness, ringRadius, 24, 1);
        glPopMatrix();

        glRotatef(rotationEffect + i * 30.0f, 0.0f, 0.0f, 1.0f);
        for (int j = 0; j < 8; j++) {
            glPushMatrix();
            glRotatef(j * 45.0f, 0.0f, 0.0f, 1.0f);
            glTranslatef(ringRadius, 0.0f, 0.0f);
            gluQuadricTexture(quad, GL_TRUE);
            gluSphere(quad, radius * 0.15f, 8, 8);
            glPopMatrix();
        }
        glPopMatrix();
    }

    // Caps and spheres at both ends (still using lava texture)
    glPushMatrix();
    gluQuadricTexture(quad, GL_TRUE);
    gluDisk(quad, 0.0, radius * 1.2, 32, 1);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.0f, 0.0f, length);
    gluQuadricTexture(quad, GL_TRUE);
    gluDisk(quad, 0.0, radius * 1.2, 32, 1);
    glPopMatrix();

    glPushMatrix();
    gluQuadricTexture(quad, GL_TRUE);
    gluSphere(quad, radius * 1.2, 32, 16);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.0f, 0.0f, length);
    gluQuadricTexture(quad, GL_TRUE);
    gluSphere(quad, radius * 1.2, 32, 16);
    glPopMatrix();

    // Disable texturing
    glDisable(GL_TEXTURE_2D);
    deleteQuad();
}

// LIGHTING

    // set up light parameters (but note: position is set each frame in DisplayScene)
void InitLighting()
{
    glEnable(GL_LIGHTING);

    // Light 0 - white directional
    GLfloat amb0[] = { 0.15f, 0.15f, 0.15f, 1.0f };
    GLfloat diff0[] = { 0.9f, 0.9f, 0.9f, 1.0f };
    GLfloat spec0[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    glLightfv(GL_LIGHT0, GL_AMBIENT, amb0);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diff0);
    glLightfv(GL_LIGHT0, GL_SPECULAR, spec0);

    // Light 1 - warm red positional
    GLfloat amb1[] = { 0.05f, 0.01f, 0.01f, 1.0f };
    GLfloat diff1[] = { 1.0f, 0.25f, 0.25f, 1.0f };
    GLfloat spec1[] = { 1.0f, 0.5f, 0.5f, 1.0f };
    glLightfv(GL_LIGHT1, GL_AMBIENT, amb1);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, diff1);
    glLightfv(GL_LIGHT1, GL_SPECULAR, spec1);

    // initial enable/disable based on flags:
    if (g_light0On) glEnable(GL_LIGHT0);
    else            glDisable(GL_LIGHT0);

    if (g_light1On) glEnable(GL_LIGHT1);
    else            glDisable(GL_LIGHT1);

    // material shininess (optional)
    GLfloat matSpec[] = { 0.9f, 0.9f, 0.9f, 1.0f };
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, matSpec);
    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 32.0f);
}

void InitGL()
{
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_NORMALIZE);
    glShadeModel(GL_SMOOTH);
    glEnable(GL_COLOR_MATERIAL);
    glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
    InitLighting();
}

// Function to draw 2D flowers for background
void drawFlower(float x, float y, float size, float r, float g, float b, float angle)
{
    glPushMatrix();
    glTranslatef(x, y, 0.0f);
    glRotatef(angle, 0.0f, 0.0f, 1.0f);
    glScalef(size, size, 1.0f);

    // Enhanced stem with thickness and leaves
    glColor3f(0.1f, 0.6f, 0.1f);
    glBegin(GL_QUADS);
    glVertex2f(-0.02f, 0.0f);
    glVertex2f(0.02f, 0.0f);
    glVertex2f(0.015f, -0.6f);
    glVertex2f(-0.015f, -0.6f);
    glEnd();

    // Add small leaves on stem
    glColor3f(0.2f, 0.7f, 0.2f);
    // Left leaf
    glBegin(GL_TRIANGLES);
    glVertex2f(-0.02f, -0.2f);
    glVertex2f(-0.08f, -0.15f);
    glVertex2f(-0.04f, -0.3f);
    glEnd();
    // Right leaf
    glBegin(GL_TRIANGLES);
    glVertex2f(0.02f, -0.35f);
    glVertex2f(0.08f, -0.3f);
    glVertex2f(0.04f, -0.45f);
    glEnd();

    // Enhanced petals - using 6 overlapping petals for fuller look
    for (int i = 0; i < 6; i++) {
        glColor3f(r, g, b);
        glPushMatrix();
        glRotatef(60.0f * i, 0.0f, 0.0f, 1.0f);

        // Main petal
        glBegin(GL_POLYGON);
        for (int j = 0; j < 20; j++) {
            float petAngle = 2.0f * 3.14159f * j / 20;
            float radius = 0.18f;  // Larger petals
            float petalX = 0.15f + radius * 0.6f * cos(petAngle);
            float petalY = radius * 0.6f * sin(petAngle);
            glVertex2f(petalX, petalY);
        }
        glEnd();

        // Add petal highlights for more realistic look
        glColor3f(min(r + 0.3f, 1.0f), min(g + 0.3f, 1.0f), min(b + 0.3f, 1.0f));
        glBegin(GL_POLYGON);
        for (int j = 0; j < 16; j++) {
            float petAngle = 2.0f * 3.14159f * j / 16;
            float radius = 0.12f;
            float petalX = 0.18f + radius * 0.4f * cos(petAngle);
            float petalY = radius * 0.4f * sin(petAngle);
            glVertex2f(petalX, petalY);
        }
        glEnd();

        glPopMatrix();
    }

    // Enhanced center of flower with multiple layers
    // Outer center ring
    glColor3f(1.0f, 0.8f, 0.0f);  // Golden outer ring
    glBegin(GL_POLYGON);
    for (int j = 0; j < 20; j++) {
        float centerAngle = 2.0f * 3.14159f * j / 20;
        float centerRadius = 0.12f;  // Larger center
        glVertex2f(centerRadius * cos(centerAngle), centerRadius * sin(centerAngle));
    }
    glEnd();

    // Inner center
    glColor3f(1.0f, 1.0f, 0.0f);  // Bright yellow inner center
    glBegin(GL_POLYGON);
    for (int j = 0; j < 16; j++) {
        float centerAngle = 2.0f * 3.14159f * j / 16;
        float centerRadius = 0.08f;
        glVertex2f(centerRadius * cos(centerAngle), centerRadius * sin(centerAngle));
    }
    glEnd();

    // Add small dots in center for detail
    glColor3f(0.8f, 0.6f, 0.0f);  // Darker yellow for dots
    for (int i = 0; i < 8; i++) {
        float dotAngle = 2.0f * 3.14159f * i / 8;
        float dotRadius = 0.05f;
        glPointSize(2.0f);
        glBegin(GL_POINTS);
        glVertex2f(dotRadius * cos(dotAngle), dotRadius * sin(dotAngle));
        glEnd();
    }

    glPopMatrix();
}

// Function to render 2D flower field background
void renderFlowerFieldBackground()
{
    if (!flowerFieldEnabled) return;

    // Save current 3D state
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();

    // Set 2D orthographic projection
    glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();

    // Disable depth testing for 2D background
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_LIGHTING);

    // Enhanced sky background - with texture support or gradient
    if (skyTextureEnabled && skyTexture != 0) {
        // Enable texture mapping for sky
        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, skyTexture);
        glColor3f(1.0f, 1.0f, 1.0f);  // White to show true texture colors

        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f); glVertex2f(-1.0f, -1.0f);
        glTexCoord2f(1.0f, 0.0f); glVertex2f(1.0f, -1.0f);
        glTexCoord2f(1.0f, 1.0f); glVertex2f(1.0f, 1.0f);
        glTexCoord2f(0.0f, 1.0f); glVertex2f(-1.0f, 1.0f);
        glEnd();

        glDisable(GL_TEXTURE_2D);
    }
    else {
        // Default gradient sky background
        glBegin(GL_QUADS);
        glColor3f(0.6f, 0.8f, 1.0f);  // Lighter sky blue at bottom (sun influence)
        glVertex2f(-1.0f, -1.0f);
        glVertex2f(1.0f, -1.0f);
        glColor3f(0.2f, 0.5f, 0.9f);  // Deeper blue at top
        glVertex2f(1.0f, 1.0f);
        glVertex2f(-1.0f, 1.0f);
        glEnd();
    }

    // Update flower sway animation
    flowerSway += flowerSwaySpeed;
    if (flowerSway > 6.28f) flowerSway = 0.0f;

    // Ground with texture suggestion and distant hills - brighter green (sun-lit)
    glBegin(GL_QUADS);
    glColor3f(0.3f, 0.8f, 0.3f);  // Brighter green grass (sunlit)
    glVertex2f(-1.0f, -1.0f);
    glVertex2f(1.0f, -1.0f);
    glColor3f(0.5f, 0.9f, 0.5f);  // Very bright green at horizon (sun effect)
    glVertex2f(1.0f, -0.3f);
    glVertex2f(-1.0f, -0.3f);
    glEnd();

    // Distant hills with better gradient - enhanced by sunlight
    glBegin(GL_POLYGON);
    glColor3f(0.4f, 0.7f, 0.4f);  // Bright mid green (sunlit)
    glVertex2f(-1.0f, -0.3f);
    glVertex2f(-0.8f, -0.25f);
    glVertex2f(-0.6f, -0.28f);
    glVertex2f(-0.4f, -0.22f);
    glVertex2f(-0.2f, -0.27f);
    glVertex2f(0.0f, -0.23f);
    glVertex2f(0.2f, -0.28f);
    glVertex2f(0.4f, -0.24f);
    glVertex2f(0.6f, -0.29f);
    glVertex2f(0.8f, -0.26f);
    glVertex2f(1.0f, -0.3f);
    glEnd();

    // Add a second row of more distant hills
    glBegin(GL_POLYGON);
    glColor3f(0.3f, 0.6f, 0.35f);  // Brighter green for distance (sunlit)
    glVertex2f(-1.0f, -0.3f);
    glVertex2f(-0.9f, -0.27f);
    glVertex2f(-0.7f, -0.25f);
    glVertex2f(-0.5f, -0.28f);
    glVertex2f(-0.3f, -0.24f);
    glVertex2f(-0.1f, -0.26f);
    glVertex2f(0.1f, -0.23f);
    glVertex2f(0.3f, -0.25f);
    glVertex2f(0.5f, -0.22f);
    glVertex2f(0.7f, -0.26f);
    glVertex2f(0.9f, -0.24f);
    glVertex2f(1.0f, -0.3f);
    glEnd();

    // Draw colorful flowers across the entire field - EXACT FLOWER COLORS FROM USER CODE
    // Define flower colors with different hues - EXACTLY AS USER REQUESTED
    struct FlowerColor {
        float r, g, b;
    } flowerColors[] = {
        {1.0f, 0.2f, 0.2f},  // Red
        {1.0f, 0.5f, 0.0f},  // Orange
        {1.0f, 1.0f, 0.0f},  // Yellow
        {0.5f, 1.0f, 0.0f},  // Lime
        {0.0f, 0.8f, 0.2f},  // Green
        {0.0f, 0.6f, 1.0f},  // Blue
        {0.5f, 0.2f, 1.0f},  // Purple
        {1.0f, 0.4f, 0.8f},  // Pink
        {1.0f, 0.8f, 0.0f},  // Golden Yellow
        {0.8f, 0.0f, 0.8f},  // Magenta
        {0.0f, 1.0f, 1.0f},  // Cyan
        {1.0f, 0.6f, 0.4f},  // Peach
        {0.6f, 0.4f, 1.0f},  // Lavender
        {1.0f, 0.0f, 0.5f},  // Rose
        {0.4f, 1.0f, 0.6f},  // Spring Green
        {1.0f, 0.3f, 0.0f}   // Red-Orange
    };

    // Create a flower garden filling the entire grass area
    // Grid-based flower placement for even distribution
    // (Variable declarations moved to controlled flower cycling section)

    // Define accent flower structure
    struct AccentFlower {
        float x, y, size;
        int colorIndex;
    } accentFlowers[] = {
        {-0.8f, -0.8f, 0.15f, 0},   // Large red flower
        {0.7f, -0.7f, 0.14f, 1},    // Large orange flower
        {-0.6f, -0.5f, 0.16f, 2},   // Large yellow flower
        {0.8f, -0.9f, 0.13f, 6},    // Large purple flower
        {-0.9f, -0.6f, 0.15f, 7},   // Large pink flower
        {0.6f, -0.4f, 0.14f, 4},    // Large green flower
        {-0.4f, -0.9f, 0.15f, 5},   // Large blue flower
        {0.9f, -0.5f, 0.16f, 8},    // Large golden flower
        {-0.7f, -0.3f, 0.14f, 9},   // Large magenta flower
        {0.5f, -0.8f, 0.15f, 10}    // Large cyan flower
    };

    // Update flower sway animation
    flowerSway += flowerSwaySpeed;
    if (flowerSway > 6.28f) flowerSway = 0.0f;

    // CONTROLLED FLOWER CYCLING: 30 to 96 flowers with progressive color enhancement
    // Update flower count cycle
    flowerCountCycle += flowerCountSpeed;
    if (flowerCountCycle > 6.28f) flowerCountCycle = 0.0f;  // Reset cycle

    // Update rainbow mode colors if active
    if (rainbowMode) {
        rainbowColorCycle += 0.01f;
        if (rainbowColorCycle > 6.28f) rainbowColorCycle = 0.0f;
    }

    // Calculate flower progression from 30 to 96 flowers and back (controlled cycle)
    // Creates smooth transition: 30 flowers -> 96 flowers -> 30 flowers
    currentFlowerProgress = 0.5f + 0.5f * sin(flowerCountCycle);

    // Calculate progressive color enhancement based on flower count
    float progressiveColorBrightness = baseColorBrightness + (maxColorBrightness - baseColorBrightness) * currentFlowerProgress;
    float progressiveColorSaturation = colorSaturation + (maxColorSaturation - colorSaturation) * currentFlowerProgress;
    float progressiveVibrancy = colorVibrancy + (1.0f * currentFlowerProgress); // Extra vibrancy at peak

    // CONTROLLED FLOWER COUNT CYCLING: 30 to 96 flowers total
    // Calculate total flowers (30 at minimum, 96 at maximum - current 12x8 grid)
    int totalFlowers = 30 + (int)(66 * currentFlowerProgress);  // 30 to 96 flowers

    // Distribute flowers across grid (approximately square distribution)
    int flowersPerRow = (int)sqrt(totalFlowers * 0.75f);  // Slightly wider than tall
    int numRows = (int)(totalFlowers / flowersPerRow);

    // Ensure reasonable distribution
    if (flowersPerRow < 6) flowersPerRow = 6;
    if (numRows < 5) numRows = 5;
    if (flowersPerRow * numRows < totalFlowers) {
        if (flowersPerRow <= numRows) flowersPerRow++;
        else numRows++;
    }

    for (int row = 0; row < numRows; row++) {
        for (int col = 0; col < flowersPerRow; col++) {
            // Only draw flowers up to totalFlowers count
            int currentFlowerIndex = row * flowersPerRow + col;
            if (currentFlowerIndex >= totalFlowers) break;

            // Calculate position with some randomness
            float baseX = -1.0f + (col * 2.0f / (flowersPerRow - 1));
            float baseY = -1.0f + (row * 0.7f / (numRows - 1));  // Cover from bottom to ground level

            // Add some randomness to avoid grid-like appearance
            float randomOffsetX = 0.1f * sin(col * 2.5f + row * 1.8f);
            float randomOffsetY = 0.05f * cos(col * 1.7f + row * 2.3f);

            float x = baseX + randomOffsetX;
            float y = baseY + randomOffsetY;

            // Vary flower sizes - make them bigger overall with progressive scaling
            float sizeVariation = 0.08f + 0.04f * sin(col * 3.1f + row * 2.7f);
            float progressiveSizeMultiplier = 0.8f + 0.4f * currentFlowerProgress;  // Size grows with count
            float size = (0.1f + sizeVariation) * progressiveSizeMultiplier;

            // Choose color with some variety - USE 16 COLORS
            int colorIndex = (row * flowersPerRow + col) % 16;
            FlowerColor& fc = flowerColors[colorIndex];

            // PROGRESSIVE COLOR ENHANCEMENT - More vibrant as flower count increases
            float brightR = min(fc.r * progressiveColorBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);
            float brightG = min(fc.g * progressiveColorBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);
            float brightB = min(fc.b * progressiveColorBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);

            // ENHANCED DRAMATIC BLINKING - MAXIMUM VISIBILITY and OBVIOUS EFFECTS
            float blinkPhase = flowerSway * 6.0f + row * 1.2f + col * 1.0f;  // Faster blinking
            float baseBlinkIntensity = 0.05f + 0.8f * currentFlowerProgress;  // More dramatic range at peak
            float blinkFactor = baseBlinkIntensity + (1.0f - baseBlinkIntensity) * (1.0f + sin(blinkPhase)) * 0.5f;

            // Add multiple synchronized pulsing effects for more obvious blinking
            float pulsePhase1 = flowerCountCycle * 3.0f + (row + col) * 0.7f;
            float pulsePhase2 = flowerSway * 8.0f + (row * col) * 0.3f;  // Secondary pulse
            float pulseFactor1 = 0.5f + 0.5f * (1.0f + currentFlowerProgress * sin(pulsePhase1));
            float pulseFactor2 = 0.7f + 0.3f * sin(pulsePhase2);  // Additional pulsing layer

            // Strobe effect for extra drama
            float strobePhase = flowerSway * 12.0f + (row + col) * 1.5f;
            float strobeFactor = 0.6f + 0.4f * (1.0f + sin(strobePhase)) * 0.5f;

            // Enhanced color variations - more dramatic at higher counts
            float colorVar = 0.3f * (1.0f + currentFlowerProgress) * sin(flowerSway * 1.5f + col * 1.0f + row * 0.8f);
            float sunlightBoost = 0.4f + 0.4f * currentFlowerProgress;  // More sunlight effect at peak

            // Add swaying motion with position-based variation
            float swayAngle = 8.0f * sin(flowerSway * 0.9f + col * 1.2f + row * 0.9f);

            drawFlower(x, y, size,
                min((brightR + colorVar + sunlightBoost) * blinkFactor * pulseFactor1 * pulseFactor2 * strobeFactor, 1.0f),
                min((brightG + colorVar + sunlightBoost) * blinkFactor * pulseFactor1 * pulseFactor2 * strobeFactor, 1.0f),
                min((brightB + colorVar + sunlightBoost) * blinkFactor * pulseFactor1 * pulseFactor2 * strobeFactor, 1.0f),
                swayAngle);
        }
    }

    // ENHANCED ACCENT FLOWERS - SCALED WITH FLOWER COUNT
    // CONTROLLED ACCENT FLOWERS - Scale with main flower count (proportional to total flowers)
    int accentFlowerCount = 3 + (int)(7 * currentFlowerProgress);  // 3 to 10 accent flowers

    for (int i = 0; i < accentFlowerCount && i < 10; i++) {
        AccentFlower& af = accentFlowers[i];
        FlowerColor& fc = flowerColors[af.colorIndex];

        // PROGRESSIVE ACCENT COLORS - Maximum attraction at peak flower count
        float accentBrightness = progressiveColorBrightness * (1.2f + 0.3f * currentFlowerProgress);
        float brightR = min(fc.r * accentBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);
        float brightG = min(fc.g * accentBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);
        float brightB = min(fc.b * accentBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);

        // EXTREME BLINKING for accent flowers - MAXIMUM DRAMA and OBVIOUS EFFECTS
        float blinkPhase = flowerSway * 8.0f + i * 1.5f;  // Much faster blinking
        float baseBlinkIntensity = 0.02f + 0.85f * currentFlowerProgress;  // Extreme range
        float blinkFactor = baseBlinkIntensity + (1.0f - baseBlinkIntensity) * (1.0f + sin(blinkPhase)) * 0.5f;

        // Multiple strobe effects synchronized with cycle - ULTRA DRAMATIC
        float strobePhase1 = flowerCountCycle * 5.0f + i * 0.8f;
        float strobePhase2 = flowerSway * 10.0f + i * 1.2f;
        float strobeFactor1 = 0.4f + 0.6f * (1.0f + currentFlowerProgress * sin(strobePhase1));
        float strobeFactor2 = 0.6f + 0.4f * sin(strobePhase2);

        // Enhanced color variations and size scaling
        float colorVar = 0.3f * (1.0f + currentFlowerProgress) * sin(flowerSway * 2.0f + i * 1.3f);
        float swayAngle = 6.0f * sin(flowerSway * 0.7f + i * 1.5f);
        float sunlightBoost = 0.5f + 0.3f * currentFlowerProgress;
        float progressiveSize = af.size * (0.8f + 0.4f * currentFlowerProgress);

        drawFlower(af.x, af.y, progressiveSize,
            min((brightR + colorVar + sunlightBoost) * blinkFactor * strobeFactor1 * strobeFactor2, 1.0f),
            min((brightG + colorVar + sunlightBoost) * blinkFactor * strobeFactor1 * strobeFactor2, 1.0f),
            min((brightB + colorVar + sunlightBoost) * blinkFactor * strobeFactor1 * strobeFactor2, 1.0f),
            swayAngle);
    }

    // ENHANCED SCATTERED FLOWERS - SCALED WITH FLOWER COUNT
    // CONTROLLED SCATTERED FLOWERS - Enhanced scaling with main count
    int scatteredFlowerCount = 8 + (int)(17 * currentFlowerProgress);  // 8 to 25 scattered flowers

    for (int i = 0; i < scatteredFlowerCount; i++) {
        float x = -0.9f + (i * 0.07f) + 0.3f * sin(i * 2.1f);
        float y = -0.95f + 0.4f * cos(i * 1.8f);

        float progressiveSize = (0.06f + 0.02f * sin(i * 2.5f)) * (0.7f + 0.5f * currentFlowerProgress);
        int colorIndex = i % 16;
        FlowerColor& fc = flowerColors[colorIndex];

        // PROGRESSIVE SCATTERED COLORS - Enhanced at peak
        float scatteredBrightness = progressiveColorBrightness * (1.2f + 0.3f * currentFlowerProgress);
        float brightR = min(fc.r * scatteredBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);
        float brightG = min(fc.g * scatteredBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);
        float brightB = min(fc.b * scatteredBrightness * progressiveColorSaturation * progressiveVibrancy, 1.0f);

        // ULTRA RAPID BLINKING - EXTREMELY OBVIOUS EFFECTS
        float blinkPhase = flowerSway * 9.0f + i * 2.0f;  // Super fast blinking
        float baseBlinkIntensity = 0.01f + 0.9f * currentFlowerProgress;  // Extreme dramatic range
        float blinkFactor = baseBlinkIntensity + (1.0f - baseBlinkIntensity) * (1.0f + sin(blinkPhase)) * 0.5f;

        // Multiple sparkle effects with cycle synchronization - MAXIMUM DRAMA
        float sparklePhase1 = flowerCountCycle * 6.0f + i * 0.4f;
        float sparklePhase2 = flowerSway * 15.0f + i * 0.7f;
        float sparkleFactor1 = 0.3f + 0.7f * (1.0f + currentFlowerProgress * sin(sparklePhase1));
        float sparkleFactor2 = 0.5f + 0.5f * sin(sparklePhase2);

        // Enhanced color variations
        float colorVar = 0.2f * (1.0f + currentFlowerProgress) * sin(flowerSway * 1.8f + i * 1.5f);
        float swayAngle = 10.0f * sin(flowerSway * 1.2f + i * 0.8f);
        float sunlightBoost = 0.3f + 0.3f * currentFlowerProgress;

        drawFlower(x, y, progressiveSize,
            min((brightR + colorVar + sunlightBoost) * blinkFactor * sparkleFactor1 * sparkleFactor2, 1.0f),
            min((brightG + colorVar + sunlightBoost) * blinkFactor * sparkleFactor1 * sparkleFactor2, 1.0f),
            min((brightB + colorVar + sunlightBoost) * blinkFactor * sparkleFactor1 * sparkleFactor2, 1.0f),
            swayAngle);
    }

    // Restore 3D state
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);

    glPopMatrix();
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
}

// Function to draw Wukong-style muscular leg anatomy with enhanced color variations
void drawWukongMuscularLeg(bool isLeft) {
    glPushMatrix();

    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }

    // Enhanced skin tones for Wukong with depth variations
    GLfloat wukongSkinBase[] = { 0.85f, 0.7f, 0.45f, 1.0f };           // Base golden-brown
    GLfloat wukongSkinLight[] = { 0.92f, 0.78f, 0.52f, 1.0f };         // Lighter highlights
    GLfloat wukongSkinMid[] = { 0.78f, 0.63f, 0.38f, 1.0f };           // Mid-tone areas
    GLfloat wukongSkinDeep[] = { 0.68f, 0.53f, 0.28f, 1.0f };          // Deeper shadows
    GLfloat muscleDefinition[] = { 0.58f, 0.43f, 0.23f, 1.0f };        // Deep muscle definition
    GLfloat muscleHighlight[] = { 0.88f, 0.73f, 0.48f, 1.0f };         // Muscle highlights

    // --- ENHANCED UPPER THIGH (Much Larger and More Muscular) ---
    glColor3fv(wukongSkinBase);

    // Main upper thigh muscle mass
    glPushMatrix();
    glTranslatef(0.0f, 6.2f, 0.0f);
    glScalef(0.85f, 1.4f, 0.85f);
    createQuad();
    gluSphere(quad, 0.5, 20, 20);
    deleteQuad();
    glPopMatrix();

    // Quadriceps muscle definition with varying depths
    for (int i = 0; i < 3; i++) {
        float angle = (i - 1) * 0.3f;
        // Vary colors based on position for depth
        if (i == 0) glColor3fv(muscleDefinition);      // Deepest
        else if (i == 1) glColor3fv(wukongSkinMid);    // Mid-tone
        else glColor3fv(muscleHighlight);              // Highlighted

        glPushMatrix();
        glTranslatef(sinf(angle) * 0.25f, 6.1f, cosf(angle) * 0.15f + 0.2f);
        glScalef(0.15f, 0.6f, 0.2f);
        createQuad();
        gluSphere(quad, 0.5, 16, 16);
        deleteQuad();
        glPopMatrix();
    }

    // --- ENHANCED MID THIGH (Larger and More Defined) ---
    glColor3fv(wukongSkinLight);  // Lighter tone for prominence
    glPushMatrix();
    glTranslatef(0.0f, 5.2f, 0.0f);
    glScalef(0.8f, 1.2f, 0.8f);
    createQuad();
    gluSphere(quad, 0.5, 20, 20);
    deleteQuad();
    glPopMatrix();

    // Hamstring muscle definition
    glColor3fv(wukongSkinDeep);  // Deeper shadow tone
    glPushMatrix();
    glTranslatef(0.0f, 5.1f, -0.3f);
    glScalef(0.6f, 0.8f, 0.25f);
    createQuad();
    gluSphere(quad, 0.5, 16, 16);
    deleteQuad();
    glPopMatrix();

    // --- ENHANCED KNEE AREA ---
    glColor3fv(wukongSkinMid);  // Mid-tone for natural transition
    glPushMatrix();
    glTranslatef(0.0f, 4.3f, 0.0f);
    glScalef(0.65f, 0.4f, 0.65f);
    createQuad();
    gluSphere(quad, 0.5, 16, 16);
    deleteQuad();
    glPopMatrix();

    // --- ENHANCED CALF MUSCLES (Much More Defined) ---
    glColor3fv(wukongSkinBase);

    // Main calf muscle
    glPushMatrix();
    glTranslatef(0.0f, 3.8f, 0.1f);
    glScalef(0.55f, 0.9f, 0.7f);
    createQuad();
    gluSphere(quad, 0.5, 18, 18);
    deleteQuad();
    glPopMatrix();

    // Gastrocnemius muscle definition with highlights
    glColor3fv(muscleHighlight);  // Highlighted muscle
    glPushMatrix();
    glTranslatef(0.0f, 3.7f, 0.2f);
    glScalef(0.35f, 0.7f, 0.4f);
    createQuad();
    gluSphere(quad, 0.5, 14, 14);
    deleteQuad();
    glPopMatrix();

    // Soleus muscle
    glColor3fv(muscleDefinition);  // Deep muscle definition
    glPushMatrix();
    glTranslatef(0.0f, 3.5f, -0.1f);
    glScalef(0.4f, 0.5f, 0.3f);
    createQuad();
    gluSphere(quad, 0.5, 14, 14);
    deleteQuad();
    glPopMatrix();

    // --- ENHANCED SHIN AREA ---
    glColor3fv(wukongSkinMid);
    glPushMatrix();
    glTranslatef(0.0f, 3.2f, 0.3f);
    glScalef(0.35f, 0.6f, 0.25f);
    createQuad();    gluSphere(quad, 0.5, 14, 14);
    deleteQuad();
    glPopMatrix();

    glPopMatrix();
}

// Enhanced function to draw high-contrast armored combat pants with depth variations
void drawHighContrastArmoredPants(float legHeight) {
    // Enhanced armored pants colors with depth variations
    GLfloat pantsBase[] = { 0.08f, 0.06f, 0.04f, 1.0f };           // Base very dark fabric
    GLfloat pantsHighlight[] = { 0.12f, 0.09f, 0.06f, 1.0f };      // Subtle highlights
    GLfloat pantsDeep[] = { 0.05f, 0.03f, 0.02f, 1.0f };           // Deepest shadows
    GLfloat armorBase[] = { 0.50f, 0.50f, 0.53f, 1.0f };           // Base steel gray
    GLfloat armorLight[] = { 0.62f, 0.62f, 0.65f, 1.0f };          // Lighter armor highlights
    GLfloat armorDeep[] = { 0.38f, 0.38f, 0.41f, 1.0f };           // Deeper armor shadows
    GLfloat rivetBase[] = { 0.40f, 0.40f, 0.42f, 1.0f };           // Base rivet color
    GLfloat rivetHighlight[] = { 0.52f, 0.52f, 0.54f, 1.0f };      // Highlighted rivets
    GLfloat rivetShadow[] = { 0.28f, 0.28f, 0.30f, 1.0f };         // Shadow rivets

    float pantsBottom = 4.2f;
    float pantsTop = pantsBottom + legHeight;

    // Draw main armored pants with depth variation
    int segments = 24;
    float angleStep = 2.0f * PI / segments;

    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        // Vary color based on position for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;  // 0 to 1 based on angle
        if (lightFactor > 0.6f) {
            glColor3fv(pantsHighlight);  // Highlighted areas
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(pantsDeep);       // Shadow areas
        }
        else {
            glColor3fv(pantsBase);       // Base areas
        }

        float bottomRadius = 0.26f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, pantsBottom, z * bottomRadius);

        float topRadius = 0.55f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, pantsTop, z * topRadius);
    }
    glEnd();

    // --- ENHANCED KNEE ARMOR PLATE with depth variations ---
    glColor3fv(armorBase);
    glPushMatrix();
    glTranslatef(0.0f, 5.2f, 0.18f);
    glScalef(0.35f, 0.25f, 0.12f);
    createQuad();
gluSphere(quad, 1.0, 20, 16);
deleteQuad();
    glPopMatrix();

    // Add armor highlights and shadows
    glColor3fv(armorLight);
    glPushMatrix();
    glTranslatef(0.05f, 5.25f, 0.22f);  // Slightly offset for highlight
    glScalef(0.15f, 0.12f, 0.06f);
    createQuad();    gluSphere(quad, 1.0, 12, 8);
    deleteQuad();
    glPopMatrix();

    glColor3fv(armorDeep);
    glPushMatrix();
    glTranslatef(-0.05f, 5.15f, 0.16f);  // Shadow area
    glScalef(0.12f, 0.10f, 0.05f);
    createQuad();
    gluSphere(quad, 1.0, 12, 8);
    deleteQuad();
    glPopMatrix();

    // Enhanced knee armor rivets with varied depth
    for (int i = 0; i < 10; i++) {
        float angle = i * 2.0f * PI / 10.0f;
        float x = sinf(angle) * 0.28f;
        float y = 5.2f + cosf(angle) * 0.18f;

        // Vary rivet colors for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(rivetHighlight);
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(rivetShadow);
        }
        else {
            glColor3fv(rivetBase);
        }

        glPushMatrix();
        glTranslatef(x, y, 0.23f);
        glScalef(0.02f, 0.02f, 0.02f);
        createQuad();
        gluSphere(quad, 1.0f, 8, 8);
        deleteQuad();
        glPopMatrix();
    }
}

// Function to draw Wukong-style outer armor layer with enhanced depth variations
void drawWukongOuterArmorLayer(float legHeight) {
    // Enhanced Wukong armor colors with rich depth variations
    GLfloat goldenBase[] = { 0.80f, 0.65f, 0.20f, 1.0f };         // Base golden armor
    GLfloat goldenLight[] = { 0.95f, 0.78f, 0.28f, 1.0f };        // Bright golden highlights
    GLfloat goldenMid[] = { 0.72f, 0.58f, 0.15f, 1.0f };          // Mid-tone golden
    GLfloat goldenDeep[] = { 0.58f, 0.45f, 0.10f, 1.0f };         // Deep golden shadows
    GLfloat bronzeBase[] = { 0.70f, 0.45f, 0.15f, 1.0f };         // Base bronze
    GLfloat bronzeLight[] = { 0.82f, 0.55f, 0.22f, 1.0f };        // Light bronze highlights
    GLfloat bronzeDeep[] = { 0.55f, 0.32f, 0.08f, 1.0f };         // Deep bronze shadows
    GLfloat darkMetalBase[] = { 0.15f, 0.12f, 0.10f, 1.0f };      // Base dark metal
    GLfloat darkMetalLight[] = { 0.22f, 0.18f, 0.15f, 1.0f };     // Lighter dark metal
    GLfloat jadeBase[] = { 0.20f, 0.60f, 0.30f, 1.0f };           // Base jade
    GLfloat jadeLight[] = { 0.28f, 0.75f, 0.40f, 1.0f };          // Light jade
    GLfloat jadeDeep[] = { 0.12f, 0.45f, 0.20f, 1.0f };           // Deep jade
    GLfloat redBase[] = { 0.80f, 0.20f, 0.10f, 1.0f };            // Base red
    GLfloat redLight[] = { 0.95f, 0.35f, 0.20f, 1.0f };           // Light red
    GLfloat redDeep[] = { 0.60f, 0.12f, 0.05f, 1.0f };            // Deep red

    float armorBottom = 3.8f;
    float armorTop = armorBottom + legHeight + 1.5f;

    // --- MAIN OUTER ARMOR SHELL with depth gradients ---
    int segments = 28;
    float angleStep = 2.0f * PI / segments;

    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        // Create depth through lighting simulation
        float lightFactor = (cosf(angle + PI * 0.3f) + 1.0f) * 0.5f;
        if (lightFactor > 0.7f) {
            glColor3fv(goldenLight);     // Bright highlights
        }
        else if (lightFactor > 0.4f) {
            glColor3fv(goldenBase);      // Mid tones
        }
        else if (lightFactor > 0.2f) {
            glColor3fv(goldenMid);       // Darker mid tones
        }
        else {
            glColor3fv(goldenDeep);      // Deep shadows
        }

        float bottomRadius = 0.4f;
        glNormal3f(x, 0, z);
        glVertex3f(x * bottomRadius, armorBottom, z * bottomRadius);

        float topRadius = 0.7f;
        glNormal3f(x, 0, z);
        glVertex3f(x * topRadius, armorTop, z * topRadius);
    }
    glEnd();

    // --- SEGMENTED ARMOR PLATES with rich depth variations ---
    for (int segment = 0; segment < 6; segment++) {
        float segmentHeight = armorBottom + 0.8f + (segment * 0.7f);
        float heightFactor = (float)segment / 5.0f;  // 0 to 1 from bottom to top

        // Vary golden armor based on height and position
        if (heightFactor > 0.6f) {
            glColor3fv(goldenLight);     // Upper segments brighter
        }
        else if (heightFactor > 0.3f) {
            glColor3fv(goldenBase);      // Middle segments
        }
        else {
            glColor3fv(goldenMid);       // Lower segments more subdued
        }

        glPushMatrix();
        glTranslatef(0.0f, segmentHeight, 0.0f);
        glRotatef(90, 1, 0, 0);
        glScalef(0.42f + (segment * 0.05f), 0.42f + (segment * 0.05f), 0.08f);
        GLUquadric* armorRing = gluNewQuadric();
        gluCylinder(armorRing, 1.0f, 1.0f, 1.0f, segments, 1);
        gluDeleteQuadric(armorRing);
        glPopMatrix();

        // Bronze decorative trim with depth variations
        if (segment % 2 == 0) {
            glColor3fv(bronzeLight);     // Alternating bright bronze
        }
        else {
            glColor3fv(bronzeBase);      // Alternating standard bronze
        }

        glPushMatrix();
        glTranslatef(0.0f, segmentHeight + 0.04f, 0.0f);
        glRotatef(90, 1, 0, 0);
        glScalef(0.44f + (segment * 0.05f), 0.44f + (segment * 0.05f), 0.02f);
        GLUquadric* trim = gluNewQuadric();
        gluCylinder(trim, 1.0f, 1.0f, 1.0f, segments, 1);
        gluDeleteQuadric(trim);
        glPopMatrix();
    }

    // --- ENHANCED KNEE ARMOR with rich depth ---
    glColor3fv(goldenBase);
    glPushMatrix();
    glTranslatef(0.0f, 4.8f, 0.3f);
    glScalef(0.5f, 0.35f, 0.18f);
    GLUquadric* kneeArmor = gluNewQuadric();
    gluSphere(kneeArmor, 1.0, 28, 24);
    gluDeleteQuadric(kneeArmor);
    glPopMatrix();

    // Add knee armor highlights
    glColor3fv(goldenLight);
    glPushMatrix();
    glTranslatef(0.08f, 4.85f, 0.35f);
    glScalef(0.2f, 0.15f, 0.08f);
    GLUquadric* kneeHighlight = gluNewQuadric();
    gluSphere(kneeHighlight, 1.0, 16, 12);
    gluDeleteQuadric(kneeHighlight);
    glPopMatrix();

    // Add knee armor shadows
    glColor3fv(goldenDeep);
    glPushMatrix();
    glTranslatef(-0.08f, 4.75f, 0.28f);
    glScalef(0.15f, 0.12f, 0.06f);
    GLUquadric* kneeShadow = gluNewQuadric();
    gluSphere(kneeShadow, 1.0, 16, 12);
    gluDeleteQuadric(kneeShadow);
    glPopMatrix();

    // Jade accents with depth variations
    for (int i = 0; i < 8; i++) {
        float angle = i * 2.0f * PI / 8.0f;
        float x = sinf(angle) * 0.35f;
        float z = cosf(angle) * 0.12f + 0.35f;

        // Vary jade colors for depth
        float lightFactor = (cosf(angle) + 1.0f) * 0.5f;
        if (lightFactor > 0.6f) {
            glColor3fv(jadeLight);
        }
        else if (lightFactor < 0.3f) {
            glColor3fv(jadeDeep);
        }
        else {
            glColor3fv(jadeBase);
        }

        glPushMatrix();
        glTranslatef(x, 4.8f, z);
        glScalef(0.03f, 0.03f, 0.03f);
        GLUquadric* jadeStud = gluNewQuadric();
        gluSphere(jadeStud, 1.0f, 10, 10);
        gluDeleteQuadric(jadeStud);
        glPopMatrix();
    }

    // --- DECORATIVE SIDE PANELS with enhanced depth ---
    for (int side = -1; side <= 1; side += 2) {
        // Main side panel with gradient
        if (side == -1) {
            glColor3fv(bronzeBase);      // Left side base bronze
        }
        else {
            glColor3fv(bronzeLight);     // Right side lighter bronze
        }

        glPushMatrix();
        glTranslatef(side * 0.45f, 5.5f, 0.1f);
        glScalef(0.15f, 1.8f, 0.3f);
        GLUquadric* sidePanel = gluNewQuadric();
        gluSphere(sidePanel, 1.0f, 20, 20);
        gluDeleteQuadric(sidePanel);
        glPopMatrix();

        // Decorative studs with varied depth
        for (int i = 0; i < 5; i++) {
            float y = 4.8f + i * 0.3f;
            float heightFactor = (float)i / 4.0f;

            // Vary red accents based on height
            if (heightFactor > 0.6f) {
                glColor3fv(redLight);
            }
            else if (heightFactor < 0.3f) {
                glColor3fv(redDeep);
            }
            else {
                glColor3fv(redBase);
            }

            glPushMatrix();
            glTranslatef(side * 0.45f, y, 0.2f);
            glScalef(0.04f, 0.04f, 0.04f);
            GLUquadric* stud = gluNewQuadric();
            gluSphere(stud, 1.0f, 12, 12);
            gluDeleteQuadric(stud);
            glPopMatrix();
        }
    }

    // --- DECORATIVE ENGRAVINGS with enhanced golden variations ---
   /* glDisable(GL_LIGHTING);*/
    glLineWidth(2.5f);

    // Cloud pattern engravings with depth variation
    for (int layer = 0; layer < 4; layer++) {
        float y = 4.5f + layer * 0.8f;
        float layerFactor = (float)layer / 3.0f;

        // Vary engraving brightness based on layer
        if (layerFactor > 0.6f) {
            glColor3f(0.98f, 0.85f, 0.35f);     // Brightest top layers
        }
        else if (layerFactor > 0.3f) {
            glColor3f(0.90f, 0.80f, 0.30f);     // Medium layers
        }
        else {
            glColor3f(0.82f, 0.72f, 0.25f);     // Deeper bottom layers
        }

        glBegin(GL_LINE_STRIP);
        for (int i = 0; i <= 20; i++) {
            float angle = i * 2.0f * PI / 20.0f;
            float radius = 0.3f + sinf(angle * 3.0f) * 0.05f;
            float x = cosf(angle) * radius;
            float z = sinf(angle) * radius * 0.7f + 0.2f;
            glVertex3f(x, y, z);
        }
        glEnd();
    }

    // Dragon scale pattern with depth variation
    for (int ring = 0; ring < 3; ring++) {
        float y = 5.2f + ring * 0.7f;
        float ringFactor = (float)ring / 2.0f;

        if (ringFactor > 0.6f) {
            glColor3f(0.95f, 0.82f, 0.32f);     // Bright upper scales
        }
        else {
            glColor3f(0.85f, 0.75f, 0.28f);     // Deeper lower scales
        }

        for (int scale = 0; scale < 12; scale++) {
            float angle = scale * 2.0f * PI / 12.0f;
            float x = cosf(angle) * 0.38f;
            float z = sinf(angle) * 0.25f + 0.15f;

            glBegin(GL_LINE_LOOP);
            for (int i = 0; i < 6; i++) {
                float scaleAngle = i * PI / 3.0f;
                float dx = cosf(scaleAngle) * 0.03f;
                float dz = sinf(scaleAngle) * 0.02f;
                glVertex3f(x + dx, y, z + dz);
            }
            glEnd();
        }
    }

    glLineWidth(1.0f);
   /* glEnable(GL_LIGHTING);*/
}

// Function to draw realistic 3D shoelaces with proper X-pattern overlapping
void drawRealistic3DShoelaces() {
    // Enhanced lace colors with realistic variations
    GLfloat laceBase[] = { 0.18f, 0.12f, 0.07f, 1.0f };        // Rich dark leather base
    GLfloat laceHighlight[] = { 0.28f, 0.20f, 0.12f, 1.0f };   // Highlighted areas
    GLfloat laceShadow[] = { 0.12f, 0.08f, 0.04f, 1.0f };      // Shadow areas
    GLfloat laceOver[] = { 0.22f, 0.15f, 0.09f, 1.0f };        // Overlapping sections

    // Eyelet positions (6 pairs, from bottom to top)
    const int numEyelets = 6;
    float eyeletPositions[numEyelets];
    for (int i = 0; i < numEyelets; i++) {
        eyeletPositions[i] = 0.4f + i * 0.28f;
    }

    float eyeletLeftX = -0.18f;
    float eyeletRightX = 0.18f;
    float eyeletZ = 0.45f;
    float laceThickness = 0.022f;
    int laceResolution = 10;

    // Helper function to draw a single lace segment with proper 3D orientation
    for (int segmentType = 0; segmentType < 4; segmentType++) {

        if (segmentType == 0) {
            // === BOTTOM TO TOP DIAGONAL LACES (LEFT TO RIGHT) ===
            for (int i = 0; i < numEyelets - 1; i++) {
                float startX = eyeletLeftX;
                float startY = eyeletPositions[i];
                float startZ = eyeletZ;
                float endX = eyeletRightX;
                float endY = eyeletPositions[i + 1];
                float endZ = eyeletZ;
                float zOffset = 0.0f;

                glColor3fv(laceBase);

                // Calculate direction vector and length
                float dx = endX - startX;
                float dy = endY - startY;
                float dz = endZ - startZ;
                float length = sqrtf(dx * dx + dy * dy + dz * dz);

                if (length > 0.001f) {
                    glPushMatrix();

                    // Position at start point with Z offset for layering
                    glTranslatef(startX, startY, startZ + zOffset);

                    // Calculate rotation angles for proper orientation
                    float angleY = atan2f(dx, dz) * 180.0f / PI;
                    float angleX = -atan2f(dy, sqrtf(dx * dx + dz * dz)) * 180.0f / PI;

                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    // Draw the main lace cylinder
                    GLUquadric* lace = gluNewQuadric();
                    gluQuadricOrientation(lace, GLU_OUTSIDE);
                    gluQuadricNormals(lace, GLU_SMOOTH);
                    gluCylinder(lace, laceThickness, laceThickness, length, laceResolution, 1);

                    // Add end caps for complete cylinder
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPushMatrix();
                    glTranslatef(0.0f, 0.0f, length);
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPopMatrix();

                    gluDeleteQuadric(lace);
                    glPopMatrix();

                    // Add highlight stripe along the lace for realism
                    glColor3fv(laceHighlight);
                    glPushMatrix();
                    glTranslatef(startX + dx * 0.1f, startY + dy * 0.1f, startZ + dz * 0.1f + zOffset + 0.01f);
                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    GLUquadric* highlight = gluNewQuadric();
                    gluQuadricOrientation(highlight, GLU_OUTSIDE);
                    gluCylinder(highlight, laceThickness * 0.3f, laceThickness * 0.3f, length * 0.8f, 6, 1);
                    gluDeleteQuadric(highlight);
                    glPopMatrix();
                }
            }
        }
        else if (segmentType == 1) {
            // === TOP TO BOTTOM DIAGONAL LACES (RIGHT TO LEFT) ===
            for (int i = 0; i < numEyelets - 1; i++) {
                float startX = eyeletRightX;
                float startY = eyeletPositions[i];
                float startZ = eyeletZ;
                float endX = eyeletLeftX;
                float endY = eyeletPositions[i + 1];
                float endZ = eyeletZ;
                float zOffset = 0.03f; // Higher Z for overlapping effect

                glColor3fv(laceOver);

                // Calculate direction vector and length
                float dx = endX - startX;
                float dy = endY - startY;
                float dz = endZ - startZ;
                float length = sqrtf(dx * dx + dy * dy + dz * dz);

                if (length > 0.001f) {
                    glPushMatrix();

                    // Position at start point with Z offset for layering
                    glTranslatef(startX, startY, startZ + zOffset);

                    // Calculate rotation angles for proper orientation
                    float angleY = atan2f(dx, dz) * 180.0f / PI;
                    float angleX = -atan2f(dy, sqrtf(dx * dx + dz * dz)) * 180.0f / PI;

                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    // Draw the main lace cylinder
                    GLUquadric* lace = gluNewQuadric();
                    gluQuadricOrientation(lace, GLU_OUTSIDE);
                    gluQuadricNormals(lace, GLU_SMOOTH);
                    gluCylinder(lace, laceThickness, laceThickness, length, laceResolution, 1);

                    // Add end caps for complete cylinder
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPushMatrix();
                    glTranslatef(0.0f, 0.0f, length);
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPopMatrix();

                    gluDeleteQuadric(lace);
                    glPopMatrix();

                    // Add highlight stripe along the lace for realism
                    glColor3fv(laceHighlight);
                    glPushMatrix();
                    glTranslatef(startX + dx * 0.1f, startY + dy * 0.1f, startZ + dz * 0.1f + zOffset + 0.01f);
                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    GLUquadric* highlight = gluNewQuadric();
                    gluQuadricOrientation(highlight, GLU_OUTSIDE);
                    gluCylinder(highlight, laceThickness * 0.3f, laceThickness * 0.3f, length * 0.8f, 6, 1);
                    gluDeleteQuadric(highlight);
                    glPopMatrix();
                }
            }
        }
        else if (segmentType == 2) {
            // === HORIZONTAL CONNECTING SEGMENTS ===
            // These represent the lace going through eyelets horizontally
            for (int i = 1; i < numEyelets - 1; i += 2) { // Every other eyelet pair
                float startX = eyeletLeftX;
                float startY = eyeletPositions[i];
                float startZ = eyeletZ;
                float endX = eyeletRightX;
                float endY = eyeletPositions[i];
                float endZ = eyeletZ;
                float zOffset = 0.015f;

                glColor3fv(laceBase);

                // Calculate direction vector and length
                float dx = endX - startX;
                float dy = endY - startY;
                float dz = endZ - startZ;
                float length = sqrtf(dx * dx + dy * dy + dz * dz);

                if (length > 0.001f) {
                    glPushMatrix();

                    // Position at start point with Z offset for layering
                    glTranslatef(startX, startY, startZ + zOffset);

                    // Calculate rotation angles for proper orientation
                    float angleY = atan2f(dx, dz) * 180.0f / PI;
                    float angleX = -atan2f(dy, sqrtf(dx * dx + dz * dz)) * 180.0f / PI;

                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);

                    // Draw the main lace cylinder
                    GLUquadric* lace = gluNewQuadric();
                    gluQuadricOrientation(lace, GLU_OUTSIDE);
                    gluQuadricNormals(lace, GLU_SMOOTH);
                    gluCylinder(lace, laceThickness, laceThickness, length, laceResolution, 1);

                    // Add end caps for complete cylinder
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPushMatrix();
                    glTranslatef(0.0f, 0.0f, length);
                    gluDisk(lace, 0.0f, laceThickness, laceResolution, 1);
                    glPopMatrix();

                    gluDeleteQuadric(lace);
                    glPopMatrix();
                }
            }
        }
        else if (segmentType == 3) {
            // === REALISTIC INTERSECTION POINTS ===
            // Add small cylindrical intersections where laces cross
            for (int i = 0; i < numEyelets - 2; i++) {
                for (int j = i + 1; j < numEyelets - 1; j++) {
                    // Calculate intersection points of crossing diagonals
                    float y1_start = eyeletPositions[i];
                    float y1_end = eyeletPositions[i + 1];
                    float y2_start = eyeletPositions[j];
                    float y2_end = eyeletPositions[j + 1];

                    // Parametric intersection calculation
                    float denom = ((y1_end - y1_start) - (y2_end - y2_start));
                    if (fabsf(denom) > 0.001f) {
                        float t = (y2_start - y1_start) / denom;

                        if (t > 0.1f && t < 0.9f) { // Only draw if intersection is in middle of segments
                            float intersectX = eyeletLeftX + t * (eyeletRightX - eyeletLeftX);
                            float intersectY = y1_start + t * (y1_end - y1_start);

                            // Draw small intersection cylinder
                            glColor3fv(laceShadow);
                            glPushMatrix();
                            glTranslatef(intersectX, intersectY, eyeletZ + 0.025f);
                            GLUquadric* intersection = gluNewQuadric();
                            gluSphere(intersection, laceThickness * 1.2f, 8, 8);
                            gluDeleteQuadric(intersection);
                            glPopMatrix();
                        }
                    }
                }
            }
        }
    }

    // === CURVED LACE SEGMENTS AROUND EYELETS ===
    // Add small curved segments where laces bend around eyelets
    for (int i = 0; i < numEyelets; i++) {
        float y = eyeletPositions[i];

        // Left and right eyelet curves
        glColor3fv(laceBase);
        for (int side = 0; side < 2; side++) { // 0=left, 1=right
            float x = (side == 0) ? eyeletLeftX : eyeletRightX;

            glPushMatrix();
            glTranslatef(x, y, eyeletZ + 0.02f);

            // Create a small curved segment
            GLUquadric* curve = gluNewQuadric();
            gluQuadricOrientation(curve, GLU_OUTSIDE);

            // Draw quarter-circle curves
            for (int angle = 0; angle < 180; angle += 20) {
                float rad = angle * PI / 180.0f;
                float curveX = cosf(rad) * 0.03f;
                float curveY = sinf(rad) * 0.03f;

                glPushMatrix();
                glTranslatef(curveX, curveY, 0.0f);
                gluSphere(curve, laceThickness * 0.7f, 6, 6);
                glPopMatrix();
            }

            gluDeleteQuadric(curve);
            glPopMatrix();
        }
    }

    // === LOOSE LACE ENDS LEADING TO BOW ===
    // Two lace ends coming from top eyelets
    for (int side = 0; side < 2; side++) {
        float x = (side == 0) ? eyeletLeftX : eyeletRightX;
        float topY = eyeletPositions[numEyelets - 1];

        glColor3fv(laceBase);
        glPushMatrix();
        glTranslatef(x, topY, eyeletZ);

        // Angle the lace end upward toward the bow
        glRotatef(70.0f + (side * 20.0f), 1, 0, 0); // 70-90 degrees upward
        glRotatef((side == 0) ? -10.0f : 10.0f, 0, 0, 1); // Slight inward angle

        // Draw tapered lace end
        GLUquadric* laceEnd = gluNewQuadric();
        gluQuadricOrientation(laceEnd, GLU_OUTSIDE);
        gluCylinder(laceEnd, laceThickness, laceThickness * 0.6f, 0.25f, laceResolution, 1);
        gluDisk(laceEnd, 0.0f, laceThickness, laceResolution, 1);
        gluDeleteQuadric(laceEnd);
        glPopMatrix();

        // Add highlight to lace end
        glColor3fv(laceHighlight);
        glPushMatrix();
        glTranslatef(x + 0.01f, topY + 0.01f, eyeletZ + 0.01f);
        glRotatef(70.0f + (side * 20.0f), 1, 0, 0);
        glRotatef((side == 0) ? -10.0f : 10.0f, 0, 0, 1);

        GLUquadric* endHighlight = gluNewQuadric();
        gluCylinder(endHighlight, laceThickness * 0.3f, laceThickness * 0.2f, 0.2f, 6, 1);
        gluDeleteQuadric(endHighlight);
        glPopMatrix();
    }

    // === AGLET TIPS (PLASTIC/METAL LACE TIPS) ===
    // Add small metallic tips to lace ends for realism
    GLfloat agletColor[] = { 0.4f, 0.4f, 0.42f, 1.0f }; // Metallic gray

    for (int side = 0; side < 2; side++) {
        float x = (side == 0) ? eyeletLeftX : eyeletRightX;
        float topY = eyeletPositions[numEyelets - 1];

        glColor3fv(agletColor);
        glPushMatrix();
        glTranslatef(x, topY + 0.15f, eyeletZ + 0.12f);
        glRotatef(70.0f + (side * 20.0f), 1, 0, 0);
        glRotatef((side == 0) ? -10.0f : 10.0f, 0, 0, 1);

        // Draw small metallic aglet
        GLUquadric* aglet = gluNewQuadric();
        gluQuadricOrientation(aglet, GLU_OUTSIDE);
        gluCylinder(aglet, laceThickness * 1.1f, laceThickness * 0.8f, 0.04f, 8, 1);

        // Add end cap
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.04f);
        gluSphere(aglet, laceThickness * 0.8f, 6, 6);
        glPopMatrix();

        gluDeleteQuadric(aglet);
        glPopMatrix();
    }
}

// Function to draw a decorative bow/knot at the top of the lacing area
void drawDecorativeBowKnot() {
    // Colors for the bow
    GLfloat bowBase[] = { 0.18f, 0.10f, 0.05f, 1.0f };          // Rich dark leather
    GLfloat bowLight[] = { 0.25f, 0.15f, 0.08f, 1.0f };         // Highlight areas
    GLfloat bowDeep[] = { 0.12f, 0.06f, 0.03f, 1.0f };          // Shadow areas

    // Center knot - the main part that ties the loops together
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(0.0f, 0.0f, 0.0f);
    glScalef(0.08f, 0.04f, 0.04f);
    GLUquadric* bowCenter = gluNewQuadric();
    gluSphere(bowCenter, 1.0f, 16, 16);
    gluDeleteQuadric(bowCenter);
    glPopMatrix();

    // Add highlight to the center knot
    glColor3fv(bowLight);
    glPushMatrix();
    glTranslatef(0.02f, 0.01f, 0.01f);
    glScalef(0.03f, 0.02f, 0.02f);
    GLUquadric* knobHighlight = gluNewQuadric();
    gluSphere(knobHighlight, 1.0f, 12, 12);
    gluDeleteQuadric(knobHighlight);
    glPopMatrix();

    // Left bow loop
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(-0.10f, 0.0f, 0.0f);
    glRotatef(30.0f, 0.0f, 0.0f, 1.0f);  // Tilt slightly
    glRotatef(15.0f, 0.0f, 1.0f, 0.0f);  // Rotate a bit forward
    glScalef(0.12f, 0.06f, 0.025f);
    GLUquadric* leftLoop = gluNewQuadric();
    gluSphere(leftLoop, 1.0f, 16, 16);
    gluDeleteQuadric(leftLoop);
    glPopMatrix();

    // Add highlight to left loop
    glColor3fv(bowLight);
    glPushMatrix();
    glTranslatef(-0.12f, 0.01f, 0.01f);
    glRotatef(30.0f, 0.0f, 0.0f, 1.0f);
    glScalef(0.05f, 0.03f, 0.015f);
    GLUquadric* leftHighlight = gluNewQuadric();
    gluSphere(leftHighlight, 1.0f, 12, 12);
    gluDeleteQuadric(leftHighlight);
    glPopMatrix();

    // Add shadow to left loop
    glColor3fv(bowDeep);
    glPushMatrix();
    glTranslatef(-0.08f, -0.01f, -0.01f);
    glRotatef(30.0f, 0.0f, 0.0f, 1.0f);
    glScalef(0.04f, 0.02f, 0.015f);
    GLUquadric* leftShadow = gluNewQuadric();
    gluSphere(leftShadow, 1.0f, 12, 12);
    gluDeleteQuadric(leftShadow);
    glPopMatrix();

    // Right bow loop
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(0.10f, 0.0f, 0.0f);
    glRotatef(-30.0f, 0.0f, 0.0f, 1.0f);  // Tilt slightly (mirror of left)
    glRotatef(15.0f, 0.0f, 1.0f, 0.0f);   // Rotate a bit forward
    glScalef(0.12f, 0.06f, 0.025f);
    GLUquadric* rightLoop = gluNewQuadric();
    gluSphere(rightLoop, 1.0f, 16, 16);
    gluDeleteQuadric(rightLoop);
    glPopMatrix();

    // Add highlight to right loop
    glColor3fv(bowLight);
    glPushMatrix();
    glTranslatef(0.12f, 0.01f, 0.01f);
    glRotatef(-30.0f, 0.0f, 0.0f, 1.0f);
    glScalef(0.05f, 0.03f, 0.015f);
    GLUquadric* rightHighlight = gluNewQuadric();
    gluSphere(rightHighlight, 1.0f, 12, 12);
    gluDeleteQuadric(rightHighlight);
    glPopMatrix();

    // Add shadow to right loop
    glColor3fv(bowDeep);
    glPushMatrix();
    glTranslatef(0.08f, -0.01f, -0.01f);
    glRotatef(-30.0f, 0.0f, 0.0f, 1.0f);
    glScalef(0.04f, 0.02f, 0.015f);
    GLUquadric* rightShadow = gluNewQuadric();
    gluSphere(rightShadow, 1.0f, 12, 12);
    gluDeleteQuadric(rightShadow);
    glPopMatrix();

    // Lower left tail of the bow
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(-0.06f, -0.05f, -0.005f);
    glRotatef(-15.0f, 0.0f, 0.0f, 1.0f);
    glRotatef(-10.0f, 1.0f, 0.0f, 0.0f);
    glScalef(0.05f, 0.10f, 0.02f);
    GLUquadric* leftTail = gluNewQuadric();
    gluSphere(leftTail, 1.0f, 14, 14);
    gluDeleteQuadric(leftTail);
    glPopMatrix();

    // Lower right tail of the bow
    glColor3fv(bowBase);
    glPushMatrix();
    glTranslatef(0.06f, -0.05f, -0.005f);
    glRotatef(15.0f, 0.0f, 0.0f, 1.0f);
    glRotatef(-10.0f, 1.0f, 0.0f, 0.0f);
    glScalef(0.05f, 0.10f, 0.02f);
    GLUquadric* rightTail = gluNewQuadric();
    gluSphere(rightTail, 1.0f, 14, 14);
    gluDeleteQuadric(rightTail);
    glPopMatrix();
}

// Enhanced function to draw smooth polygon shoes with complete coverage like real shoes
void drawEnhancedHeritageBootWithContrast(bool isLeft) {
    // Enhanced colors for realistic shoe appearance
    GLfloat soleBase[] = { 0.08f, 0.06f, 0.04f, 1.0f };           // Dark sole base
    GLfloat soleLight[] = { 0.12f, 0.09f, 0.06f, 1.0f };          // Sole highlights
    GLfloat soleDeep[] = { 0.04f, 0.02f, 0.01f, 1.0f };           // Deep sole shadows

    // Premium leather colors for smooth appearance
    GLfloat leatherBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };        // Rich leather base
    GLfloat leatherLight[] = { 0.58f, 0.42f, 0.28f, 1.0f };       // Leather highlights
    GLfloat leatherMid[] = { 0.40f, 0.25f, 0.15f, 1.0f };         // Mid-tone leather
    GLfloat leatherDeep[] = { 0.28f, 0.16f, 0.08f, 1.0f };        // Deep leather shadows

    // Smooth upper materials
    GLfloat upperBase[] = { 0.35f, 0.22f, 0.15f, 1.0f };          // Upper material base
    GLfloat upperLight[] = { 0.45f, 0.32f, 0.22f, 1.0f };         // Upper highlights
    GLfloat upperDeep[] = { 0.25f, 0.14f, 0.08f, 1.0f };          // Upper shadows

    // Metal accents
    GLfloat metalBase[] = { 0.45f, 0.45f, 0.47f, 1.0f };          // Metal base
    GLfloat metalLight[] = { 0.62f, 0.62f, 0.65f, 1.0f };         // Metal highlights
    GLfloat metalDeep[] = { 0.28f, 0.28f, 0.30f, 1.0f };          // Metal shadows

    glPushMatrix();

    if (!isLeft) {
        glScalef(-1.0f, 1.0f, 1.0f);
    }

    // === SEAMLESS SOLE CONSTRUCTION (COMPLETELY CLOSED LIKE REAL SHOES) ===

    // MAIN CONTINUOUS SOLE - Single seamless piece
    glColor3fv(soleBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.75f, 0.1f);
    glScalef(0.9f, 0.25f, 2.8f);  // Larger for complete coverage
    GLUquadric* continuousSole = gluNewQuadric();
    gluSphere(continuousSole, 0.5, 48, 48);  // High resolution for smoothness
    gluDeleteQuadric(continuousSole);
    glPopMatrix();

    // PERFECTLY FLAT BOTTOM - No gaps or openings
    glColor3fv(soleDeep);
    glPushMatrix();
    glTranslatef(0.0f, -0.95f, 0.1f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.92f, 2.85f, 0.05f);
    GLUquadric* flatBottom = gluNewQuadric();
    gluDisk(flatBottom, 0.0f, 0.5f, 48, 1);  // Completely sealed bottom
    gluDeleteQuadric(flatBottom);
    glPopMatrix();

    // SEAMLESS SOLE EDGE - Continuous rim with no breaks
    glColor3fv(soleLight);
    glPushMatrix();
    glTranslatef(0.0f, -0.85f, 0.1f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.91f, 2.82f, 0.08f);
    GLUquadric* soleEdge = gluNewQuadric();
    gluCylinder(soleEdge, 0.5, 0.5, 1.0, 48, 1);  // Smooth continuous edge
    gluDeleteQuadric(soleEdge);
    glPopMatrix();

    // === SEAMLESS UPPER CONSTRUCTION ===
    int segments = 48;  // High resolution for smooth appearance
    float angleStep = 2.0f * PI / segments;

    // MAIN UPPER BODY - Single seamless piece
    glColor3fv(leatherBase);
    glBegin(GL_TRIANGLE_STRIP);
    for (int i = 0; i <= segments; i++) {
        float angle = i * angleStep;
        float x = cosf(angle);
        float z = sinf(angle);

        float lightFactor = (cosf(angle + PI * 0.25f) + 1.0f) * 0.5f;
        if (lightFactor > 0.7f) glColor3fv(leatherLight);
        else if (lightFactor > 0.3f) glColor3fv(leatherBase);
        else glColor3fv(leatherDeep);

        glNormal3f(x, 0, z);
        glVertex3f(x * 0.52f, -0.6f, z * 0.45f + 0.1f);  // Sole connection
        glVertex3f(x * 0.48f, 2.9f, z * 0.4f);           // Top opening
    }
    glEnd();

    // TOP CLOSURE - Complete seal
    glColor3fv(leatherMid);
    glPushMatrix();
    glTranslatef(0.0f, 2.9f, 0.0f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.48f, 0.4f, 0.08f);
    GLUquadric* topClosure = gluNewQuadric();
    gluDisk(topClosure, 0.0f, 1.0f, segments, 1);
    gluDeleteQuadric(topClosure);
    glPopMatrix();

    // SEAMLESS TOE CAP
    glColor3fv(leatherBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.25f, 0.85f);
    glScalef(0.72f, 0.65f, 0.9f);
    GLUquadric* seamlessToe = gluNewQuadric();
    gluSphere(seamlessToe, 0.5, 32, 32);
    gluDeleteQuadric(seamlessToe);
    glPopMatrix();

    // SEAMLESS HEEL
    glColor3fv(leatherBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.25f, -0.45f);
    glScalef(0.7f, 0.7f, 0.8f);
    GLUquadric* seamlessHeel = gluNewQuadric();
    gluSphere(seamlessHeel, 0.5, 32, 32);
    gluDeleteQuadric(seamlessHeel);
    glPopMatrix();

    // CONTINUOUS WELT
    glColor3fv(upperBase);
    glPushMatrix();
    glTranslatef(0.0f, -0.65f, 0.1f);
    glRotatef(90, 1, 0, 0);
    glScalef(0.87f, 2.75f, 0.08f);
    GLUquadric* continuousWelt = gluNewQuadric();
    gluCylinder(continuousWelt, 0.5, 0.5, 1.0, 48, 1);
    gluDeleteQuadric(continuousWelt);
    glPopMatrix();

    // SIMPLE EYELETS
    glColor3fv(metalBase);
    for (int i = 0; i < 6; i++) {
        float y = 0.4f + i * 0.28f;
        if (i % 2 == 0) glColor3fv(metalLight);
        else glColor3fv(metalBase);

        glPushMatrix();
        glTranslatef(-0.18f, y, 0.45f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* leftEyelet = gluNewQuadric();
        gluSphere(leftEyelet, 1.0f, 12, 12);
        gluDeleteQuadric(leftEyelet);
        glPopMatrix();

        glPushMatrix();
        glTranslatef(0.18f, y, 0.45f);
        glScalef(0.02f, 0.02f, 0.02f);
        GLUquadric* rightEyelet = gluNewQuadric();
        gluSphere(rightEyelet, 1.0f, 12, 12);
        gluDeleteQuadric(rightEyelet);
        glPopMatrix();
    }

    // Draw realistic 3D shoelaces with X-pattern overlapping
    drawRealistic3DShoelaces();

    // COLLAR
    glColor3fv(upperBase);
    glPushMatrix();
    glTranslatef(0.0f, 2.7f, 0.0f);
    glScalef(0.5f, 0.18f, 0.42f);
    GLUquadric* collar = gluNewQuadric();
    gluSphere(collar, 1.0f, 24, 24);
    gluDeleteQuadric(collar);
    glPopMatrix();

    // MINIMAL TREAD
    //glDisable(GL_LIGHTING);
    glColor3f(0.06f, 0.04f, 0.02f);
    glLineWidth(1.0f);

    for (int i = 0; i < 12; i++) {
        float z = -1.2f + (i * 0.2f);
        glBegin(GL_LINES);
        for (int j = 0; j < 8; j++) {
            float x = -0.3f + (j * 0.075f);
            glVertex3f(x, -0.93f, z);
            glVertex3f(x + 0.05f, -0.93f, z);
        }
        glEnd();
    }

   /* glEnable(GL_LIGHTING);*/

    // NEW: DECORATIVE BOW KNOT AT TOP OF LACING
    glPushMatrix();
    glTranslatef(0.0f, 2.0f, 0.48f); // Position at the top of the lacing area
    drawDecorativeBowKnot();
    glPopMatrix();

    glPopMatrix();
}




// Enhanced function to draw complete Black Myth Wukong character
void drawBlackMythWukongCharacter(bool isLeft) {
}
    #define WINDOW_TITLE "Wukong Arms - Controllable with Fur"

    // Animation and control variables - Left and Right arms
    float shoulderAngle[2] = {0.0f, 0.0f};
    float elbowAngle[2] = {0.0f, 0.0f};
    float wristAngle[2] = {0.0f, 0.0f};

    // Finger control - each finger has 3 joints for both arms
    float thumbAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    float indexAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    float middleAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    float ringAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};
    float pinkyAngles[2][3] = {{0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}};

    // Control state
    int activeArm = 0; // 0 = left, 1 = right
    int activeLeg = -1; // -1 = none, 0 = left, 1 = right
    
    // Limb control mode
    enum ControlMode { CAMERA, LEFT_ARM, RIGHT_ARM, LEFT_LEG, RIGHT_LEG };
    ControlMode currentControlMode = CAMERA; // Default to camera control
    
    // Status text to display current control mode
    bool showStatus = true; // Toggle to show/hide status text
    
    // Limb rotation angles for manual control
    float armRotationX[2] = { 0.0f, 0.0f }; // X rotation for left and right arms
    float armRotationY[2] = { 0.0f, 0.0f }; // Y rotation for left and right arms
    float armRotationZ[2] = { 0.0f, 0.0f }; // Z rotation for left and right arms
    
    float legRotationX[2] = { 0.0f, 0.0f }; // X rotation for left and right legs
    float legRotationY[2] = { 0.0f, 0.0f }; // Y rotation for left and right legs
    float legRotationZ[2] = { 0.0f, 0.0f }; // Z rotation for left and right legs

    // Camera control
    float cameraAngleX = 0.0f;
    float cameraAngleY = 0.0f;
    float cameraDistance = 30.0f;
    bool cameraEnabled = true; // Toggle for camera view

    // Key states
    bool keys[256] = {false};
#include <vector>   // add this near your other includes
    float armSwingAngle[2] = { 0.0f, -0.0f }; // left arm forward, right arm back
    int armSwingDir[2] = { -1, 1 };             // opposite swing directions
    float legSwingAngle[2] = { 0.0f, -0.0f };   // left leg forward, right leg back
    int legSwingDir[2] = { 1, -1 };             // opposite swing directions to arms
    
    // Walking system variables
    bool isWalking = false;
    bool wasWPressed = false;  // Track W key state to prevent rapid toggling
    float characterX = 0.0f;   // Character position X
    float characterZ = 0.0f;   // Character position Z
    float characterRotation = 0.0f;  // Character rotation in degrees
    float walkingSpeed = 0.1f; // Speed of forward/backward movement
    float turningSpeed = 2.0f; // Speed of turning left/right
    
    // Wrist and ankle movement for realistic walking
    float wristSwingAngle[2] = { 0.0f, -0.0f };   // left wrist, right wrist
    float ankleSwingAngle[2] = { 0.0f, -0.0f };   // left ankle, right ankle
    
    // Jumping system variables
    bool isJumping = false;
    bool wasEPressed = false;  // Track E key state to prevent rapid jumping
    float jumpVelocity = 0.0f; // Current jump velocity
    float characterY = 0.0f;   // Character height position
    float gravity = -0.02f;    // Gravity constant
    float jumpForce = 0.8f;    // Initial jump force
    float groundLevel = 0.0f;  // Ground level (where character lands)
    
    // Jump animation variables
    float jumpArmAngle = 0.0f;  // Arms raised during jump
    float jumpLegAngle = 0.0f;  // Legs bent during jump
    
    // Head rotation system variables
    float headRotationY = 0.0f;  // Head rotation around Y-axis (left/right)
    float headRotationX = 0.0f;  // Head rotation around X-axis (up/down)
    bool wasRPressed = false;    // Track R key state to prevent rapid rotation
    bool wasTPressed = false;    // Track T key state to prevent rapid rotation
    bool wasUPressed = false;    // Track U key state for vertical rotation
    bool wasYPressed = false;    // Track Y key state for vertical rotation
    float headTurnSpeed = 5.0f;  // Speed of head rotation (increased for more responsiveness)
    float headReturnSpeed = 2.5f; // Speed of returning to center (faster return)
    float maxHeadRotation = 90.0f; // Maximum rotation in degrees (realistic limit)
    float maxHeadVerticalRotation = 45.0f; // Maximum vertical rotation in degrees
    
    // Character duplication system variables
    bool wasGPressed = false;     // Track G key state to prevent rapid duplication
    bool isLeftDuplicate = false; // Track if left duplicate exists
    bool isRightDuplicate = false; // Track if right duplicate exists
    float duplicateOffset = 3.0f;  // Distance offset for duplicates
    
    // Hi animation system variables
    bool isHiAnimating = false;        // Track if hi animation is active
    bool wasHPressed = false;          // Track H key state to prevent rapid toggling
    float hiAnimationTime = 0.0f;      // Current animation time
    float hiAnimationDuration = 2.0f;  // Total duration of hi animation (2 seconds)
    float hiArmAngle = 0.0f;           // Current hi arm angle
    float hiWristAngle = 0.0f;         // Current hi wrist angle
    float hiHandRotation = 0.0f;       // Current hi hand rotation angle
    
    // Slapping animation system variables
    bool isSlapAnimating = false;      // Track if slapping animation is active
    bool wasCPressed = false;          // Track C key state to prevent rapid toggling
    float slapAnimationTime = 0.0f;    // Current slapping animation time
    float slapAnimationDuration = 1.0f; // Total duration of slapping animation (1 second)
    float slapArmAngle[2] = {0.0f, 0.0f}; // Current slapping arm angles for both arms
    float slapWristAngle[2] = {0.0f, 0.0f}; // Current slapping wrist angles
    int slapPhase = 0;                 // 0 = not active, 1 = moving together, 2 = clap contact, 3 = returning
    float maxSlapAngle = 25.0f;       // Maximum angle for slapping motion
    
    // Calf kick animation system variables
    bool isKickAnimating = false;      // Track if kick animation is active
    bool wasKPressed = false;          // Track K key state to prevent rapid toggling
    float kickAnimationTime = 0.0f;    // Current kick animation time
    float kickAnimationDuration = 1.0f; // Total duration of kick animation (1.2 seconds)
    float kickThighAngle = 0.0f;       // Current thigh angle for kick
    float kickKneeAngle = 0.0f;        // Current knee angle for kick
    float kickBodyTilt = 0.0f;         // Body tilt during kick for balance
    int kickPhase = 0;                 // 0 = not active, 1 = charging, 2 = kick forward, 3 = return
    float maxKickAngle = 43.0f;  // Maximum angle for kick motion (70 degrees)
    float kickChargingEnd = 0.25f;     // Charging phase ends at 25% of animation
    float kickForwardEnd = 0.65f;      // Forward phase ends at 65% of animation
    
    // Bow down animation system variables
    bool isBowingAnimating = false;    // Track if bowing animation is active
    bool wasJPressed = false;          // Track J key state to prevent rapid toggling
    float bowAnimationTime = 0.0f;     // Current bow animation time
    float bowAnimationDuration = 1.5f; // Total duration of bow animation (1.5 seconds)
    float bowAngle = 0.0f;             // Current bow angle for upper body
    int bowPhase = 0;                  // 0 = not active, 1 = bowing down, 2 = holding, 3 = returning
    float maxBowAngle = 45.0f;         // Maximum angle for bow motion (45 degrees)
    float bowDownEnd = 0.4f;           // Bowing down phase ends at 40% of animation
    float bowHoldEnd = 0.6f;           // Hold phase ends at 60% of animation
    float bowArmAngle[2] = {0.0f, 0.0f}; // Current arm angles during bow animation
    float bowWristAngle[2] = {0.0f, 0.0f}; // Current wrist angles during bow animation



    struct FurPatch {
        float x, y, z;
        float nx, ny, nz;   // outward direction
        float length;
    };
    // Precomputed fur arrays for parts (per arm where relevant)
    std::vector<FurPatch> upperArmFur[2];
    std::vector<FurPatch> forearmFur[2];
    std::vector<FurPatch> shoulderFur[2];
    std::vector<FurPatch> palmFur[2];

    // Utility forward declarations
    void generateFurForCylinder(std::vector<FurPatch>& out, float radius, float height, int furCount);
    void generateFurForSphere(std::vector<FurPatch>& out, float radius, int furCount);
    void drawFurFromArray(const std::vector<FurPatch>& arr);
    void precomputeAllFur();

    LRESULT WINAPI WindowProcedure(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        switch (msg)
        {
        case WM_KEYDOWN:
            switch (wParam)
            {
            case VK_UP:
                // Handle arrow key based on current control mode
                if (currentControlMode == CAMERA) {
                    // Only control camera if in camera mode
                    cameraAngleX += 1.0f;
                    if (cameraAngleX > 89.0f) cameraAngleX = 89.0f;
                }
                else if (currentControlMode == LEFT_ARM) {
                    // Control left arm
                    armRotationX[0] += 5.0f;
                    if (armRotationX[0] > 90.0f) armRotationX[0] = 90.0f;
                }
                else if (currentControlMode == RIGHT_ARM) {
                    // Control right arm
                    armRotationX[1] += 5.0f;
                    if (armRotationX[1] > 90.0f) armRotationX[1] = 90.0f;
                }
                else if (currentControlMode == LEFT_LEG) {
                    // Control left leg
                    legRotationX[0] += 5.0f;
                    if (legRotationX[0] > 90.0f) legRotationX[0] = 90.0f;
                }
                else if (currentControlMode == RIGHT_LEG) {
                    // Control right leg
                    legRotationX[1] += 5.0f;
                    if (legRotationX[1] > 90.0f) legRotationX[1] = 90.0f;
                }
                break;

            case VK_DOWN:
                // Handle arrow key based on current control mode
                if (currentControlMode == CAMERA) {
                    // Only control camera if in camera mode
                    cameraAngleX -= 1.0f;
                    if (cameraAngleX < -89.0f) cameraAngleX = -89.0f;
                }
                else if (currentControlMode == LEFT_ARM) {
                    // Control left arm
                    armRotationX[0] -= 5.0f;
                    if (armRotationX[0] < -90.0f) armRotationX[0] = -90.0f;
                }
                else if (currentControlMode == RIGHT_ARM) {
                    // Control right arm
                    armRotationX[1] -= 5.0f;
                    if (armRotationX[1] < -90.0f) armRotationX[1] = -90.0f;
                }
                else if (currentControlMode == LEFT_LEG) {
                    // Control left leg
                    legRotationX[0] -= 5.0f;
                    if (legRotationX[0] < -90.0f) legRotationX[0] = -90.0f;
                }
                else if (currentControlMode == RIGHT_LEG) {
                    // Control right leg
                    legRotationX[1] -= 5.0f;
                    if (legRotationX[1] < -90.0f) legRotationX[1] = -90.0f;
                }
                break;

            case VK_LEFT:
                // Handle arrow key based on current control mode
                if (currentControlMode == CAMERA) {
                    // Only control camera if in camera mode
                    cameraAngleY += 1.0f;
                }
                else if (currentControlMode == LEFT_ARM) {
                    // Control left arm
                    armRotationY[0] += 5.0f;
                    if (armRotationY[0] > 90.0f) armRotationY[0] = 90.0f;
                }
                else if (currentControlMode == RIGHT_ARM) {
                    // Control right arm
                    armRotationY[1] += 5.0f;
                    if (armRotationY[1] > 90.0f) armRotationY[1] = 90.0f;
                }
                else if (currentControlMode == LEFT_LEG) {
                    // Control left leg
                    legRotationY[0] += 5.0f;
                    if (legRotationY[0] > 45.0f) legRotationY[0] = 45.0f;
                }
                else if (currentControlMode == RIGHT_LEG) {
                    // Control right leg
                    legRotationY[1] += 5.0f;
                    if (legRotationY[1] > 45.0f) legRotationY[1] = 45.0f;
                }
                break;

            case VK_RIGHT:
                // Handle arrow key based on current control mode
                if (currentControlMode == CAMERA) {
                    // Only control camera if in camera mode
                    cameraAngleY -= 1.0f;
                }
                else if (currentControlMode == LEFT_ARM) {
                    // Control left arm
                    armRotationY[0] -= 5.0f;
                    if (armRotationY[0] < -90.0f) armRotationY[0] = -90.0f;
                }
                else if (currentControlMode == RIGHT_ARM) {
                    // Control right arm
                    armRotationY[1] -= 5.0f;
                    if (armRotationY[1] < -90.0f) armRotationY[1] = -90.0f;
                }
                else if (currentControlMode == LEFT_LEG) {
                    // Control left leg
                    legRotationY[0] -= 5.0f;
                    if (legRotationY[0] < -45.0f) legRotationY[0] = -45.0f;
                }
                else if (currentControlMode == RIGHT_LEG) {
                    // Control right leg
                    legRotationY[1] -= 5.0f;
                    if (legRotationY[1] < -45.0f) legRotationY[1] = -45.0f;
                }
                break;

            case 'Z':  // zoom in
                cameraDistance -= 0.2f;
                if (cameraDistance < 3.0f) cameraDistance = 3.0f;
                break;

            case 'X':  // zoom out
                cameraDistance += 0.2f;
                if (cameraDistance > 40.0f) cameraDistance = 40.0f;
                break;

            case 'W':  // toggle walking
                isWalking = true;
                break;

            case 'Q':  // toggle walking
                isWalking = false;
                break;

            case VK_ESCAPE: // quit app
                PostQuitMessage(0);
                break;

            case'1': // toggle light 0

                g_light0On = !g_light0On;
                if (g_light0On) glEnable(GL_LIGHT0);
                else            glDisable(GL_LIGHT0);
                break;

            case '2': // toggle light 1

                g_light1On = !g_light1On;
               if (g_light1On) glEnable(GL_LIGHT1);
                else            glDisable(GL_LIGHT1);
                break;
            case '3': // toggle fire texture on weapon
                if (g_showWeapon) {
                    g_weaponFireTexture = !g_weaponFireTexture;
                    if (g_weaponFireTexture) {
                        // Load fire texture if not already loaded
                        if (g_fireTexture == 0) {
                            g_fireTexture = loadTexture("fire.bmp");
                        }
                        // --- ADD THIS BLOCK to load the lava texture ---
                        if (g_lavaTexture == 0) {
                            g_lavaTexture = loadTexture("lava.bmp");
                        }
                    }
                }
                break;
            case '4': // toggle flower field background
                flowerFieldEnabled = !flowerFieldEnabled;
                break;
                
            case 'P': // toggle projection mode
                usePerspective = !usePerspective;

                ResizeGL(1024, 768);  // or current window size
                break;
                
            case '9': // toggle weapon visibility
                g_showWeapon = !g_showWeapon;
                if (g_showWeapon) {
                    // Start grip animation when weapon is shown
                    g_weaponGripAnimation = 0.0f;
                    g_weaponAnimating = true;
                } else {
                    // Reset hand position when weapon is hidden
                    g_weaponGripAnimation = 0.0f;
                    g_weaponAnimating = false;
                }
                break;
                
            case 'L': // overhead smash attack
                if (g_showWeapon && !g_smashAttacking) {
                    // Start overhead smash attack only if weapon is equipped
                    g_smashAttacking = true;
                    g_smashPhase = 1; // Start with raising arm
                    g_smashAngle = 0.0f;
                }
                break;
                
            case 'H': // hi animation
                if (!isHiAnimating) {
                    // Start hi animation only if not already animating
                    isHiAnimating = true;
                    hiAnimationTime = 0.0f;  // Reset animation time
                    hiArmAngle = 0.0f;       // Start from neutral position
                    hiWristAngle = 0.0f;     // Start from neutral position
                    hiHandRotation = 0.0f;   // Start from neutral position
                }
                break;
                
            case 'K': // calf kick animation
                if (!isKickAnimating) {
                    // Start kick animation only if not already animating
                    isKickAnimating = true;
                    kickAnimationTime = 0.0f;  // Reset animation time
                    kickThighAngle = 0.0f;     // Start from neutral position
                    kickKneeAngle = 0.0f;      // Start from neutral position
                    kickBodyTilt = 0.0f;       // Start from neutral position
                    kickPhase = 1;             // Start with charging phase
                }
                break;
                
            case 'C': // slapping animation
                if (!isSlapAnimating) {
                    // Start slapping animation only if not already animating
                    isSlapAnimating = true;
                    slapAnimationTime = 0.0f;  // Reset animation time
                    slapArmAngle[0] = 0.0f;     // Start from neutral position (left arm)
                    slapArmAngle[1] = 0.0f;     // Start from neutral position (right arm)
                    slapWristAngle[0] = 0.0f;   // Start from neutral wrist position
                    slapWristAngle[1] = 0.0f;   // Start from neutral wrist position
                    slapPhase = 1;              // Start with moving together phase
                }
                break;
                
            case 'J': // bow down animation
                if (!isBowingAnimating) {
                    // Start bow down animation only if not already animating
                    isBowingAnimating = true;
                    bowAnimationTime = 0.0f;  // Reset animation time
                    bowAngle = 0.0f;          // Start from neutral position
                    bowPhase = 1;             // Start with bowing down phase
                }
                break;
                
            case 'I': // cycle through limb controls with arrow keys
                // Cycle through: CAMERA -> LEFT_ARM -> RIGHT_ARM -> LEFT_LEG -> RIGHT_LEG -> CAMERA
                switch (currentControlMode) {
                    case CAMERA:
                        // Switch to left arm control
                        currentControlMode = LEFT_ARM;
                        activeArm = 0; // Set left arm as active
                        /*strcpy(statusText, "Control Mode: LEFT ARM (Arrow Keys) - Press I to cycle");*/
                        break;
                    case LEFT_ARM:
                        // Switch to right arm control
                        currentControlMode = RIGHT_ARM;
                        activeArm = 1; // Set right arm as active
                        /*strcpy(statusText, "Control Mode: RIGHT ARM (Arrow Keys) - Press I to cycle");*/
                        break;
                    case RIGHT_ARM:
                        // Switch to left leg control
                        currentControlMode = LEFT_LEG;
                        activeLeg = 0; // Set left leg as active
                        /*strcpy(statusText, "Control Mode: LEFT LEG (Arrow Keys) - Press I to cycle");*/
                        break;
                    case LEFT_LEG:
                        // Switch to right leg control
                        currentControlMode = RIGHT_LEG;
                        activeLeg = 1; // Set right leg as active
                        /*strcpy(statusText, "Control Mode: RIGHT LEG (Arrow Keys) - Press I to cycle");*/
                        break;
                    case RIGHT_LEG:
                        // Switch back to camera control
                        currentControlMode = CAMERA;
                        /*strcpy(statusText, "Control Mode: Camera (Arrow Keys)");*/
                        break;
                }
                break;  
                
            case '0': // toggle camera view
                cameraEnabled = !cameraEnabled;
                if (cameraEnabled) {
                    // Camera view enabled
                    // No need to change anything, as the camera view is controlled in the display function
                } else {
                    // Camera view disabled - reset to a fixed position
                    // We'll handle this in the display function
                }
                break;
                
            case VK_SPACE: // reset all elements to default
                // Reset camera position
                cameraAngleX = 0.0f;
                cameraAngleY = 0.0f;
                cameraDistance = 30.0f;
                cameraEnabled = true;
                
                // Reset control mode
                currentControlMode = CAMERA;
                
                // Reset arm rotations
                for (int i = 0; i < 2; i++) {
                    armRotationX[i] = 0.0f;
                    armRotationY[i] = 0.0f;
                    armRotationZ[i] = 0.0f;
                }
                
                // Reset leg rotations
                for (int i = 0; i < 2; i++) {
                    legRotationX[i] = 0.0f;
                    legRotationY[i] = 0.0f;
                    legRotationZ[i] = 0.0f;
                }
                
                // Reset animation states
                g_smashAttacking = false;
                g_smashPhase = 0;
                g_smashAngle = 0.0f;
                
                isHiAnimating = false;
                hiAnimationTime = 0.0f;
                hiArmAngle = 0.0f;
                hiWristAngle = 0.0f;
                hiHandRotation = 0.0f;
                
                isKickAnimating = false;
                kickAnimationTime = 0.0f;
                kickThighAngle = 0.0f;
                kickKneeAngle = 0.0f;
                kickBodyTilt = 0.0f;
                
                isSlapAnimating = false;
                slapAnimationTime = 0.0f;
                slapArmAngle[0] = 0.0f;
                slapArmAngle[1] = 0.0f;
                slapWristAngle[0] = 0.0f;
                slapWristAngle[1] = 0.0f;
                
                isBowingAnimating = false;
                bowAnimationTime = 0.0f;
                bowAngle = 0.0f;
                
                // Reset walking animation
                for (int i = 0; i < 2; i++) {
                    armSwingAngle[i] = 0.0f;
                    legSwingAngle[i] = 0.0f;
                    ankleSwingAngle[i] = 0.0f;
                }
                
                break;

            default:
                break;
            }
        }
        return DefWindowProc(hWnd, msg, wParam, lParam);
    }

    bool initPixelFormat(HDC hdc)
    {
        PIXELFORMATDESCRIPTOR pfd;
        ZeroMemory(&pfd, sizeof(PIXELFORMATDESCRIPTOR));
        pfd.cAlphaBits = 8;
        pfd.cColorBits = 32;
        pfd.cDepthBits = 24;
        pfd.cStencilBits = 0;
        pfd.dwFlags = PFD_DOUBLEBUFFER | PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;
        pfd.iLayerType = PFD_MAIN_PLANE;
        pfd.iPixelType = PFD_TYPE_RGBA;
        pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
        pfd.nVersion = 1;

        int n = ChoosePixelFormat(hdc, &pfd);
        if (SetPixelFormat(hdc, n, &pfd))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    void drawCylinder(float radius, float height, int slices)
    {
        GLUquadricObj* quadric = gluNewQuadric();
        gluQuadricNormals(quadric, GLU_SMOOTH);  // <-- add normals
        gluCylinder(quadric, radius, radius, height, slices, 1);
        gluDeleteQuadric(quadric);
    }

    void drawSphere(float radius, int slices, int stacks)
    {
        GLUquadricObj* quadric = gluNewQuadric();
        gluQuadricNormals(quadric, GLU_SMOOTH);  // <-- add normals
        gluSphere(quadric, radius, slices, stacks);
        gluDeleteQuadric(quadric);
    }


  

    void drawFurPatch(float x, float y, float z, float size, float angleX, float angleY, float angleZ)
    {
        glPushMatrix();
            glTranslatef(x, y, z);
            glRotatef(angleX, 1, 0, 0);
            glRotatef(angleY, 0, 1, 0);
            glRotatef(angleZ, 0, 0, 1);
            glScalef(size, size * 0.3f, size * 2.0f);
            glColor3f(0.4f, 0.3f, 0.2f); // Dark brown fur
            drawSphere(0.05f, 6, 6);
        glPopMatrix();
    }

    //void drawFurOnCylinder(float radius, float height, int furCount)
    //{
    //    for (int i = 0; i < furCount; i++) {
    //        float angle = (float)i / furCount * 6.28f; // 2 * PI
    //        float heightPos = (rand() % 100) / 100.0f * height;
    //        float radiusOffset = radius + (rand() % 20 - 10) / 200.0f;
    //    
    //        float x = cos(angle) * radiusOffset;
    //        float y = sin(angle) * radiusOffset;
    //        float z = heightPos;
    //    
    //        float furAngleX = (rand() % 60 - 30);
    //        float furAngleY = angle * 180.0f / 3.14159f;
    //        float furAngleZ = (rand() % 40 - 20);
    //        float furSize = 0.8f + (rand() % 40) / 100.0f;
    //    
    //        drawFurPatch(x, y, z, furSize, furAngleX, furAngleY, furAngleZ);
    //    }
  
    GLuint myTexture;
    // old drawFurOnCylinder/drawFurOnSphere removed ?replaced by drawFurFromArray
    void drawFurFromArray(const std::vector<FurPatch>& arr)
    {
        glBindTexture(GL_TEXTURE_2D, myTexture);
        glBegin(GL_QUADS);
        for (auto& patch : arr) {
            float s = 0.05f; // small quad size
            glTexCoord2f(0, 0); glVertex3f(patch.x - s, patch.y, patch.z);
            glTexCoord2f(1, 0); glVertex3f(patch.x + s, patch.y, patch.z);
            glTexCoord2f(1, 1); glVertex3f(patch.x + s, patch.y, patch.z + patch.length);
            glTexCoord2f(0, 1); glVertex3f(patch.x - s, patch.y, patch.z + patch.length);
        }
        glEnd();
    }

    void generateFurForCylinder(std::vector<FurPatch>& patches, float radius, float height, int density)
    {

        patches.clear();               // free old patches

        for (int i = 0; i < density; i++) {
            float angle = (rand() % 360) * M_PI / 180.0f;
            float z = ((float)rand() / RAND_MAX) * height;

            // Base position on surface
            float x = cosf(angle) * radius;
            float y = sinf(angle) * radius;

            // Normal points outward
            float nx = cosf(angle);
            float ny = sinf(angle);
            float nz = 0.0f;

            // Push base point slightly outward
            float offset = 0.05f;
            x += nx * offset;
            y += ny * offset;

            // Fur patch
            FurPatch patch;
            patch.x = x;
            patch.y = y;
            patch.z = z;
            patch.nx = nx;
            patch.ny = ny;
            patch.nz = nz;
            patch.length = 0.3f + ((rand() % 100) / 500.0f); // 0.3?.5 length
            patches.push_back(patch);
        }
    }


    void generateFurForSphere(std::vector<FurPatch>& patches, float radius, int density)
    {

        patches.clear();               // free old patches

        for (int i = 0; i < density; i++) {
            float theta = ((float)rand() / RAND_MAX) * M_PI;
            float phi = ((float)rand() / RAND_MAX) * 2 * M_PI;

            // Base point on sphere
            float x = radius * sinf(theta) * cosf(phi);
            float y = radius * sinf(theta) * sinf(phi);
            float z = radius * cosf(theta);

            // Normal = same as position (pointing outward)
            float nx = x, ny = y, nz = z;
            float len = sqrtf(nx * nx + ny * ny + nz * nz);
            nx /= len; ny /= len; nz /= len;

            // Push base outward
            float offset = 0.05f;
            x += nx * offset;
            y += ny * offset;
            z += nz * offset;

            FurPatch patch;
            patch.x = x;
            patch.y = y;
            patch.z = z;
            patch.nx = nx;
            patch.ny = ny;
            patch.nz = nz;
            patch.length = 0.1f + ((rand() % 100) / 500.0f);
            patches.push_back(patch);
        }
    }


    void precomputeAllFur()
    {

        // Example counts ?match the counts you used previously (or tune)
        for (int arm = 0; arm < 2; ++arm) {
            generateFurForCylinder(upperArmFur[arm], 0.6f, 3.0f, 35);
            generateFurForCylinder(forearmFur[arm], 0.5f, 2.5f, 28);
            generateFurForSphere(shoulderFur[arm], 0.8f, 20);
            generateFurForSphere(palmFur[arm], 0.8f, 15);
            // If you have other joints with separate fur density, precompute them similarly
        }
    }


    void drawFinger(int armIndex, float* angles, float baseWidth, float length1, float length2, float length3)
    {
        // Base angles from the current finger position
        float baseAngles[3] = {angles[0], angles[1], angles[2]};
        
        // For the left hand when gripping the weapon, apply finger curling animation
        if (armIndex == 0 && g_showWeapon) {
            // Different grip angles for each joint - these values create a natural grip pose
            // For left hand, use negative values because of the mirrored coordinate system
            // Increased curl for middle/tip joints (PIP/DIP) while keeping base joint (MCP) moderate
            float gripAngles[3] = {-45.0f, -70.0f, -60.0f};
            
            // Interpolate between open and grip pose based on animation progress
            baseAngles[0] += gripAngles[0] * g_weaponGripAnimation;
            baseAngles[1] += gripAngles[1] * g_weaponGripAnimation;
            baseAngles[2] += gripAngles[2] * g_weaponGripAnimation;
        }

        drawFurFromArray(palmFur[armIndex]);

        // First joint (base)
        glPushMatrix();
            glRotatef(baseAngles[0], 1, 0, 0);
            glColor3f(0.8f, 0.6f, 0.4f); // Monkey skin color
            drawCylinder(baseWidth, length1, 12);
            //drawFurOnCylinder(baseWidth, length1, 8); // Add fur
            drawFurFromArray(palmFur[0]);
            // Joint sphere
            glTranslatef(0, 0, length1);
            glColor3f(0.7f, 0.5f, 0.3f);
            drawSphere(baseWidth * 1.1f, 8, 8);
            //drawFurOnSphere(baseWidth * 1.1f, 4);
        
            // Second joint
            glPushMatrix();
                glRotatef(baseAngles[1], 1, 0, 0);
                glColor3f(0.8f, 0.6f, 0.4f);
                drawCylinder(baseWidth * 0.9f, length2, 12);
                //drawFurOnCylinder(baseWidth * 0.9f, length2, 6);
            
                // Joint sphere
                glTranslatef(0, 0, length2);
                glColor3f(0.7f, 0.5f, 0.3f);
                drawSphere(baseWidth * 0.9f, 8, 8);
                //drawFurOnSphere(baseWidth * 0.9f, 3);
            
                // Third joint (fingertip)
                glPushMatrix();
                    glRotatef(baseAngles[2], 1, 0, 0);
                    glColor3f(0.8f, 0.6f, 0.4f);
                    drawCylinder(baseWidth * 0.8f, length3, 12);
                    //drawFurOnCylinder(baseWidth * 0.8f, length3, 4);
                
                    // Fingertip
                    glTranslatef(0, 0, length3);
                    glColor3f(0.75f, 0.55f, 0.35f);
                    drawSphere(baseWidth * 0.8f, 8, 8);
                    //drawFurOnSphere(baseWidth * 0.8f, 3);
                glPopMatrix();
            glPopMatrix();
        glPopMatrix();
    }
    void drawHand(int armIndex)
    {
        // Apply stable hi animation hand rotation to show palm facing front
        if (armIndex == 1 && isHiAnimating) {
            glRotatef(hiHandRotation, 0, 0, 1);  // Z-axis rotation to show palm front (90° max)
            glRotatef(-15.0f, 1, 0, 0);          // Gentle X-axis tilt for clear palm visibility
            glRotatef(0.0f, 0, 1, 0);            // No Y-axis rotation - keep palm stable facing front
        }
        
        // Palm
        glPushMatrix();
        glColor3f(0.8f, 0.6f, 0.4f); // Monkey skin color
        glScalef(1.5f, 0.8f, 2.5f);
        drawSphere(0.8f, 16, 16);
        drawFurFromArray(palmFur[armIndex]);
        glPopMatrix();
        
        // If this is the left hand and weapon is shown, draw the Ruyi Jingu Bang in the hand
        // If this is the left hand and weapon is shown, draw the Ruyi Jingu Bang in the hand
        if (armIndex == 0 && g_showWeapon) {
            glPushMatrix();
            // Position the weapon in the hand with proper offset to prevent clipping
            glTranslatef(-5.0f, 1.0f, 1.65f);  // Raised in Y and moved forward in Z to avoid clipping
            // Rotate the staff to position it correctly in the hand
            glRotatef(90, 0.0f, 1.0f, 0.0f);  // Point forward
            glRotatef(20, 0.0f, 0.0f, 1.0f);  // Angle slightly upward (reduced angle)
            // Draw the staff with fire texture if enabled, otherwise normal
            if (g_weaponFireTexture && g_fireTexture != 0) {
                DrawRuyiJinguBangWithCustomTextures(12.0f, 0.3f);
            }
            else {
                DrawRuyiJinguBang(12.0f, 0.3f);
            }
            glPopMatrix();
        }

        // Thumb
        glPushMatrix();
        if (armIndex == 0 && g_showWeapon) {
            // Special position for left thumb when gripping weapon
            glTranslatef(-1.0f, 0.0f, 0.5f);  // Move closer to the palm base
            glRotatef(-70, 0, 1, 0);          // More rotation around Y to wrap around
            glRotatef(30, 0, 0, 1);           // Adjusted Z rotation for better grip
            glRotatef(-20, 1, 0, 0);          // Add X rotation to curl inward
        } else {
            // Default thumb position
            glTranslatef(-1.0f, 0.3f, 0.3f);  // Moved closer to palm base
            glRotatef(-30, 0, 1, 0);
            glRotatef(45, 0, 0, 1);
        }
        drawFinger(armIndex, thumbAngles[armIndex], 0.25f, 0.8f, 0.6f, 0.5f);
        glPopMatrix();

        // Index finger - with subtle hi animation spreading
        glPushMatrix();
        if (armIndex == 1 && isHiAnimating) {
            glTranslatef(-0.7f, 0.0f, 1.8f);  // Reduced spreading for subtle waving gesture, moved closer to palm
        } else {
            glTranslatef(-0.6f, 0.0f, 1.8f);  // Moved closer to palm surface
        }
        drawFinger(armIndex, indexAngles[armIndex], 0.2f, 1.0f, 0.8f, 0.6f);
        glPopMatrix();

        // Middle finger
        glPushMatrix();
        glTranslatef(-0.2f, 0.0f, 1.8f);  // Moved closer to palm surface
        drawFinger(armIndex, middleAngles[armIndex], 0.22f, 1.1f, 0.9f, 0.7f);
        glPopMatrix();

        // Ring finger
        glPushMatrix();
        glTranslatef(0.2f, 0.0f, 1.8f);  // Moved closer to palm surface
        drawFinger(armIndex, ringAngles[armIndex], 0.2f, 1.0f, 0.8f, 0.6f);
        glPopMatrix();

        // Pinky finger - with subtle hi animation spreading
        glPushMatrix();
        if (armIndex == 1 && isHiAnimating) {
            glTranslatef(0.7f, 0.0f, 1.6f);  // Reduced spreading for subtle waving gesture, moved closer to palm
        } else {
            glTranslatef(0.6f, 0.0f, 1.6f);  // Moved closer to palm surface
        }
        drawFinger(armIndex, pinkyAngles[armIndex], 0.18f, 0.8f, 0.6f, 0.5f);
        glPopMatrix();
    }

    void drawArm(int armIndex)
    {
        // Always set the base arm color first to ensure consistency
        if ((currentControlMode == LEFT_ARM && armIndex == 0) || 
            (currentControlMode == RIGHT_ARM && armIndex == 1)) {
            glColor3f(1.0f, 0.8f, 0.2f); // Bright golden highlight for actively controlled arm
        } else if (armIndex == activeArm) {
            glColor3f(0.9f, 0.7f, 0.3f); // Golden highlight for active Wukong arm
        } else {
            glColor3f(0.7f, 0.5f, 0.3f); // Monkey skin color
        }
        
        drawSphere(0.8f, 16, 16);
        drawFurFromArray(shoulderFur[armIndex]);

        // --- Apply manual control, walking swing, smash attack, hi animation, bow animation, or slapping animation
        if ((currentControlMode == LEFT_ARM && armIndex == 0) || 
            (currentControlMode == RIGHT_ARM && armIndex == 1)) {
            // Apply manual rotations for the controlled arm
            glRotatef(armRotationX[armIndex], 1, 0, 0); // X rotation
            glRotatef(armRotationY[armIndex], 0, 1, 0); // Y rotation
            glRotatef(armRotationZ[armIndex], 0, 0, 1); // Z rotation
        } else if (armIndex == 0 && g_smashAttacking && g_showWeapon) {
            // Apply overhead smash animation for left arm if weapon is equipped
            // Add slight offset to prevent model overlapping
            glTranslatef(0.0f, 0.0f, 0.3f);  // Move the arm slightly outward
            glRotatef(g_smashAngle, 1, 0, 0);  // rotate around X-axis
        } else if (armIndex == 1 && isHiAnimating) {
            // Apply hi animation for right arm only
            glRotatef(hiArmAngle, 0, 0, 1);  // Raise arm up (rotate around Z-axis)
        } else if (isBowingAnimating) {
            // Apply bow animation for both arms
            glRotatef(bowArmAngle[armIndex], 1, 0, 0);  // Both arms move forward during bow
        } else if (isSlapAnimating) {
            // Apply slapping animation for both arms
            // Both arms rotate in the same direction (both use same rotation)
            glRotatef(slapArmAngle[armIndex], 1, 0, 0);  // Both arms rotate in same direction
        } else {
            // Normal walking animation
            glRotatef(armSwingAngle[armIndex], 1, 0, 0);  // rotate around X-axis
        }


        // Mirror the right arm
        if (armIndex == 1) {
            glScalef(-1.0f, 1.0f, 1.0f);
        }
    
        // Shoulder joint
        glPushMatrix();
            // Reapply color coding for active arm
            if ((currentControlMode == LEFT_ARM && armIndex == 0) || 
                (currentControlMode == RIGHT_ARM && armIndex == 1)) {
                glColor3f(1.0f, 0.8f, 0.2f); // Bright golden highlight for actively controlled arm
            } else if (armIndex == activeArm) {
                glColor3f(0.9f, 0.7f, 0.3f); // Golden highlight for active Wukong arm
            } else {
                glColor3f(0.7f, 0.5f, 0.3f); // Monkey skin color
            }
            drawSphere(0.8f, 16, 16);
          

            //drawFurOnSphere(0.8f, 20); // Dense fur on shoulder

            //if (armIndex == 0) {
            //    glRotatef(90, 0, 0, 1);   // left arm
            //}
            //else {
            //    glRotatef(-90, 0, 0, 1);  // right arm
            //}
            glRotatef(-90, 0, 0, 1);   // left arm

            // Now apply the swing forward/back, smash attack, hi animation, bow animation, or slapping
            if (armIndex == 0 && g_smashAttacking && g_showWeapon) {
                // Apply overhead smash animation for left arm if weapon is equipped
                glTranslatef(0.0f, 0.0f, 0.2f);  // Additional slight outward offset
                glRotatef(g_smashAngle, 1, 0, 0);  // rotate around X-axis
            } else if (armIndex == 1 && isHiAnimating) {
                // Apply hi animation for right arm only
                glRotatef(hiArmAngle, 0, 0, 1);  // Raise arm up (rotate around Z-axis)
            } else if (isBowingAnimating) {
                // Apply bow animation for both arms
                glRotatef(bowArmAngle[armIndex], 1, 0, 0);  // Both arms move forward during bow
            } else if (isSlapAnimating) {
                // Apply slapping animation for both arms
                // Both arms rotate in the same direction (both use same rotation)
                glRotatef(-slapArmAngle[armIndex], 1, 0, 0);  // Both arms rotate in same direction
            } else {
                // Normal walking animation
                glRotatef(armSwingAngle[armIndex], 1, 0, 0);
            }

        
            // Upper arm
            glPushMatrix();
                // Use consistent arm color
                if (armIndex == activeArm) {
                    glColor3f(0.85f, 0.65f, 0.35f); // Golden highlight for active Wukong arm
                } else {
                    glColor3f(0.8f, 0.6f, 0.4f); // Monkey skin
                }
                drawCylinder(0.6f, 3.0f, 16);
                //drawFurOnCylinder(0.6f, 3.0f, 35); // Dense fur on upper arm
            
                // Muscle definition with fur
                glTranslatef(0, 0, 1.5f);
                // Slightly darker shade for muscle definition
                if (armIndex == activeArm) {
                    glColor3f(0.8f, 0.6f, 0.3f);
                } else {
                    glColor3f(0.75f, 0.55f, 0.35f);
                }
                drawSphere(0.7f, 12, 12);
                //drawFurOnSphere(0.7f, 18);
            glPopMatrix();

            // draw upper arm fur
            drawFurFromArray(upperArmFur[armIndex]);
        
            // Move to elbow
            glTranslatef(0, 0, 3.0f);
        
            // Elbow joint
            if (armIndex == activeArm) {
                glColor3f(0.9f, 0.7f, 0.3f); // Golden highlight
            } else {
                glColor3f(0.7f, 0.5f, 0.3f);
            }
            drawSphere(0.7f, 16, 16);
            //drawFurOnSphere(0.7f, 15);
           
            // Forearm rotation
                glRotatef(elbowAngle[armIndex], 1, 0, 0);
        
            // Forearm
            glPushMatrix();
                // Use consistent arm color
                if (armIndex == activeArm) {
                    glColor3f(0.85f, 0.65f, 0.35f); // Golden highlight for active Wukong arm
                } else {
                    glColor3f(0.8f, 0.6f, 0.4f); // Monkey skin
                }
                drawCylinder(0.5f, 2.5f, 16);

                //drawFurOnCylinder(0.5f, 2.5f, 28); // Fur on forearm
            glPopMatrix();
            drawFurFromArray(palmFur[armIndex]);

            // Move to wrist
            glTranslatef(0, 0, 2.5f);
            drawFurFromArray(forearmFur[armIndex]);
            // Wrist joint
            if (armIndex == activeArm) {
                glColor3f(0.9f, 0.7f, 0.3f); // Golden highlight
            } else {
                glColor3f(0.7f, 0.5f, 0.3f);
            }
            drawSphere(0.5f, 12, 12);
            //drawFurOnSphere(0.5f, 10);
        
              // Apply wrist animation - hi animation, bow animation, slapping animation, normal walking, or default
             if (armIndex == 1 && isHiAnimating) {
                 // Apply hi wrist waving animation for right arm
                 glRotatef(hiWristAngle, 0, 1, 0);  // Wave side to side (rotate around Y-axis)
             } else if (isBowingAnimating) {
                 // Apply bow wrist animation for both arms
                 glRotatef(bowWristAngle[armIndex], 1, 0, 0);  // Bend wrists forward during bow
             } else if (isSlapAnimating) {
                 // Apply slapping wrist animation for both arms
                 // Both wrists rotate in the same direction
                 glRotatef(slapWristAngle[armIndex], 1, 0, 0);  // Both wrists rotate in same direction
             } else {
                 // Normal walking animation
                 glRotatef(wristSwingAngle[armIndex], 0, 1, 0);
             }
    
        
            // Hand
            drawHand(armIndex);
        glPopMatrix();
    }

    void handleInput()
    {
        // Camera rotation - only if camera is enabled
        if (cameraEnabled) {
            if (GetAsyncKeyState(VK_UP) & 0x8000) {
                cameraAngleX += 1.0f;
                if (cameraAngleX < -89.0f) cameraAngleX = -89.0f; // limit looking straight down
            }
            if (GetAsyncKeyState(VK_DOWN) & 0x8000) {
                cameraAngleX -= 1.0f;
                if (cameraAngleX > 89.0f) cameraAngleX = 89.0f; // limit looking straight up
            }
            if (GetAsyncKeyState(VK_LEFT) & 0x8000) {
                cameraAngleY += 1.0f;
            }
            if (GetAsyncKeyState(VK_RIGHT) & 0x8000) {
                cameraAngleY -= 1.0f;
            }
        }

        // Camera zoom
        if (GetAsyncKeyState('Z') & 0x8000) {
            cameraDistance -= 0.2f;
            if (cameraDistance < 3.0f) cameraDistance = 3.0f;
        }
        if (GetAsyncKeyState('X') & 0x8000) {
            cameraDistance += 0.2f;
            if (cameraDistance > 40.0f) cameraDistance = 40.0f;
        }
        // Walking toggle (W key) - prevent rapid toggling
        bool wPressed = (GetAsyncKeyState('W') & 0x8000) != 0;
        if (wPressed && !wasWPressed) {
            isWalking = !isWalking;
        }
        wasWPressed = wPressed;
        
        // Directional controls (only work when walking)
        if (isWalking) {
            // Forward/Backward movement
            if (GetAsyncKeyState('W') & 0x8000) {
                // Move forward in the direction the character is facing
                float radians = characterRotation * M_PI / 180.0f;
                characterX += sinf(radians) * walkingSpeed;
                characterZ += cosf(radians) * walkingSpeed;
            }
            if (GetAsyncKeyState('S') & 0x8000) {
                // Move backward in the direction the character is facing
                float radians = characterRotation * M_PI / 180.0f;
                characterX -= sinf(radians) * walkingSpeed;
                characterZ -= cosf(radians) * walkingSpeed;
            }
            
            // Turning left/right
            if (GetAsyncKeyState('A') & 0x8000) {
                characterRotation += turningSpeed;
            }
            if (GetAsyncKeyState('D') & 0x8000) {
                characterRotation -= turningSpeed;
            }
        }
        
        // Jump detection (E key) - can jump anytime
        bool ePressed = (GetAsyncKeyState('E') & 0x8000) != 0;
        if (ePressed && !wasEPressed && !isJumping && characterY <= groundLevel) {
            // Start jump only if not already jumping and on ground
            isJumping = true;
            jumpVelocity = jumpForce;  // Set initial upward velocity
        }
        wasEPressed = ePressed;
        
        // Character duplication (G key) - toggle duplicates
        bool gPressed = (GetAsyncKeyState('G') & 0x8000) != 0;
        if (gPressed && !wasGPressed) {
            // Alternate between left and right duplicates
            if (!isLeftDuplicate) {
                isLeftDuplicate = true;
            } else if (!isRightDuplicate) {
                isRightDuplicate = true;
            } else {
                // If both duplicates exist, remove both
                isLeftDuplicate = false;
                isRightDuplicate = false;
            }
        }
        wasGPressed = gPressed;
        
        // Head rotation controls (T and R keys) - continuous rotation while held
        bool rPressed = (GetAsyncKeyState('R') & 0x8000) != 0;
        if (rPressed) {
            headRotationY += headTurnSpeed;  // Turn head right continuously
            // Limit head rotation to realistic range
            if (headRotationY > maxHeadRotation) headRotationY = maxHeadRotation;
        }
        wasRPressed = rPressed;
        
        bool tPressed = (GetAsyncKeyState('T') & 0x8000) != 0;
        if (tPressed) {
            headRotationY -= headTurnSpeed;  // Turn head left continuously
            // Limit head rotation to realistic range
            if (headRotationY < -maxHeadRotation) headRotationY = -maxHeadRotation;
        }
        wasTPressed = tPressed;
        
        // Vertical head movement controls (U and I keys) - continuous rotation while held
        bool uPressed = (GetAsyncKeyState('U') & 0x8000) != 0;
        if (uPressed) {
            headRotationX += headTurnSpeed;  // Turn head up continuously
            // Limit head rotation to realistic range
            if (headRotationX > maxHeadVerticalRotation) headRotationX = maxHeadVerticalRotation;
        }
        wasUPressed = uPressed;
        
        bool yPressed = (GetAsyncKeyState('Y') & 0x8000) != 0;
        if (yPressed) {
            headRotationX -= headTurnSpeed;  // Turn head down continuously
            // Limit head rotation to realistic range
            if (headRotationX < -maxHeadVerticalRotation) headRotationX = -maxHeadVerticalRotation;
        }
        wasYPressed = yPressed;
        
        // Gradually return head to center position when no keys are pressed
        if (!rPressed && !tPressed) {
            if (headRotationY > 1.0f) {
                headRotationY -= headReturnSpeed;
                if (headRotationY < 0.0f) headRotationY = 0.0f;
            } else if (headRotationY < -1.0f) {
                headRotationY += headReturnSpeed;
                if (headRotationY > 0.0f) headRotationY = 0.0f;
            }
        }
        
        if (!uPressed && !yPressed) {
            if (headRotationX > 1.0f) {
                headRotationX -= headReturnSpeed;
                if (headRotationX < 0.0f) headRotationX = 0.0f;
            } else if (headRotationX < -1.0f) {
                headRotationX += headReturnSpeed;
                if (headRotationX > 0.0f) headRotationX = 0.0f;
            }
        }
        
    }
    // --------------------------------------------------------------------
    void DrawCube()
    {
        glBegin(GL_QUADS);
        // Front
        glNormal3f(0, 0, 1);
        glVertex3f(-1, -1, 1); glVertex3f(1, -1, 1);
        glVertex3f(1, 1, 1); glVertex3f(-1, 1, 1);
        // Back
        glNormal3f(0, 0, -1);
        glVertex3f(1, -1, -1); glVertex3f(-1, -1, -1);
        glVertex3f(-1, 1, -1); glVertex3f(1, 1, -1);
        // Left
        glNormal3f(-1, 0, 0);
        glVertex3f(-1, -1, -1); glVertex3f(-1, -1, 1);
        glVertex3f(-1, 1, 1); glVertex3f(-1, 1, -1);
        // Right
        glNormal3f(1, 0, 0);
        glVertex3f(1, -1, 1); glVertex3f(1, -1, -1);
        glVertex3f(1, 1, -1); glVertex3f(1, 1, 1);
        // Top
        glNormal3f(0, 1, 0);
        glVertex3f(-1, 1, 1); glVertex3f(1, 1, 1);
        glVertex3f(1, 1, -1); glVertex3f(-1, 1, -1);
        // Bottom
        glNormal3f(0, -1, 0);
        glVertex3f(-1, -1, -1); glVertex3f(1, -1, -1);
        glVertex3f(1, -1, 1); glVertex3f(-1, -1, 1);
        glEnd();
    }


    // -------------------------------------------------------------------- UNUSED
    void DisplayScene()
    {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glTranslatef(0.0f, 0.0f, -6.0f);

        // Light positions (set each frame)
        GLfloat light0_pos[] = { 2.0f, 2.0f, 2.0f, 0.0f }; // directional
        glLightfv(GL_LIGHT0, GL_POSITION, light0_pos);
        GLfloat light1_pos[] = { -2.0f, 2.0f, 2.0f, 1.0f }; // positional
        glLightfv(GL_LIGHT1, GL_POSITION, light1_pos);

        // Rotate cube
        g_angle += 0.5f;
        if (g_angle > 360) g_angle -= 360;
        glRotatef(g_angle, 1.0f, 1.0f, 0.0f);

        // Draw cube
        glColor3f(0.0f, 0.5f, 1.0f);
        DrawCube();
    }
    void display()
    {
        handleInput();

        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glMatrixMode(GL_MODELVIEW);


        if (flowerFieldEnabled) {
            renderFlowerFieldBackground();
        }

        glLoadIdentity();

        // Update weapon grip animation
        if (g_weaponAnimating) {
            g_weaponGripAnimation += 0.05f;  // Animation speed
            if (g_weaponGripAnimation >= 1.0f) {
                g_weaponGripAnimation = 1.0f;
                g_weaponAnimating = false;  // Animation complete
            }
        }
        
        // Update overhead smash attack animation
        if (g_smashAttacking) {
            if (g_smashPhase == 1) {  // Raising arm phase
                g_smashAngle -= 5.0f;  // Raise arm upward (negative angle)
                if (g_smashAngle <= -30.0f) {  // Fully raised
                    g_smashAngle = -30.0f;  // Limit to -60 to avoid overlapping
                    g_smashPhase = 2;  // Switch to slam down phase
                }
            }
            else if (g_smashPhase == 2) {  // Slamming down phase
                g_smashAngle += 12.0f;  // Slam down quickly but not too fast (positive angle)
                if (g_smashAngle >= 35.0f) {  // End position (less forward to avoid overlaps)
                    g_smashAngle = 35.0f;
                    g_smashPhase = 3;  // Switch to recovery phase
                }
            }
            else if (g_smashPhase == 3) {  // Recovery phase
                g_smashAngle -= 5.0f;  // Return to neutral position
                if (g_smashAngle <= 0.0f) {  // Back to neutral
                    g_smashAngle = 0.0f;
                    g_smashPhase = 0;  // End animation
                    g_smashAttacking = false;
                }
            }
        }
        
        // Update hi animation
        if (isHiAnimating) {
            // Increment animation time
            hiAnimationTime += 0.02f;  // Adjust speed as needed
            
            // Calculate animation progress (0.0 to 1.0)
            float progress = hiAnimationTime / hiAnimationDuration;
            
            if (progress >= 1.0f) {
                // Animation complete - return to original position
                progress = 1.0f;
                isHiAnimating = false;
                hiAnimationTime = 0.0f;
                hiArmAngle = 0.0f;
                hiWristAngle = 0.0f;
                hiHandRotation = 0.0f;
            } else {
                // Enhanced multi-phase hi gesture: Show palm -> Pause -> Wave
                // Use sine wave that goes from 0 to max and back to 0 over 2 seconds
                float waveProgress = sinf(progress * M_PI);  // Creates a smooth 0->1->0 curve
                
                // Right arm raises up and waves (shoulder rotation)
                hiArmAngle = waveProgress * 120.0f;  // Raise arm up to 120 degrees
                
                // Phase-based palm and wrist animation
                if (progress < 0.3f) {
                    // Phase 1: Show palm (first 30% of animation) - palm faces front, no waving
                    hiHandRotation = 90.0f * (progress / 0.3f);  // Gradually show palm
                    hiWristAngle = 0.0f;  // No waving yet
                } else if (progress < 0.5f) {
                    // Phase 2: Pause (30%-50% of animation) - palm held steady facing front
                    hiHandRotation = 90.0f;  // Palm fully facing front, held steady
                    hiWristAngle = 0.0f;  // Still no waving, just showing palm
                } else {
                    // Phase 3: Wave (50%-100% of animation) - palm waves side to side while facing front
                    hiHandRotation = 90.0f;  // Keep palm facing front (no rotation)
                    
                    // Waving motion only during this phase
                    float wavePhaseProgress = (progress - 0.5f) / 0.5f;  // 0 to 1 for wave phase
                    float waveFrequency = 3.0f;  // Faster waves during wave phase
                    hiWristAngle = sinf(wavePhaseProgress * M_PI * waveFrequency) * 25.0f * wavePhaseProgress;
                }
            }
        }
        
        // Update slapping animation
        if (isSlapAnimating) {
            // Increment animation time
            slapAnimationTime += 0.05f;  // Faster than hi animation for quick slapping motion
            
            // Calculate animation progress (0.0 to 1.0)
            float progress = slapAnimationTime / slapAnimationDuration;
            
            if (progress >= 1.0f) {
                // Animation complete - return to original position
                isSlapAnimating = false;
                slapAnimationTime = 0.0f;
                slapArmAngle[0] = 0.0f;
                slapArmAngle[1] = 0.0f;
                slapWristAngle[0] = 0.0f;
                slapWristAngle[1] = 0.0f;
                slapPhase = 0;
            } else {
                // Multi-phase slapping animation
                if (progress < 0.4f) {
                    // Phase 1: Move arms together (first 40% of animation)
                    slapPhase = 1;
                    float moveProgress = progress / 0.4f;  // 0 to 1 for this phase
                    
                    // Both arms move toward center with smooth ease-in motion
                    float easeIn = moveProgress * moveProgress;  // Quadratic ease-in
                    slapArmAngle[0] = easeIn * maxSlapAngle;     // Left arm angle (positive)
                    slapArmAngle[1] = easeIn * maxSlapAngle;     // Right arm angle (positive, direction handled in rotation)
                    
                    // Slight wrist bend for natural motion
                    slapWristAngle[0] = easeIn * 15.0f;
                    slapWristAngle[1] = easeIn * 15.0f;
                    
                } else if (progress < 0.6f) {
                    // Phase 2: Contact and slight bounce (40%-60% of animation)
                    slapPhase = 2;
                    float contactProgress = (progress - 0.4f) / 0.2f;  // 0 to 1 for this phase
                    
                    // Brief contact with slight overshoot and bounce back
                    float bounce = sinf(contactProgress * M_PI * 2.0f) * 0.1f;  // Small bounce effect
                    slapArmAngle[0] = maxSlapAngle + bounce * maxSlapAngle;
                    slapArmAngle[1] = maxSlapAngle + bounce * maxSlapAngle;
                    
                    // Enhanced wrist motion during contact
                    slapWristAngle[0] = 15.0f + bounce * 10.0f;
                    slapWristAngle[1] = 15.0f + bounce * 10.0f;
                    
                } else {
                    // Phase 3: Return to original position (60%-100% of animation)
                    slapPhase = 3;
                    float returnProgress = (progress - 0.6f) / 0.4f;  // 0 to 1 for this phase
                    
                    // Smooth ease-out return to neutral position
                    float easeOut = 1.0f - (1.0f - returnProgress) * (1.0f - returnProgress);  // Quadratic ease-out
                    slapArmAngle[0] = maxSlapAngle * (1.0f - easeOut);
                    slapArmAngle[1] = maxSlapAngle * (1.0f - easeOut);
                    
                    // Return wrists to neutral
                    slapWristAngle[0] = 15.0f * (1.0f - easeOut);
                    slapWristAngle[1] = 15.0f * (1.0f - easeOut);
                }
            }
        }
        

        
        // Update bow down animation
        if (isBowingAnimating) {
            // Increment animation time
            bowAnimationTime += 0.02f;  // Adjust speed as needed
            
            // Calculate animation progress (0.0 to 1.0)
            float progress = bowAnimationTime / bowAnimationDuration;
            
            if (progress >= 1.0f) {
                // Animation complete - return to original position
                isBowingAnimating = false;
                bowAnimationTime = 0.0f;
                bowAngle = 0.0f;
                bowPhase = 0;
                
                // Reset arm and wrist angles
                bowArmAngle[0] = 0.0f;
                bowArmAngle[1] = 0.0f;
                bowWristAngle[0] = 0.0f;
                bowWristAngle[1] = 0.0f;
            } else {
                // Multi-phase bow animation
                if (progress < bowDownEnd) {
                    // Phase 1: Bowing down (0-40% of animation)
                    bowPhase = 1;
                    float bowDownProgress = progress / bowDownEnd;  // 0 to 1 for this phase
                    
                    // Smooth ease-in for natural bowing motion
                    float easeIn = bowDownProgress * bowDownProgress;  // Quadratic ease-in
                    
                    // Calculate bow angle - up to 45 degrees
                    bowAngle = easeIn * maxBowAngle;
                    
                    // Arms follow the bow motion - only need slight adjustments
                    // since the entire upper body is already rotating
                    for (int i = 0; i < 2; i++) {
                        bowArmAngle[i] = easeIn * 15.0f;  // Reduced arm forward angle (15 instead of 30)
                        bowWristAngle[i] = easeIn * 25.0f;  // Increased wrist bend for natural hand position
                    }
                    
                } else if (progress < bowHoldEnd) {
                    // Phase 2: Hold the bow (40%-60% of animation)
                    bowPhase = 2;
                    
                    // Keep the maximum bow angle during hold phase
                    bowAngle = maxBowAngle;
                    
                    // Keep arms in adjusted position during hold
                    for (int i = 0; i < 2; i++) {
                        bowArmAngle[i] = 15.0f;  // Hold arms in adjusted forward position
                        bowWristAngle[i] = 25.0f;  // Hold wrists in adjusted bent position
                    }
                    
                } else {
                    // Phase 3: Return to upright position (60%-100% of animation)
                    bowPhase = 3;
                    float returnProgress = (progress - bowHoldEnd) / (1.0f - bowHoldEnd);  // 0 to 1 for this phase
                    
                    // Smooth ease-out for natural return motion
                    float easeOut = 1.0f - (1.0f - returnProgress) * (1.0f - returnProgress);  // Quadratic ease-out
                    
                    // Gradually return to upright position
                    bowAngle = maxBowAngle * (1.0f - easeOut);
                    
                    // Arms gradually return to neutral position
                    for (int i = 0; i < 2; i++) {
                        bowArmAngle[i] = 15.0f * (1.0f - easeOut);  // Return arms to neutral from adjusted position
                        bowWristAngle[i] = 25.0f * (1.0f - easeOut);  // Return wrists to neutral from adjusted position
                    }
                }
            }
        }
        
        // Update kick animation
        if (isKickAnimating) {
            // Increment animation time
            kickAnimationTime += 0.02f;  // Adjust speed as needed
            
            // Calculate animation progress (0.0 to 1.0)
            float progress = kickAnimationTime / kickAnimationDuration;
            
            if (progress >= 1.0f) {
                // Animation complete - return to original position
                isKickAnimating = false;
                kickAnimationTime = 0.0f;
                kickThighAngle = 0.0f;
                kickKneeAngle = 0.0f;
                kickBodyTilt = 0.0f;
                kickPhase = 0;
            } else {
                // Multi-phase kick animation
                if (progress < kickChargingEnd) {
                    // Phase 1: Charging phase (0-25% of animation)
                    kickPhase = 1;
                    float chargeProgress = progress / kickChargingEnd;  // 0 to 1 for this phase
                    
                    // Quadratic ease-in for natural charging motion
                    float easeIn = chargeProgress * chargeProgress;
                    
                    // Knee bending for charging (prepare for kick)
                    kickKneeAngle = easeIn * 20.0f;  // Bend knee slightly
                    
                    // Body tilt for balance
                    kickBodyTilt = easeIn * 5.0f;  // Slight forward tilt
                    
                } else if (progress < kickForwardEnd) {
                    // Phase 2: Kick forward phase (25-65% of animation)
                    kickPhase = 2;
                    float forwardProgress = (progress - kickChargingEnd) / (kickForwardEnd - kickChargingEnd);  // 0 to 1 for this phase
                    
                    // Quadratic ease-out for powerful kick
                    float easeOut = 1.0f - (1.0f - forwardProgress) * (1.0f - forwardProgress);
                    
                    // Extend leg forward for kick
                    kickThighAngle = easeOut * maxKickAngle;  // Thigh moves forward
                    
                    // Straighten knee for powerful kick
                    kickKneeAngle = 20.0f - (easeOut * 20.0f);  // Go from bent to straight
                    
                    // Body tilt for momentum
                    kickBodyTilt = 5.0f - (easeOut * 10.0f);  // Forward tilt then backward recovery
                    
                } else {
                    // Phase 3: Return to neutral phase (65-100% of animation)
                    kickPhase = 3;
                    float returnProgress = (progress - kickForwardEnd) / (1.0f - kickForwardEnd);  // 0 to 1 for this phase
                    
                    // Sine ease-out for smooth return
                    float easeOut = sinf(returnProgress * M_PI * 0.5f);
                    
                    // Return thigh to neutral
                    kickThighAngle = maxKickAngle * (1.0f - easeOut);
                    
                    // Return knee to neutral
                    kickKneeAngle = -easeOut * 10.0f;  // Slight overextension for natural motion
                    
                    // Return body tilt to neutral
                    kickBodyTilt = -5.0f * (1.0f - easeOut);
                }
            }
        }
        
        // Jump physics update
        if (isJumping) {
            // Apply gravity to velocity
            jumpVelocity += gravity;
            
            // Update character height
            characterY += jumpVelocity;
            
            // Update jump animation based on jump phase
            if (jumpVelocity > 0.2f) {
                // Ascending phase - arms up, legs bent
                jumpArmAngle = 45.0f;
                jumpLegAngle = 30.0f;
            } else if (jumpVelocity > 0.0f) {
                // Peak of jump - arms slightly up, legs extended
                jumpArmAngle = 20.0f;
                jumpLegAngle = 15.0f;
            } else {
                // Descending phase - arms down, legs extended
                jumpArmAngle = -10.0f;
                jumpLegAngle = -5.0f;
            }
            
            // Check if landed on ground
            if (characterY <= groundLevel) {
                characterY = groundLevel;  // Snap to ground level
                jumpVelocity = 0.0f;       // Stop vertical movement
                jumpArmAngle = 0.0f;       // Reset arm animation
                jumpLegAngle = 0.0f;       // Reset leg animation
                isJumping = false;         // End jump
            }
        }

        // Set up camera
        glTranslatef(0, 0, -cameraDistance);
        
        // Only apply camera rotations if camera is enabled
        if (cameraEnabled) {
            glRotatef(cameraAngleX, 1, 0, 0);
            glRotatef(cameraAngleY, 0, 1, 0);
        } else {
            // Use a fixed view when camera is disabled
            // This gives a front view of the model
            glRotatef(0.0f, 1, 0, 0);
            glRotatef(0.0f, 0, 1, 0);
        }

        // Light positions (set each frame)
        GLfloat light0_pos[] = { 2.0f, 2.0f, 2.0f, 0.0f }; // directional
        glLightfv(GL_LIGHT0, GL_POSITION, light0_pos);
        GLfloat light1_pos[] = { -2.0f, 2.0f, 2.0f, 1.0f }; // positional
        glLightfv(GL_LIGHT1, GL_POSITION, light1_pos);

        // Apply character position and rotation
        glPushMatrix();
        glTranslatef(characterX, characterY, characterZ);  // Move character to position (including jump height)
        glRotatef(characterRotation, 0.0f, 1.0f, 0.0f);  // Rotate character

        if (isWalking && !isJumping && !isSlapAnimating) {
            // Animate arms (only when walking and not jumping and not slapping)
            for (int i = 0; i < 2; i++) {
                armSwingAngle[i] += armSwingDir[i] * 1.0f;  // speed

                if (armSwingAngle[i] > 30.0f) {
                    armSwingAngle[i] = 30.0f;
                    armSwingDir[i] = -1;
                }
                if (armSwingAngle[i] < -30.0f) {
                    armSwingAngle[i] = -30.0f;
                    armSwingDir[i] = 1;
                }
            }
            
            // Animate legs - opposite to arms for realistic walking motion
            for (int i = 0; i < 2; i++) {
                legSwingAngle[i] += legSwingDir[i] * 1.0f;  // same speed as arms
                
                if (legSwingAngle[i] > 15) {
                    legSwingAngle[i] = 15.0f;
                    legSwingDir[i] = -1;
                }
                if (legSwingAngle[i] < -15.0f) {
                    legSwingAngle[i] = -15.0f;
                    legSwingDir[i] = 1;
                }
            }
            
            // Animate wrists - synchronized with arms for natural hand movement
            for (int i = 0; i < 2; i++) {
                wristSwingAngle[i] = armSwingAngle[i] * 0.3f;  // wrists move with arms but smaller angle
            }
            
            // Animate ankles - synchronized with legs for natural foot movement
            for (int i = 0; i < 2; i++) {
                ankleSwingAngle[i] = legSwingAngle[i] * 0.4f;  // ankles move with legs but smaller angle
            }
        }
        
        // Apply jump animation to arms and legs when jumping (but not when slapping)
        if (isJumping && !isSlapAnimating) {
            for (int i = 0; i < 2; i++) {
                // Override walking animation with jump animation
                armSwingAngle[i] = jumpArmAngle;
                legSwingAngle[i] = jumpLegAngle;
                wristSwingAngle[i] = jumpArmAngle * 0.2f;  // Wrists follow arms during jump
                ankleSwingAngle[i] = jumpLegAngle * 0.3f;  // Ankles follow legs during jump
            }
        }

        // Camera setup for viewing the monkey tail and vertical legs
        glTranslatef(0.0f, -0.5f, zoom);  // Adjusted for vertical leg positioning
        glRotatef(rotationX, 1.0f, 0.0f, 0.0f);
        glRotatef(rotationY, 0.0f, 1.0f, 0.0f);

        glScalef(2.5f, 2.5f, 2.5f);  // Adjust size for integration

        glTranslatef(0.0f, -2.0f, 5.75);  // Adjust position for integration

        // Save the current matrix state before applying upper body rotation
        glPushMatrix();
        
        // Apply bow down rotation to the upper body if animation is active
        if (isBowingAnimating) {
            // Apply rotation at the base of the upper body (waist)
            glTranslatef(0.0f, 1.2f, 0.0f);  // Move to pivot point (waist)
            glRotatef(bowAngle, 1.0f, 0.0f, 0.0f);  // Rotate around X-axis (bow forward)
            glTranslatef(0.0f, -1.2f, 0.0f);  // Move back
        }
        
        // Draw the simple head
        drawSimpleHead();

        // Draw the muscular upper torso above the middle body
        drawMuscularUpperTorso();

        // Draw the simple upper body to connect tail and legs
        drawUpperBody();
        
        // Draw arms within the same transformation matrix as the upper body
        // so they follow the bow rotation
        glPushMatrix();
        // Position left arm at the shoulder joint of the upper body
        glTranslatef(-1.0f, 3.25f, 0.3f); // Aligned with shoulder joint
        glScalef(0.4f, 0.4f, 0.4f); // Scale down arm to match body proportions
        drawArm(0); // Left arm
        glPopMatrix();

        glPushMatrix();
        // Position right arm at the shoulder joint of the upper body
        glTranslatef(1.0f, 3.25f, 0.3f);// Aligned with shoulder joint
        glScalef(0.4f, 0.4f, 0.4f); // Scale down arm to match body proportions
        drawArm(1); // Right arm
        glPopMatrix();
        
        // Restore the matrix state after drawing the upper body parts
        glPopMatrix();

        // Draw the simple legs with proper vertical orientation
        drawSimpleLegs();

        // Draw the monkey tail
        drawMonkeyTail();
        
        // Draw the Ruyi Jingu Bang (weapon) only when toggled on with key 9
        // We'll draw the weapon with the left arm instead of separately in world space
        // The drawing happens in the drawArm function
     /*   glDisable(GL_LIGHTING); */
    
        glPopMatrix();  // End character transformation
        
        // Draw left duplicate if enabled
        if (isLeftDuplicate) {
            glPushMatrix();
            glTranslatef(characterX - duplicateOffset, characterY, characterZ);  // Move character to left position
            glRotatef(characterRotation, 0.0f, 1.0f, 0.0f);  // Rotate character
            
            // Camera setup for viewing the monkey tail and vertical legs
            glTranslatef(0.0f, -0.5f, zoom);  // Adjusted for vertical leg positioning
            glRotatef(rotationX, 1.0f, 0.0f, 0.0f);
            glRotatef(rotationY, 0.0f, 1.0f, 0.0f);

            glScalef(2.5f, 2.5f, 2.5f);  // Adjust size for integration

            glTranslatef(-1.0f, -2.0f, -1.0f);  // Adjust position for integration

            // Save the current matrix state before applying upper body rotation
            glPushMatrix();
            
            // Apply bow down rotation to the upper body if animation is active
            if (isBowingAnimating) {
                // Apply rotation at the base of the upper body (waist)
                glTranslatef(0.0f, 1.2f, 0.0f);  // Move to pivot point (waist)
                glRotatef(bowAngle, 1.0f, 0.0f, 0.0f);  // Rotate around X-axis (bow forward)
                glTranslatef(0.0f, -1.2f, 0.0f);  // Move back
            }
            
            // Draw the simple head
            drawSimpleHead();

            // Draw the muscular upper torso above the middle body
            drawMuscularUpperTorso();

            // Draw the simple upper body to connect tail and legs
            drawUpperBody();
            
            // Draw arms within the same transformation matrix as the upper body
            // so they follow the bow rotation
            glPushMatrix();
            // Position left arm at the shoulder joint of the upper body
            glTranslatef(-1.0f, 3.25f, 0.3f); // Aligned with shoulder joint
            glScalef(0.4f, 0.4f, 0.4f); // Scale down arm to match body proportions
            drawArm(0); // Left arm
            glPopMatrix();

            glPushMatrix();
            // Position right arm at the shoulder joint of the upper body
            glTranslatef(1.0f, 3.25f, 0.3f);// Aligned with shoulder joint
            glScalef(0.4f, 0.4f, 0.4f); // Scale down arm to match body proportions
            drawArm(1); // Right arm
            glPopMatrix();
            
            // Restore the matrix state after drawing the upper body parts
            glPopMatrix();

            // Draw the simple legs with proper vertical orientation
            drawSimpleLegs();

            // Draw the monkey tail
            drawMonkeyTail();
            
            glPopMatrix();  // End left duplicate transformation
        }
        
        // Draw right duplicate if enabled
        if (isRightDuplicate) {
            glPushMatrix();
            glTranslatef(characterX + duplicateOffset, characterY, characterZ);  // Move character to right position
            glRotatef(characterRotation, 0.0f, 1.0f, 0.0f);  // Rotate character
            
            // Camera setup for viewing the monkey tail and vertical legs
            glTranslatef(0.0f, -0.5f, zoom);  // Adjusted for vertical leg positioning
            glRotatef(rotationX, 1.0f, 0.0f, 0.0f);
            glRotatef(rotationY, 0.0f, 1.0f, 0.0f);

            glScalef(2.5f, 2.5f, 2.5f);  // Adjust size for integration

            glTranslatef(1.0f, -2.0f, -1.0f);  // Adjust position for integration

            // Save the current matrix state before applying upper body rotation
            glPushMatrix();
            
            // Apply bow down rotation to the upper body if animation is active
            if (isBowingAnimating) {
                // Apply rotation at the base of the upper body (waist)
                glTranslatef(0.0f, 1.2f, 0.0f);  // Move to pivot point (waist)
                glRotatef(bowAngle, 1.0f, 0.0f, 0.0f);  // Rotate around X-axis (bow forward)
                glTranslatef(0.0f, -1.2f, 0.0f);  // Move back
            }
            
            // Draw the simple head
            drawSimpleHead();

            // Draw the muscular upper torso above the middle body
            drawMuscularUpperTorso();

            // Draw the simple upper body to connect tail and legs
            drawUpperBody();
            
            // Draw arms within the same transformation matrix as the upper body
            // so they follow the bow rotation
            glPushMatrix();
            // Position left arm at the shoulder joint of the upper body
            glTranslatef(-1.0f, 3.25f, 0.3f); // Aligned with shoulder joint
            glScalef(0.4f, 0.4f, 0.4f); // Scale down arm to match body proportions
            drawArm(0); // Left arm
            glPopMatrix();

            glPushMatrix();
            // Position right arm at the shoulder joint of the upper body
            glTranslatef(1.0f, 3.25f, 0.3f);// Aligned with shoulder joint
            glScalef(0.4f, 0.4f, 0.4f); // Scale down arm to match body proportions
            drawArm(1); // Right arm
            glPopMatrix();
            
            // Restore the matrix state after drawing the upper body parts
            glPopMatrix();

            // Draw the simple legs with proper vertical orientation
            drawSimpleLegs();

            // Draw the monkey tail
            drawMonkeyTail();
            
            glPopMatrix();  // End right duplicate transformation
        }
        
        // Render status text
        renderStatusText();
        
        glFlush();
        
    }


    int WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR, int nCmdShow)
    {
        WNDCLASSEX wc;
        
       
        ZeroMemory(&wc, sizeof(WNDCLASSEX));
        wc.cbSize = sizeof(WNDCLASSEX);
        wc.hInstance = GetModuleHandle(NULL);
        wc.lpfnWndProc = WindowProcedure;
        wc.lpszClassName = WINDOW_TITLE;
        wc.style = CS_HREDRAW | CS_VREDRAW;
        if (!RegisterClassEx(&wc)) return false;

        HWND hWnd = CreateWindow(WINDOW_TITLE, WINDOW_TITLE, WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, 1024, 768,
            NULL, NULL, wc.hInstance, NULL);

        HDC hdc = GetDC(hWnd);
        initPixelFormat(hdc);
        HGLRC hglrc = wglCreateContext(hdc);
        if (!wglMakeCurrent(hdc, hglrc)) return false;

        // lighting

        InitGL();

        //// OpenGL initialization
        //glEnable(GL_DEPTH_TEST);
        //glEnable(GL_TEXTURE_2D);
        //glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

        //glEnable(GL_COLOR_MATERIAL);
        //glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
        //glEnable(GL_NORMALIZE);
        //glClearColor(0.05f, 0.05f, 0.1f, 1.0f); // Darker background for Wukong
       

        // Initialize random seed for fur generation
        srand(12345); // Fixed seed for consistent fur pattern
        precomputeAllFur();

        ResizeGL(1024,768);

        ShowWindow(hWnd, nCmdShow);

        MSG msg;
        ZeroMemory(&msg, sizeof(msg));
        while (true)
        {
            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (msg.message == WM_QUIT) break;
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            display();
            SwapBuffers(hdc);
            Sleep(16); // ~60 FPS
        }// delete textures before shutting down GL
        // Clean up fire texture before exiting
        if (g_fireTexture != 0) {
            glDeleteTextures(1, &g_fireTexture);
            g_fireTexture = 0;
        }
        

        UnregisterClass(WINDOW_TITLE, wc.hInstance);
        return true;
    }


/// BOTTOm

// Function to draw simple legs like the image
    void drawSimpleLegs() {
        // Use the same authentic monkey fur colors from the tail
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights  
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows
        GLfloat furUnderside[] = { 0.75f, 0.55f, 0.35f, 1.0f };    // Lighter underside
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };        // Pink skin patches

        // Draw left leg - positioned to the left
        glPushMatrix();
        glTranslatef(-0.6f, 0.0f, 0.0f);  // Position left leg
        drawSimpleLeg(true);
        glPopMatrix();

        // Draw right leg - positioned to the right
        glPushMatrix();
        glTranslatef(0.6f, 0.0f, 0.0f);   // Position right leg
        drawSimpleLeg(false);
        glPopMatrix();
    }

    // Function to draw a single realistic human-like leg
    void drawSimpleLeg(bool isLeft) {
        // Enhanced colors with more variation for realistic skin/fur tones
        GLfloat furBase[4];
        GLfloat furLight[4];
        GLfloat furDark[4];
        GLfloat jointColor[4];
        GLfloat muscleHighlight[4];
        GLfloat muscleDefinition[4];
        
        int legIndex = isLeft ? 0 : 1;
        
        // Set colors based on control mode
        if ((currentControlMode == LEFT_LEG && legIndex == 0) || 
            (currentControlMode == RIGHT_LEG && legIndex == 1)) {
            // Bright golden highlight for actively controlled leg
            furBase[0] = 0.55f; furBase[1] = 0.40f; furBase[2] = 0.20f; furBase[3] = 1.0f;
            furLight[0] = 0.75f; furLight[1] = 0.55f; furLight[2] = 0.30f; furLight[3] = 1.0f;
            furDark[0] = 0.40f; furDark[1] = 0.28f; furDark[2] = 0.15f; furDark[3] = 1.0f;
            jointColor[0] = 0.50f; jointColor[1] = 0.35f; jointColor[2] = 0.20f; jointColor[3] = 1.0f;
            muscleHighlight[0] = 0.65f; muscleHighlight[1] = 0.45f; muscleHighlight[2] = 0.25f; muscleHighlight[3] = 1.0f;
            muscleDefinition[0] = 0.45f; muscleDefinition[1] = 0.32f; muscleDefinition[2] = 0.18f; muscleDefinition[3] = 1.0f;
        } else {
            // Standard colors
            furBase[0] = 0.45f; furBase[1] = 0.30f; furBase[2] = 0.18f; furBase[3] = 1.0f;
            furLight[0] = 0.65f; furLight[1] = 0.45f; furLight[2] = 0.28f; furLight[3] = 1.0f;
            furDark[0] = 0.30f; furDark[1] = 0.18f; furDark[2] = 0.10f; furDark[3] = 1.0f;
            jointColor[0] = 0.40f; jointColor[1] = 0.25f; jointColor[2] = 0.15f; jointColor[3] = 1.0f;
            muscleHighlight[0] = 0.55f; muscleHighlight[1] = 0.35f; muscleHighlight[2] = 0.22f; muscleHighlight[3] = 1.0f;
            muscleDefinition[0] = 0.35f; muscleDefinition[1] = 0.22f; muscleDefinition[2] = 0.12f; muscleDefinition[3] = 1.0f;
        }

        glPushMatrix();
        
        // Apply walking swing animation (forward/back rotation)
        // legIndex already defined above
        
        // Apply manual control if this leg is selected
        if ((currentControlMode == LEFT_LEG && legIndex == 0) || 
            (currentControlMode == RIGHT_LEG && legIndex == 1)) {
            // Apply manual rotations for the controlled leg
            glRotatef(legRotationX[legIndex], 1, 0, 0); // X rotation
            glRotatef(legRotationY[legIndex], 0, 1, 0); // Y rotation
            glRotatef(legRotationZ[legIndex], 0, 0, 1); // Z rotation
        }
        // Apply kick animation if active (only for right leg)
        else if (isKickAnimating && !isLeft) {
            // Apply body tilt for balance during kick
            glRotatef(kickBodyTilt, 0, 0, 1);  // Tilt body for balance
            
            // Apply thigh rotation for kick
            glRotatef(kickThighAngle, 1, 0, 0);  // Rotate thigh forward
            
            // Apply knee rotation for kick
            // We'll apply this at the knee joint level
        } else {
            // Normal walking animation
            glRotatef(legSwingAngle[legIndex], 1, 0, 0);  // rotate around X-axis
        }

        // === REALISTIC UPPER LEG (THIGH) === - Human-like muscular structure
        glColor3fv(furBase);

        // Main thigh muscle mass - larger and more defined
        glPushMatrix();
        glTranslatef(0.0f, 0.3f, 0.0f);  // Adjusted Y position for better connection
        glScalef(0.35f, 0.9f, 0.35f);  // Extended height for overlap
        GLUquadric* mainThigh = gluNewQuadric();
        gluQuadricNormals(mainThigh, GLU_SMOOTH);
        gluSphere(mainThigh, 1.0f, 24, 24);  // Higher resolution
        gluDeleteQuadric(mainThigh);
        glPopMatrix();

        // Quadriceps muscle definition (front)
        glColor3fv(muscleHighlight);
        for (int i = 0; i < 3; i++) {
            float angle = (i - 1) * 0.4f;
            glPushMatrix();
            glTranslatef(sinf(angle) * 0.12f, 0.2f, cosf(angle) * 0.08f + 0.25f); // Adjusted Y
            glScalef(0.08f, 0.7f, 0.12f);  // Extended height
            GLUquadric* quad = gluNewQuadric();
            gluQuadricNormals(quad, GLU_SMOOTH);
            gluSphere(quad, 1.0f, 16, 16);
            gluDeleteQuadric(quad);
            glPopMatrix();
        }

        // Hamstring muscles (back)
        glColor3fv(muscleDefinition);
        for (int i = 0; i < 2; i++) {
            float sideOffset = (i == 0) ? -0.08f : 0.08f;
            glPushMatrix();
            glTranslatef(sideOffset, 0.1f, -0.2f);  // Adjusted Y
            glScalef(0.1f, 0.8f, 0.15f);  // Extended height
            GLUquadric* hamstring = gluNewQuadric();
            gluQuadricNormals(hamstring, GLU_SMOOTH);
            gluSphere(hamstring, 1.0f, 16, 16);
            gluDeleteQuadric(hamstring);
            glPopMatrix();
        }

        // Outer thigh muscle (vastus lateralis)
        glColor3fv(furLight);
        glPushMatrix();
        glTranslatef(0.25f, 0.0f, 0.05f);  // Adjusted Y
        glScalef(0.12f, 0.9f, 0.2f);  // Extended height
        GLUquadric* outerThigh = gluNewQuadric();
        gluQuadricNormals(outerThigh, GLU_SMOOTH);
        gluSphere(outerThigh, 1.0f, 16, 16);
        gluDeleteQuadric(outerThigh);
        glPopMatrix();

        // Inner thigh muscle (adductors)
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(-0.2f, -0.1f, 0.1f);  // Adjusted Y
        glScalef(0.15f, 1.0f, 0.18f);  // Extended height
        GLUquadric* innerThigh = gluNewQuadric();
        gluQuadricNormals(innerThigh, GLU_SMOOTH);
        gluSphere(innerThigh, 1.0f, 16, 16);
        gluDeleteQuadric(innerThigh);
        glPopMatrix();

        // === SEAMLESS THIGH-TO-KNEE TRANSITION === - Bridge connecting upper and lower leg
        glColor3fv(jointColor);
        glPushMatrix();
        glTranslatef(0.0f, -0.5f, 0.0f);  // Positioned between thigh and knee
        glScalef(0.28f, 0.4f, 0.28f);  // Large transition area
        GLUquadric* thighKneeConnector = gluNewQuadric();
        gluQuadricNormals(thighKneeConnector, GLU_SMOOTH);
        gluSphere(thighKneeConnector, 1.0f, 20, 20);
        gluDeleteQuadric(thighKneeConnector);
        glPopMatrix();

        // === ENHANCED KNEE JOINT === - More realistic knee structure with overlap
        glPushMatrix();
        glTranslatef(0.0f, -0.8f, 0.0f);  // Moved up for better connection
        glColor3fv(jointColor);

        // Main knee joint - larger for seamless connection
        GLUquadric* knee = gluNewQuadric();
        gluQuadricNormals(knee, GLU_SMOOTH);
        gluSphere(knee, 0.26f, 20, 20);  // Larger for better overlap
        gluDeleteQuadric(knee);

        // Kneecap (patella)
        glColor3fv(furLight);
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.2f);
        glScalef(0.14f, 0.17f, 0.1f);
        GLUquadric* kneecap = gluNewQuadric();
        gluQuadricNormals(kneecap, GLU_SMOOTH);
        gluSphere(kneecap, 1.0f, 16, 16);
        gluDeleteQuadric(kneecap);
        glPopMatrix();
        glPopMatrix();

        // === SEAMLESS KNEE-TO-CALF CONNECTOR === - Eliminates gap between knee and lower leg
        glColor3fv(muscleHighlight);
        glPushMatrix();
        glTranslatef(0.0f, -1.1f, 0.0f);  // Between knee and calf
        glScalef(0.24f, 0.3f, 0.24f);  // Connecting bridge
        GLUquadric* kneeCalfConnector = gluNewQuadric();
        gluQuadricNormals(kneeCalfConnector, GLU_SMOOTH);
        gluSphere(kneeCalfConnector, 1.0f, 18, 18);
        gluDeleteQuadric(kneeCalfConnector);
        glPopMatrix();

        // === REALISTIC LOWER LEG (CALF AND SHIN) === - Human-like structure with seamless connection

        // Main calf muscle (gastrocnemius) - back of leg, extended upward
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -1.3f, -0.05f);  // Moved up for connection
        glScalef(0.25f, 0.9f, 0.3f);  // Extended height for overlap
        GLUquadric* mainCalf = gluNewQuadric();
        gluQuadricNormals(mainCalf, GLU_SMOOTH);
        gluSphere(mainCalf, 1.0f, 20, 20);
        gluDeleteQuadric(mainCalf);
        glPopMatrix();

        // Split gastrocnemius heads (medial and lateral) - extended upward
        glColor3fv(muscleHighlight);
        for (int i = 0; i < 2; i++) {
            float sideOffset = (i == 0) ? -0.08f : 0.08f;
            glPushMatrix();
            glTranslatef(sideOffset, -1.2f, 0.1f);  // Moved up
            glScalef(0.1f, 0.7f, 0.15f);  // Extended height
            GLUquadric* calfHead = gluNewQuadric();
            gluQuadricNormals(calfHead, GLU_SMOOTH);
            gluSphere(calfHead, 1.0f, 16, 16);
            gluDeleteQuadric(calfHead);
            glPopMatrix();
        }

        // Soleus muscle (deeper calf muscle) - extended upward
        glColor3fv(muscleDefinition);
        glPushMatrix();
        glTranslatef(0.0f, -1.5f, -0.1f);  // Moved up
        glScalef(0.18f, 0.6f, 0.2f);  // Extended height
        GLUquadric* soleus = gluNewQuadric();
        gluQuadricNormals(soleus, GLU_SMOOTH);
        gluSphere(soleus, 1.0f, 16, 16);
        gluDeleteQuadric(soleus);
        glPopMatrix();

        // Shin area (tibia) - front of lower leg, extended upward
        glColor3fv(furLight);
        glPushMatrix();
        glTranslatef(0.0f, -1.4f, 0.25f);  // Moved up
        glScalef(0.15f, 0.8f, 0.12f);  // Extended height
        GLUquadric* shin = gluNewQuadric();
        gluQuadricNormals(shin, GLU_SMOOTH);
        gluSphere(shin, 1.0f, 16, 16);
        gluDeleteQuadric(shin);
        glPopMatrix();

        // Fibula (outer lower leg bone area) - extended upward
        glColor3fv(furDark);
        glPushMatrix();
        glTranslatef(0.15f, -1.3f, 0.1f);  // Moved up
        glScalef(0.08f, 0.9f, 0.1f);  // Extended height
        GLUquadric* fibula = gluNewQuadric();
        gluQuadricNormals(fibula, GLU_SMOOTH);
        gluSphere(fibula, 1.0f, 12, 12);
        gluDeleteQuadric(fibula);
        glPopMatrix();

        // === COMPLETE LEG MUSCLE COVERAGE === - Fill any remaining gaps
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -0.9f, 0.0f);  // Mid-leg coverage
        glScalef(0.22f, 0.5f, 0.22f);  // Complete coverage
        GLUquadric* midLegFill = gluNewQuadric();
        gluQuadricNormals(midLegFill, GLU_SMOOTH);
        gluSphere(midLegFill, 1.0f, 16, 16);
        gluDeleteQuadric(midLegFill);
        glPopMatrix();

        // === ENHANCED ANKLE AREA === - More realistic ankle structure
        glPushMatrix();
        glTranslatef(0.0f, -2.1f, 0.0f);  // Moved up for better connection
        glColor3fv(jointColor);

        // Main ankle joint - larger for better connection
        GLUquadric* ankle = gluNewQuadric();
        gluQuadricNormals(ankle, GLU_SMOOTH);
        gluSphere(ankle, 0.20f, 18, 18);  // Larger for overlap
        gluDeleteQuadric(ankle);

        // Ankle bones (malleoli) - inner and outer ankle bones
        glColor3fv(furLight);
        for (int i = 0; i < 2; i++) {
            float sideOffset = (i == 0) ? -0.12f : 0.12f;
            glPushMatrix();
            glTranslatef(sideOffset, 0.0f, 0.0f);
            glScalef(0.06f, 0.08f, 0.06f);
            GLUquadric* malleolus = gluNewQuadric();
            gluQuadricNormals(malleolus, GLU_SMOOTH);
            gluSphere(malleolus, 1.0f, 12, 12);
            gluDeleteQuadric(malleolus);
            glPopMatrix();
        }
        glPopMatrix();

        // === SEAMLESS ANKLE CONNECTOR === - Enhanced bridge for perfect foot connection
        glPushMatrix();
        glTranslatef(0.0f, -2.2f, 0.0f);  // Positioned to overlap with both ankle and foot
        glColor3fv(jointColor);
        GLUquadric* ankleConnector = gluNewQuadric();
        gluQuadricNormals(ankleConnector, GLU_SMOOTH);
        gluCylinder(ankleConnector, 0.19f, 0.17f, 0.3f, 20, 1);  // Larger bridge cylinder

        // Add connector caps for complete sealing
        GLUquadric* connectorTop = gluNewQuadric();
        gluQuadricOrientation(connectorTop, GLU_INSIDE);
        gluDisk(connectorTop, 0.0f, 0.19f, 20, 1);
        gluDeleteQuadric(connectorTop);

        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.3f);
        GLUquadric* connectorBottom = gluNewQuadric();
        gluDisk(connectorBottom, 0.0f, 0.17f, 20, 1);
        gluDeleteQuadric(connectorBottom);
        glPopMatrix();
        gluDeleteQuadric(ankleConnector);
        glPopMatrix();

        // === ACHILLES TENDON === - Realistic tendon connection
        glColor3fv(furDark);
        glPushMatrix();
        glTranslatef(0.0f, -1.9f, -0.15f);  // Moved up for connection
        glScalef(0.06f, 0.5f, 0.08f);  // Extended height
        GLUquadric* achilles = gluNewQuadric();
        gluQuadricNormals(achilles, GLU_SMOOTH);
        gluSphere(achilles, 1.0f, 12, 12);
        gluDeleteQuadric(achilles);
        glPopMatrix();

        // === FOOT OR SHOE === - Positioned to COMPLETELY OVERLAP with ankle connector
        glPushMatrix();
        glTranslatef(0.0f, -2.35f, 0.0f);  // Adjusted for perfect overlap with connector
        
        // Apply ankle rotation for walking animation
        //int legIndex = isLeft ? 0 : 1;
        glRotatef(ankleSwingAngle[legIndex], 1, 0, 0);  // rotate around X-axis
        
        // Draw either the shoe or the bare foot based on the toggle
        if (g_wearingShoes) {
            drawSimpleShoes(isLeft);
        } else {
            drawSimpleFoot(isLeft);
        }
        
        glPopMatrix();

        glPopMatrix();
    }

    // Function to draw a simple foot with five toes - Enhanced with seamless connections
    void drawSimpleFoot(bool isLeft) {
        // Same colors as the tail
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };
        GLfloat jointColor[] = { 0.40f, 0.25f, 0.15f, 1.0f };

        glPushMatrix();

        // === EXTENDED ANKLE OVERLAP === - Large overlap area to eliminate all gaps
        glColor3fv(jointColor);
        glPushMatrix();
        glTranslatef(0.0f, 0.1f, 0.0f);  // Large overlap with ankle connector
        GLUquadric* ankleOverlap = gluNewQuadric();
        gluQuadricNormals(ankleOverlap, GLU_SMOOTH);
        gluSphere(ankleOverlap, 0.15f, 16, 16);  // Larger overlap sphere
        gluDeleteQuadric(ankleOverlap);
        glPopMatrix();

        // === TRANSITION ZONE === - Smooth transition from ankle to foot
        glPushMatrix();
        glColor3fv(jointColor);
        glTranslatef(0.0f, 0.0f, 0.0f);
        glRotatef(-90, 1, 0, 0);  // Vertical orientation
        GLUquadric* transition = gluNewQuadric();
        gluQuadricNormals(transition, GLU_SMOOTH);
        gluCylinder(transition, 0.14f, 0.13f, 0.25f, 16, 1);  // Smooth transition

        // Add transition caps
        GLUquadric* transTop = gluNewQuadric();
        gluQuadricOrientation(transTop, GLU_INSIDE);
        gluDisk(transTop, 0.0f, 0.14f, 16, 1);
        gluDeleteQuadric(transTop);

        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.25f);
        GLUquadric* transBottom = gluNewQuadric();
        gluDisk(transBottom, 0.0f, 0.13f, 16, 1);
        gluDeleteQuadric(transBottom);
        glPopMatrix();
        gluDeleteQuadric(transition);
        glPopMatrix();

        // === MAIN FOOT BODY === - Enhanced shape and connection
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -0.2f, 0.3f);  // Positioned to overlap with transition
        glScalef(1.0f, 0.4f, 2.2f);  // Larger proportions for better coverage
        GLUquadric* footBody = gluNewQuadric();
        gluQuadricNormals(footBody, GLU_SMOOTH);
        gluSphere(footBody, 0.25f, 20, 16);
        gluDeleteQuadric(footBody);
        glPopMatrix();

        // === COMPLETELY SEAMLESS SOLE === - Covers entire bottom with overlaps
        glPushMatrix();
        glColor3fv(skinPink);
        glTranslatef(0.0f, -0.5f, 0.3f);  // Positioned to cover everything
        glRotatef(90, 1, 0, 0);
        glScalef(0.95f, 2.1f, 0.15f);  // Even larger and thicker sole
        GLUquadric* sole = gluNewQuadric();
        gluQuadricNormals(sole, GLU_SMOOTH);

        // Draw main sole disk - much larger
        gluDisk(sole, 0.0f, 0.3f, 24, 1);

        // Add thick sole edge for complete coverage
        gluQuadricOrientation(sole, GLU_OUTSIDE);
        gluCylinder(sole, 0.3f, 0.3f, 1.0f, 24, 1);

        // Add top sole cap for complete sealing
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 1.0f);
        gluDisk(sole, 0.0f, 0.3f, 24, 1);
        glPopMatrix();

        gluDeleteQuadric(sole);
        glPopMatrix();

        // === ENHANCED HEEL === - Better connection to foot body with overlap
        glPushMatrix();
        glColor3fv(furDark);
        glTranslatef(0.0f, -0.15f, -0.1f);  // Overlaps with foot body
        GLUquadric* heel = gluNewQuadric();
        gluQuadricNormals(heel, GLU_SMOOTH);
        gluSphere(heel, 0.25f, 16, 12);  // Larger for better coverage
        gluDeleteQuadric(heel);
        glPopMatrix();

        // === COMPLETE ARCH FILLING === - Fills all gaps between heel and main foot
        glPushMatrix();
        glColor3fv(furBase);
        glTranslatef(0.0f, -0.25f, 0.05f);
        glScalef(0.8f, 0.25f, 0.7f);
        GLUquadric* arch = gluNewQuadric();
        gluQuadricNormals(arch, GLU_SMOOTH);
        gluSphere(arch, 0.25f, 16, 12);
        gluDeleteQuadric(arch);
        glPopMatrix();

        // === SIDE COVERAGE === - Fills any remaining side gaps
        for (int side = -1; side <= 1; side += 2) {
            glPushMatrix();
            glColor3fv(furBase);
            glTranslatef(side * 0.2f, -0.2f, 0.15f);
            glScalef(0.15f, 0.3f, 0.6f);
            GLUquadric* sideFill = gluNewQuadric();
            gluQuadricNormals(sideFill, GLU_SMOOTH);
            gluSphere(sideFill, 0.25f, 12, 10);
            gluDeleteQuadric(sideFill);
            glPopMatrix();
        }

        // === ENHANCED FIVE TOES === - Better proportioned and positioned
        for (int toe = 0; toe < 5; toe++) {
            float toeX = (toe - 2) * 0.13f;  // Better spacing
            float toeLength = 0.18f - abs(toe - 2) * 0.025f;  // More natural variation
            float toeWidth = 0.06f - abs(toe - 2) * 0.008f;   // Better proportions

            glPushMatrix();
            glTranslatef(toeX, -0.15f, 0.85f);  // Better positioned on foot
            drawSimpleToe(toeLength, toeWidth);
            glPopMatrix();
        }

        // === COMPLETE TOP COVERAGE === - Ensures no gaps on top of foot
        glPushMatrix();
        glColor3fv(furBase);
        glTranslatef(0.0f, 0.05f, 0.2f);
        glScalef(0.7f, 0.2f, 1.0f);
        GLUquadric* topCoverage = gluNewQuadric();
        gluQuadricNormals(topCoverage, GLU_SMOOTH);
        gluSphere(topCoverage, 0.2f, 16, 12);
        gluDeleteQuadric(topCoverage);
        glPopMatrix();
    }

    // Function to draw simple shoes
    void drawSimpleShoes(bool isLeft) {
        // Colors for the shoes
        GLfloat shoeBase[] = { 0.2f, 0.1f, 0.05f, 1.0f };      // Dark brown
        GLfloat shoeSole[] = { 0.3f, 0.2f, 0.1f, 1.0f };       // Slightly lighter brown for sole
        GLfloat shoeHighlight[] = { 0.4f, 0.25f, 0.15f, 1.0f }; // Highlights
        GLfloat shoeLaces[] = { 0.8f, 0.8f, 0.8f, 1.0f };      // Off-white laces
        
        glPushMatrix();
        
        // === SHOE ANKLE CONNECTOR === 
        // This ensures the shoe connects properly to the leg
        glColor3fv(shoeBase);
        glPushMatrix();
        glTranslatef(0.0f, 0.1f, 0.0f);
        GLUquadric* ankleConnector = gluNewQuadric();
        gluQuadricNormals(ankleConnector, GLU_SMOOTH);
        gluSphere(ankleConnector, 0.15f, 16, 16);
        gluDeleteQuadric(ankleConnector);
        glPopMatrix();
        
        // === MAIN SHOE BODY ===
        glColor3fv(shoeBase);
        glPushMatrix();
        glTranslatef(0.0f, -0.2f, 0.4f);
        glScalef(1.1f, 0.5f, 2.4f);  // Slightly larger than the foot
        GLUquadric* shoeBody = gluNewQuadric();
        gluQuadricNormals(shoeBody, GLU_SMOOTH);
        gluSphere(shoeBody, 0.3f, 20, 16);
        gluDeleteQuadric(shoeBody);
        glPopMatrix();
        
        // === SHOE SOLE ===
        glPushMatrix();
        glColor3fv(shoeSole);
        glTranslatef(0.0f, -0.55f, 0.3f);
        glRotatef(90, 1, 0, 0);
        glScalef(1.0f, 2.2f, 0.15f);
        GLUquadric* sole = gluNewQuadric();
        gluQuadricNormals(sole, GLU_SMOOTH);
        
        // Draw main sole disk
        gluDisk(sole, 0.0f, 0.35f, 24, 1);
        
        // Add thick sole edge
        gluQuadricOrientation(sole, GLU_OUTSIDE);
        gluCylinder(sole, 0.35f, 0.35f, 1.0f, 24, 1);
        
        // Add top sole cap
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 1.0f);
        gluDisk(sole, 0.0f, 0.35f, 24, 1);
        glPopMatrix();
        
        gluDeleteQuadric(sole);
        glPopMatrix();
        
        // === SHOE TOE CAP ===
        glPushMatrix();
        glColor3fv(shoeBase);
        glTranslatef(0.0f, -0.25f, 0.95f);
        glScalef(1.1f, 0.4f, 0.8f);
        GLUquadric* toeCap = gluNewQuadric();
        gluQuadricNormals(toeCap, GLU_SMOOTH);
        gluSphere(toeCap, 0.3f, 16, 12);
        gluDeleteQuadric(toeCap);
        glPopMatrix();
        
        // === SHOE HEEL ===
        glPushMatrix();
        glColor3fv(shoeSole);
        glTranslatef(0.0f, -0.45f, -0.15f);
        glScalef(1.0f, 0.8f, 0.6f);
        GLUquadric* heel = gluNewQuadric();
        gluQuadricNormals(heel, GLU_SMOOTH);
        gluSphere(heel, 0.25f, 16, 12);
        gluDeleteQuadric(heel);
        glPopMatrix();
        
        // === SHOE TONGUE ===
        glPushMatrix();
        glColor3fv(shoeHighlight);
        glTranslatef(0.0f, -0.05f, 0.6f);
        glScalef(0.8f, 0.15f, 0.6f);
        GLUquadric* tongue = gluNewQuadric();
        gluQuadricNormals(tongue, GLU_SMOOTH);
        gluSphere(tongue, 0.3f, 16, 12);
        gluDeleteQuadric(tongue);
        glPopMatrix();
        
        // === SHOE LACES ===
        glColor3fv(shoeLaces);
        
        // Horizontal laces
        for (int i = 0; i < 3; i++) {
            glPushMatrix();
            glTranslatef(0.0f, -0.1f - i * 0.08f, 0.6f);
            glScalef(0.7f, 0.03f, 0.1f);
            GLUquadric* lace = gluNewQuadric();
            gluQuadricNormals(lace, GLU_SMOOTH);
            gluSphere(lace, 0.3f, 8, 8);
            gluDeleteQuadric(lace);
            glPopMatrix();
        }
        
        // Vertical lace section
        glPushMatrix();
        glTranslatef(0.0f, -0.18f, 0.6f);
        glScalef(0.03f, 0.2f, 0.1f);
        GLUquadric* vertLace = gluNewQuadric();
        gluQuadricNormals(vertLace, GLU_SMOOTH);
        gluSphere(vertLace, 0.3f, 8, 8);
        gluDeleteQuadric(vertLace);
        glPopMatrix();
        
        // === SHOE TRIM ===
        glPushMatrix();
        glColor3fv(shoeHighlight);
        glTranslatef(0.0f, 0.0f, 0.0f);
        glRotatef(90, 1, 0, 0);
        GLUquadric* trim = gluNewQuadric();
        gluQuadricNormals(trim, GLU_SMOOTH);
        gluCylinder(trim, 0.16f, 0.18f, 0.15f, 16, 1);
        gluDeleteQuadric(trim);
        glPopMatrix();
        
        glPopMatrix();
    }

    // Function to draw a simple toe - Enhanced details
    void drawSimpleToe(float length, float width) {
        // Same colors as the tail
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };
        GLfloat furMid[] = { 0.55f, 0.35f, 0.22f, 1.0f };  // Mid-tone color for variety

        glPushMatrix();

        // === ENHANCED TOE BODY === - Better shape and connection
        glColor3fv(furBase);
        glPushMatrix();
        glScalef(width, width * 0.85f, length);
        GLUquadric* toeBody = gluNewQuadric();
        gluQuadricNormals(toeBody, GLU_SMOOTH);
        gluSphere(toeBody, 1.0f, 12, 10);
        gluDeleteQuadric(toeBody);
        glPopMatrix();

        // === TOE JOINT === - Mid-toe articulation
        glPushMatrix();
        glColor3fv(furMid);
        glTranslatef(0.0f, 0.0f, length * 0.6f);
        GLUquadric* toeJoint = gluNewQuadric();
        gluQuadricNormals(toeJoint, GLU_SMOOTH);
        gluSphere(toeJoint, width * 0.8f, 10, 8);
        gluDeleteQuadric(toeJoint);
        glPopMatrix();

        // === ENHANCED TOE TIP/NAIL === - Better positioned and shaped
        glPushMatrix();
        glColor3fv(skinPink);
        glTranslatef(0.0f, width * 0.2f, length * 0.9f);
        GLUquadric* toeTip = gluNewQuadric();
        gluQuadricNormals(toeTip, GLU_SMOOTH);
        gluSphere(toeTip, width * 0.35f, 8, 8);
        gluDeleteQuadric(toeTip);
        glPopMatrix();

        // === TOE KNUCKLE === - Adds realistic detail
        glPushMatrix();
        glColor3fv(furBase);
        glTranslatef(0.0f, width * 0.4f, length * 0.3f);
        GLUquadric* toeKnuckle = gluNewQuadric();
        gluQuadricNormals(toeKnuckle, GLU_SMOOTH);
        gluSphere(toeKnuckle, width * 0.6f, 8, 6);
        gluDeleteQuadric(toeKnuckle);
        glPopMatrix();

        glPopMatrix();
    }

    // Function to draw a simple rectangular upper body that connects tail and legs
    void drawUpperBody() {
        // Use the same authentic monkey fur colors from the tail and legs
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights  
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows
        GLfloat muscleHighlight[] = { 0.55f, 0.35f, 0.22f, 1.0f };  // Muscle definition

        glPushMatrix();

        // Position the upper body to connect with the legs at the top and tail at the back
        glTranslatef(0.0f, 1.2f, 0.0f);  // Positioned above the legs

        // === MAIN TORSO (PROPORTIONAL) === - Better proportioned rectangular shape
        glColor3fv(furBase);
        glPushMatrix();
        glScalef(1.1f, 1.2f, 0.7f);  // REDUCED: More proportional to legs
        GLUquadric* torso = gluNewQuadric();
        gluQuadricNormals(torso, GLU_SMOOTH);
        gluSphere(torso, 0.8f, 20, 16);  // Using sphere but scaled to be rectangular
        gluDeleteQuadric(torso);
        glPopMatrix();

        // === ENHANCED BACK MUSCLES === - Spine and back definition  
        glColor3fv(furDark);
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, -0.45f);  // Slightly reduced back extension
        glScalef(0.9f, 1.0f, 0.25f);  // Proportionally reduced back area
        GLUquadric* back = gluNewQuadric();
        gluQuadricNormals(back, GLU_SMOOTH);
        gluSphere(back, 0.8f, 16, 12);
        gluDeleteQuadric(back);
        glPopMatrix();

        // === TAIL CONNECTION AREA === - Specific area where tail attaches
        glColor3fv(furBase);
        glPushMatrix();
        // Position to match tail base at (0.0f, 1.1f, -0.8f) 
        glTranslatef(0.0f, -0.1f, -0.8f);  // Connect at tail attachment point
        GLUquadric* tailConnection = gluNewQuadric();
        gluQuadricNormals(tailConnection, GLU_SMOOTH);
        gluSphere(tailConnection, 0.25f, 20, 16);  // Connection point for tail
        gluDeleteQuadric(tailConnection);
        glPopMatrix();

        // === LOWER TORSO CONNECTION (PROPORTIONAL) === - Connects to the top of legs
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -0.8f, 0.0f);  // Lower part to connect with legs
        glScalef(1.0f, 0.5f, 0.45f);  // Proportionally reduced lower torso
        GLUquadric* lowerTorso = gluNewQuadric();
        gluQuadricNormals(lowerTorso, GLU_SMOOTH);
        gluSphere(lowerTorso, 0.8f, 16, 12);
        gluDeleteQuadric(lowerTorso);
        glPopMatrix();

        // === LEG CONNECTION POINTS (PROPORTIONAL) === - Seamless connection to legs
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(muscleHighlight);
            glPushMatrix();
            glTranslatef(side * 0.35f, -1.0f, 0.0f);  // Slightly closer hip connections
            GLUquadric* hipConnection = gluNewQuadric();
            gluQuadricNormals(hipConnection, GLU_SMOOTH);
            gluSphere(hipConnection, 0.28f, 16, 12);  // Slightly smaller hip connections
            gluDeleteQuadric(hipConnection);
            glPopMatrix();
        }

        // === NECK AREA (PROPORTIONAL) === - Simple neck connection point for potential head
        glColor3fv(furLight);
        glPushMatrix();
        glTranslatef(0.0f, 0.9f, 0.0f);  // Slightly lower position
        GLUquadric* neck = gluNewQuadric();
        gluQuadricNormals(neck, GLU_SMOOTH);
        gluSphere(neck, 0.18f, 12, 10);  // Slightly smaller neck
        gluDeleteQuadric(neck);
        glPopMatrix();

        // === ENHANCED SPINAL CONNECTION === - Better connection to tail
        glColor3fv(furDark);
        glPushMatrix();
        glTranslatef(0.0f, 0.4f, -0.55f);  // Adjusted spinal area leading to tail
        glScalef(0.12f, 0.7f, 0.35f);  // Proportionally adjusted spine ridge
        GLUquadric* spine = gluNewQuadric();
        gluQuadricNormals(spine, GLU_SMOOTH);
        gluSphere(spine, 0.8f, 12, 10);
        gluDeleteQuadric(spine);
        glPopMatrix();

        // === SIDE MUSCLES (PROPORTIONAL) === - Enhanced side muscle definition
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(muscleHighlight);
            glPushMatrix();
            glTranslatef(side * 0.6f, 0.0f, 0.08f);  // Adjusted side muscle placement
            glScalef(0.22f, 0.85f, 0.35f);  // Proportionally reduced side muscles
            GLUquadric* sideMuscle = gluNewQuadric();
            gluQuadricNormals(sideMuscle, GLU_SMOOTH);
            gluSphere(sideMuscle, 0.8f, 14, 12);
            gluDeleteQuadric(sideMuscle);
            glPopMatrix();
        }

        glPopMatrix();
    }

    // Function to draw a detailed muscular upper torso above the middle body
    void drawMuscularUpperTorso() {
        // Enhanced authentic colors for gym-fit physique with six-pack focus
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights  
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows
        GLfloat muscleHighlight[] = { 0.55f, 0.35f, 0.22f, 1.0f };  // Muscle definition
        GLfloat muscleDefinition[] = { 0.35f, 0.22f, 0.12f, 1.0f }; // Deep muscle definition
        GLfloat jointColor[] = { 0.40f, 0.25f, 0.15f, 1.0f };      // Joint definition
        GLfloat veins[] = { 0.25f, 0.15f, 0.08f, 1.0f };           // Vascular definition
        GLfloat abColor[] = { 0.60f, 0.40f, 0.25f, 1.0f };         // Enhanced ab color

        // Enhanced breathing motion for realistic muscle movement
        float breathingMotion = sinf(animationTime * 0.3f) * 0.08f;
        float musclePump = sinf(animationTime * 0.2f) * 0.05f + 0.95f; // Muscle pump cycle



        glPushMatrix();

        // Position the upper torso above the current middle body
        glTranslatef(0.0f, 2.8f, 0.0f);  // Positioned well above the middle body

        // === MAIN UPPER TORSO === - Athletic proportions without being oversized
        glColor3fv(furBase);
        glPushMatrix();
        glScalef(1.3f * musclePump, 1.9f + breathingMotion, 0.8f);  // REDUCED: More proportional athletic build
        GLUquadric* upperTorso = gluNewQuadric();
        gluQuadricNormals(upperTorso, GLU_SMOOTH);
        gluSphere(upperTorso, 0.8f, 28, 24);  // Ultra-high resolution for detail
        gluDeleteQuadric(upperTorso);
        glPopMatrix();

        // === ENHANCED SIX-PACK ABDOMINAL MUSCLES === - Gym-fit definition
        // Main six-pack structure (3 rows ?2 columns = 6 pack)
        for (int row = 0; row < 3; row++) {
            for (int col = -1; col <= 1; col += 2) {
                glColor3fv(abColor);
                glPushMatrix();
                glTranslatef(col * 0.16f, 0.4f - row * 0.22f, 0.42f);  // Slightly adjusted positioning
                glScalef(0.13f + breathingMotion * 0.15f, 0.13f + breathingMotion * 0.08f, 0.11f);  // Proportionally reduced
                GLUquadric* ab = gluNewQuadric();
                gluQuadricNormals(ab, GLU_SMOOTH);
                gluSphere(ab, 0.9f, 20, 18);
                gluDeleteQuadric(ab);
                glPopMatrix();
            }
        }

        // Enhanced abdominal definition with deeper cuts
        for (int i = 0; i < 3; i++) {
            // Vertical separation (linea alba) - deeper and more prominent
            glColor3fv(veins);
            glPushMatrix();
            glTranslatef(0.0f, 0.35f - i * 0.22f, 0.41f);  // Adjusted positioning
            glScalef(0.025f, 0.18f, 0.07f);  // Proportionally adjusted
            GLUquadric* abSep = gluNewQuadric();
            gluQuadricNormals(abSep, GLU_SMOOTH);
            gluSphere(abSep, 0.9f, 14, 12);
            gluDeleteQuadric(abSep);
            glPopMatrix();

            // Horizontal separations between rows
            if (i < 2) {
                glPushMatrix();
                glTranslatef(0.0f, 0.23f - i * 0.22f, 0.41f);  // Adjusted positioning
                glScalef(0.3f, 0.02f, 0.07f);  // Proportionally adjusted
                GLUquadric* abHorizSep = gluNewQuadric();
                gluQuadricNormals(abHorizSep, GLU_SMOOTH);
                gluSphere(abHorizSep, 0.9f, 14, 12);
                gluDeleteQuadric(abHorizSep);
                glPopMatrix();
            }
        }

        // Additional ab muscle detail for each individual ab
        for (int row = 0; row < 3; row++) {
            for (int col = -1; col <= 1; col += 2) {
                // Individual ab muscle fibers
                glColor3fv(muscleDefinition);
                for (int fiber = 0; fiber < 3; fiber++) {
                    glPushMatrix();
                    glTranslatef(col * (0.14f + fiber * 0.008f), 0.38f - row * 0.22f + fiber * 0.015f, 0.43f);  // Adjusted
                    glScalef(0.035f, 0.035f, 0.018f);  // Proportionally reduced
                    GLUquadric* abFiber = gluNewQuadric();
                    gluQuadricNormals(abFiber, GLU_SMOOTH);
                    gluSphere(abFiber, 0.8f, 12, 10);
                    gluDeleteQuadric(abFiber);
                    glPopMatrix();
                }
            }
        }

        // === OBLIQUE MUSCLES === - Side ab definition
        for (int side = -1; side <= 1; side += 2) {
            for (int i = 0; i < 4; i++) {
                glColor3fv(muscleHighlight);
                glPushMatrix();
                glTranslatef(side * (0.35f + i * 0.04f), 0.25f - i * 0.13f, 0.35f);  // Proportionally adjusted
                glScalef(0.07f, 0.08f, 0.07f);  // Proportionally reduced
                GLUquadric* oblique = gluNewQuadric();
                gluQuadricNormals(oblique, GLU_SMOOTH);
                gluSphere(oblique, 0.9f, 16, 14);
                gluDeleteQuadric(oblique);
                glPopMatrix();
            }
        }

        // === PROPORTIONAL DELTOID MUSCLES === - Well-developed but not oversized
        for (int side = -1; side <= 1; side += 2) {
            // Main deltoid mass
            glColor3fv(muscleHighlight);
            glPushMatrix();
            glTranslatef(side * 0.85f, 0.5f, 0.0f);  // Slightly closer
            GLUquadric* mainDeltoid = gluNewQuadric();
            gluQuadricNormals(mainDeltoid, GLU_SMOOTH);
            gluSphere(mainDeltoid, 0.42f * musclePump, 24, 20);  // REDUCED: More proportional deltoids
            gluDeleteQuadric(mainDeltoid);
            glPopMatrix();

            // Three deltoid heads with good definition
            for (int i = 0; i < 3; i++) {
                float deltaAngle = (i - 1) * 1.0f; // Front, middle, back deltoid

                // Varying colors and sizes for each deltoid head
                if (i == 0) {
                    glColor3fv(furLight);          // Anterior (front) - largest
                }
                else if (i == 1) {
                    glColor3fv(muscleHighlight);   // Medial (middle) - peaked
                }
                else {
                    glColor3fv(muscleDefinition);  // Posterior (back) - deep
                }

                glPushMatrix();
                glTranslatef(side * 0.72f, 0.42f + i * 0.07f, sinf(deltaAngle) * 0.22f);  // Proportionally adjusted
                glScalef(0.22f + i * 0.04f, 0.3f + i * 0.08f, 0.26f + i * 0.04f);  // Proportionally reduced
                GLUquadric* deltoidPart = gluNewQuadric();
                gluQuadricNormals(deltoidPart, GLU_SMOOTH);
                gluSphere(deltoidPart, 0.9f, 20, 16);
                gluDeleteQuadric(deltoidPart);
                glPopMatrix();
            }

            // Deltoid striations (muscle fibers)
            for (int j = 0; j < 4; j++) {
                glColor3fv(veins);
                glPushMatrix();
                glTranslatef(side * (0.76f + j * 0.018f), 0.35f + j * 0.08f, j * 0.04f);  // Proportionally adjusted
                glScalef(0.07f, 0.17f, 0.08f);  // Proportionally reduced
                GLUquadric* deltoidStriation = gluNewQuadric();
                gluQuadricNormals(deltoidStriation, GLU_SMOOTH);
                gluSphere(deltoidStriation, 0.8f, 16, 12);
                gluDeleteQuadric(deltoidStriation);
                glPopMatrix();
            }
        }

        // === PROPORTIONAL LATISSIMUS DORSI === - V-taper but not extreme
        for (int side = -1; side <= 1; side += 2) {
            // Main lat muscle (creates the V-shape)
            glColor3fv(furDark);
            glPushMatrix();
            glTranslatef(side * 0.6f, -0.08f, -0.3f);  // Proportionally adjusted
            glScalef(0.38f * musclePump, 1.0f, 0.35f);  // REDUCED: More proportional V-taper
            glRotatef(side * 22, 0, 0, 1); // Moderate V-angle
            GLUquadric* mainLat = gluNewQuadric();
            gluQuadricNormals(mainLat, GLU_SMOOTH);
            gluSphere(mainLat, 0.8f, 22, 18);
            gluDeleteQuadric(mainLat);
            glPopMatrix();

            // Lat muscle fibers (creates the wing effect)
            for (int i = 0; i < 3; i++) {
                glColor3fv(i == 0 ? veins : (i == 1 ? muscleDefinition : muscleHighlight));
                glPushMatrix();
                glTranslatef(side * (0.5f + i * 0.1f), -0.17f + i * 0.12f, -0.26f);  // Proportionally adjusted
                glScalef(0.15f + i * 0.04f, 0.42f + i * 0.17f, 0.17f);  // Proportionally reduced
                GLUquadric* latFiber = gluNewQuadric();
                gluQuadricNormals(latFiber, GLU_SMOOTH);
                gluSphere(latFiber, 0.8f, 18, 14);
                gluDeleteQuadric(latFiber);
                glPopMatrix();
            }

            // Lower lat insertions
            glColor3fv(muscleDefinition);
            glPushMatrix();
            glTranslatef(side * 0.42f, -0.5f, -0.22f);  // Proportionally adjusted
            glScalef(0.22f, 0.26f, 0.13f);  // Proportionally reduced
            GLUquadric* latInsertion = gluNewQuadric();
            gluQuadricNormals(latInsertion, GLU_SMOOTH);
            gluSphere(latInsertion, 0.8f, 16, 12);
            gluDeleteQuadric(latInsertion);
            glPopMatrix();
        }

        // === PROPORTIONAL TRAPEZIUS MUSCLES === - Well-developed traps
        glColor3fv(muscleHighlight);
        glPushMatrix();
        glTranslatef(0.0f, 0.75f, -0.26f);  // Proportionally adjusted
        glScalef(1.0f * musclePump, 0.5f + breathingMotion, 0.35f);  // REDUCED: More proportional traps
        GLUquadric* mainTrap = gluNewQuadric();
        gluQuadricNormals(mainTrap, GLU_SMOOTH);
        gluSphere(mainTrap, 0.8f, 22, 18);
        gluDeleteQuadric(mainTrap);
        glPopMatrix();

        // Upper trap peaks (controlled size)
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furLight);
            glPushMatrix();
            glTranslatef(side * 0.26f, 0.9f, -0.22f);  // Proportionally adjusted
            glScalef(0.17f, 0.33f + breathingMotion * 0.15f, 0.13f);  // Proportionally reduced
            GLUquadric* trapPeak = gluNewQuadric();
            gluQuadricNormals(trapPeak, GLU_SMOOTH);
            gluSphere(trapPeak, 0.8f, 16, 14);
            gluDeleteQuadric(trapPeak);
            glPopMatrix();

            // Middle trap fibers
            for (int i = 0; i < 3; i++) {
                glColor3fv(i % 2 == 0 ? muscleDefinition : muscleHighlight);
                glPushMatrix();
                glTranslatef(side * (0.22f + i * 0.07f), 0.72f + i * 0.04f, -0.19f);  // Proportionally adjusted
                glScalef(0.07f, 0.13f, 0.07f);  // Proportionally reduced
                GLUquadric* trapFiber = gluNewQuadric();
                gluQuadricNormals(trapFiber, GLU_SMOOTH);
                gluSphere(trapFiber, 0.8f, 14, 12);
                gluDeleteQuadric(trapFiber);
                glPopMatrix();
            }
        }

        // === PROPORTIONAL CONNECTION TO MIDDLE BODY === - Seamless athletic transition
        glColor3fv(furBase);
        glPushMatrix();
        glTranslatef(0.0f, -1.3f, 0.0f);  // Adjusted connection point
        glScalef(1.1f * musclePump, 0.65f, 0.65f);  // REDUCED: Proportional connection area
        GLUquadric* connection = gluNewQuadric();
        gluQuadricNormals(connection, GLU_SMOOTH);
        gluSphere(connection, 0.8f, 20, 18);
        gluDeleteQuadric(connection);
        glPopMatrix();

        // Proportional connection bridge for seamless attachment
        glColor3fv(jointColor);
        glPushMatrix();
        glTranslatef(0.0f, -1.0f, 0.0f);  // Adjusted positioning
        glRotatef(-90, 1, 0, 0); // Vertical orientation
        GLUquadric* bridge = gluNewQuadric();
        gluQuadricNormals(bridge, GLU_SMOOTH);
        gluCylinder(bridge, 0.28f * musclePump, 0.32f, 0.45f, 20, 3);  // REDUCED: Proportional bridge

        // Enhanced bridge caps
        gluQuadricOrientation(bridge, GLU_INSIDE);
        gluDisk(bridge, 0.0f, 0.28f * musclePump, 20, 1);

        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.45f);
        GLUquadric* bridgeBottom = gluNewQuadric();
        gluQuadricOrientation(bridgeBottom, GLU_OUTSIDE);
        gluDisk(bridgeBottom, 0.0f, 0.32f, 20, 1);
        glPopMatrix();
        gluDeleteQuadric(bridge);
        glPopMatrix();

        glPopMatrix();
    }

    // Function to draw the human-like head with fierce features
    void drawSimpleHead() {
        // Use the SAME COLORS AS TAIL for consistency
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base - SAME AS TAIL
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights - SAME AS TAIL
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows - SAME AS TAIL
        GLfloat furTip[] = { 0.25f, 0.15f, 0.08f, 1.0f };          // Very dark tip - SAME AS TAIL
        GLfloat furUnderside[] = { 0.75f, 0.55f, 0.35f, 1.0f };    // Lighter underside - SAME AS TAIL
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };        // Pink skin patches - SAME AS TAIL
        GLfloat muscleRidge[] = { 0.35f, 0.22f, 0.12f, 1.0f };     // Muscle definition - SAME AS TAIL
        GLfloat vertebraeColor[] = { 0.38f, 0.25f, 0.15f, 1.0f };  // Vertebrae bumps - SAME AS TAIL

        // Enhanced eye and mouth colors for visibility
        GLfloat eyeWhite[] = { 0.95f, 0.95f, 0.95f, 1.0f };        // Bright eye whites
        GLfloat eyeBlue[] = { 0.2f, 0.4f, 0.8f, 1.0f };            // Blue iris
        GLfloat eyeBlack[] = { 0.05f, 0.05f, 0.05f, 1.0f };        // Black pupils
        GLfloat mouthRed[] = { 0.8f, 0.3f, 0.2f, 1.0f };           // Bright red mouth interior
        GLfloat lipColor[] = { 0.6f, 0.35f, 0.25f, 1.0f };         // Natural lip color
        GLfloat teethWhite[] = { 0.95f, 0.95f, 0.90f, 1.0f };      // Teeth color

        // Subtle head animation - breathing and slight movement
        float headBob = sinf(animationTime * 0.4f) * 0.03f;
        float headTilt = sinf(animationTime * 0.3f) * 1.5f;
        float eyeBlink = fabs(sinf(animationTime * 0.8f)) > 0.95f ? 0.3f : 0.0f; // Blinking

        glPushMatrix();

        // Position the head above the muscular upper torso
        glTranslatef(0.0f, 4.2f + headBob, 0.2f);
        
        // Apply head rotation (T/R keys) - left/right turning
        glRotatef(headRotationY, 0, 1, 0);  // Rotate around Y-axis for left/right
        
        // Apply head rotation (U/I keys) - up/down movement
        glRotatef(headRotationX, 1, 0, 0);  // Rotate around X-axis for up/down
        
        // Apply automatic head tilt (breathing animation)
        glRotatef(headTilt, 0, 0, 1);

        // === MAIN HEAD SHAPE (MONKEY-HUMAN HYBRID) ===
        glColor3fv(furBase);  // Use tail color for base
        glPushMatrix();
        glScalef(0.9f, 1.1f, 0.85f);  // Human-like oval head proportions
        GLUquadric* mainHead = gluNewQuadric();
        gluQuadricNormals(mainHead, GLU_SMOOTH);
        gluSphere(mainHead, 0.6f, 28, 28);
        gluDeleteQuadric(mainHead);
        glPopMatrix();

        // === HUMAN FACIAL STRUCTURE === - Central face area
        glColor3fv(furLight);  // Use tail light color for central face
        glPushMatrix();
        glTranslatef(0.0f, -0.1f, 0.35f);
        glScalef(0.75f, 0.8f, 0.4f);
        GLUquadric* faceStructure = gluNewQuadric();
        gluQuadricNormals(faceStructure, GLU_SMOOTH);
        gluSphere(faceStructure, 0.6f, 24, 24);
        gluDeleteQuadric(faceStructure);
        glPopMatrix();

        // === ENHANCED HUMAN-LIKE EYES ===
        for (int side = -1; side <= 1; side += 2) {
            // Eye socket - deeper and more defined
            glColor3fv(furDark);  // Use tail dark color
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.18f, 0.42f);
            glScalef(0.18f, 0.12f, 0.08f);
            GLUquadric* eyeSocket = gluNewQuadric();
            gluQuadricNormals(eyeSocket, GLU_SMOOTH);
            gluSphere(eyeSocket, 1.0f, 20, 16);
            gluDeleteQuadric(eyeSocket);
            glPopMatrix();

            // Eye white - larger human-like almond shape
            glColor3fv(eyeWhite);
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.18f, 0.48f);
            glScalef(0.16f, 0.09f - eyeBlink, 0.06f);  // Larger eyes with blinking
            GLUquadric* eyeWhitePart = gluNewQuadric();
            gluQuadricNormals(eyeWhitePart, GLU_SMOOTH);
            gluSphere(eyeWhitePart, 1.0f, 20, 16);
            gluDeleteQuadric(eyeWhitePart);
            glPopMatrix();

            // Iris - blue colored human iris
            glColor3fv(eyeBlue);
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.18f, 0.52f);
            GLUquadric* iris = gluNewQuadric();
            gluQuadricNormals(iris, GLU_SMOOTH);
            gluSphere(iris, 0.07f, 16, 16);  // Slightly larger iris
            gluDeleteQuadric(iris);
            glPopMatrix();

            // Pupil - with subtle tracking movement
            float eyeMove = sinf(animationTime * 0.15f + side) * 0.008f;
            glColor3fv(eyeBlack);
            glPushMatrix();
            glTranslatef(side * 0.22f + eyeMove, 0.18f, 0.54f);
            GLUquadric* pupil = gluNewQuadric();
            gluQuadricNormals(pupil, GLU_SMOOTH);
            gluSphere(pupil, 0.03f, 16, 16);
            gluDeleteQuadric(pupil);
            glPopMatrix();

            // Eye highlights for realism
            glColor3fv(eyeWhite);
            glPushMatrix();
            glTranslatef(side * 0.21f, 0.19f, 0.55f);
            GLUquadric* eyeHighlight = gluNewQuadric();
            gluQuadricNormals(eyeHighlight, GLU_SMOOTH);
            gluSphere(eyeHighlight, 0.015f, 12, 10);
            gluDeleteQuadric(eyeHighlight);
            glPopMatrix();

            // Upper eyelid
            glColor3fv(furBase);  // Use tail base color
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.22f, 0.47f);
            glScalef(0.16f, 0.04f, 0.08f);
            GLUquadric* upperEyelid = gluNewQuadric();
            gluQuadricNormals(upperEyelid, GLU_SMOOTH);
            gluSphere(upperEyelid, 1.0f, 16, 12);
            gluDeleteQuadric(upperEyelid);
            glPopMatrix();

            // Lower eyelid
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.14f, 0.47f);
            glScalef(0.16f, 0.03f, 0.08f);
            GLUquadric* lowerEyelid = gluNewQuadric();
            gluQuadricNormals(lowerEyelid, GLU_SMOOTH);
            gluSphere(lowerEyelid, 1.0f, 16, 12);
            gluDeleteQuadric(lowerEyelid);
            glPopMatrix();
        }

        // === FIERCE EYEBROWS ===
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furTip);  // Use tail tip color for dark eyebrows

            // Main eyebrow ridge - angled for fierce look
            glPushMatrix();
            glTranslatef(side * 0.22f, 0.28f, 0.45f);
            glRotatef(side * -15.0f, 0, 0, 1);  // Angled for fierce expression
            glScalef(0.2f, 0.06f, 0.08f);  // Thicker eyebrows
            GLUquadric* eyebrow = gluNewQuadric();
            gluQuadricNormals(eyebrow, GLU_SMOOTH);
            gluSphere(eyebrow, 1.0f, 16, 12);
            gluDeleteQuadric(eyebrow);
            glPopMatrix();
        }

        // === HUMAN-LIKE NOSE ===
        glColor3fv(furUnderside);  // Use tail underside color for nose
        glPushMatrix();
        glTranslatef(0.0f, 0.05f, 0.52f);

        // Nose bridge
        glPushMatrix();
        glTranslatef(0.0f, 0.1f, -0.02f);
        glScalef(0.06f, 0.15f, 0.08f);
        GLUquadric* noseBridge = gluNewQuadric();
        gluQuadricNormals(noseBridge, GLU_SMOOTH);
        gluSphere(noseBridge, 1.0f, 16, 16);
        gluDeleteQuadric(noseBridge);
        glPopMatrix();

        // Nose tip
        glPushMatrix();
        glScalef(0.08f, 0.06f, 0.1f);
        GLUquadric* noseTip = gluNewQuadric();
        gluQuadricNormals(noseTip, GLU_SMOOTH);
        gluSphere(noseTip, 1.0f, 16, 16);
        gluDeleteQuadric(noseTip);
        glPopMatrix();

        // Nostrils - human-like shape
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furDark);  // Use tail dark color for nostril holes
            glPushMatrix();
            glTranslatef(side * 0.025f, -0.015f, 0.04f);
            glScalef(0.02f, 0.015f, 0.03f);
            GLUquadric* nostril = gluNewQuadric();
            gluQuadricNormals(nostril, GLU_SMOOTH);
            gluSphere(nostril, 1.0f, 12, 10);
            gluDeleteQuadric(nostril);
            glPopMatrix();
        }
        glPopMatrix();

        // === ENHANCED VISIBLE MOUTH - SMALLER ===
        glPushMatrix();
        glTranslatef(0.0f, -0.15f, 0.5f);  // Less forward prominence

        // MOUTH OPENING - SMALLER interior
        glColor3fv(mouthRed);  // Bright red interior for visibility
        glPushMatrix();
        glTranslatef(0.0f, -0.01f, 0.02f);
        glScalef(0.14f, 0.06f, 0.08f);  // Smaller mouth opening
        GLUquadric* mouthInterior = gluNewQuadric();
        gluQuadricNormals(mouthInterior, GLU_SMOOTH);
        gluSphere(mouthInterior, 1.0f, 18, 14);  // Slightly less detailed
        gluDeleteQuadric(mouthInterior);
        glPopMatrix();

        // Upper lip - smaller but defined
        glColor3fv(lipColor);
        glPushMatrix();
        glTranslatef(0.0f, 0.02f, 0.01f);  // Adjusted position
        glScalef(0.16f, 0.03f, 0.05f);  // Smaller dimensions
        GLUquadric* upperLip = gluNewQuadric();
        gluQuadricNormals(upperLip, GLU_SMOOTH);
        gluSphere(upperLip, 1.0f, 18, 14);  // Less detailed
        gluDeleteQuadric(upperLip);
        glPopMatrix();

        // Lower lip - smaller but still defined
        glPushMatrix();
        glTranslatef(0.0f, -0.04f, 0.005f);  // Adjusted for smaller gap
        glScalef(0.18f, 0.04f, 0.04f);  // Smaller dimensions
        GLUquadric* lowerLip = gluNewQuadric();
        gluQuadricNormals(lowerLip, GLU_SMOOTH);
        gluSphere(lowerLip, 1.0f, 18, 14);  // Less detailed
        gluDeleteQuadric(lowerLip);
        glPopMatrix();

        // VISIBLE TEETH - SMALLER AND FEWER
        glColor3fv(teethWhite);
        // Upper row of teeth - fewer teeth
        for (int i = 0; i < 5; i++) {  // Fewer teeth for smaller mouth
            float x = (i - 2.0f) * 0.04f;  // Closer spacing
            glPushMatrix();
            glTranslatef(x, 0.01f, 0.04f);  // Adjusted position
            glScalef(0.02f, 0.03f, 0.025f);  // Smaller teeth
            GLUquadric* tooth = gluNewQuadric();
            gluQuadricNormals(tooth, GLU_SMOOTH);
            gluSphere(tooth, 1.0f, 12, 10);  // Less detailed
            gluDeleteQuadric(tooth);
            glPopMatrix();
        }
        
        // Lower row of teeth - fewer teeth
        for (int i = 0; i < 4; i++) {  // Even fewer teeth on bottom row
            float x = (i - 1.5f) * 0.04f;  // Closer spacing
            glPushMatrix();
            glTranslatef(x, -0.02f, 0.03f);  // Position below upper row
            glScalef(0.019f, 0.025f, 0.02f);  // Smaller than upper
            GLUquadric* tooth = gluNewQuadric();
            gluQuadricNormals(tooth, GLU_SMOOTH);
            gluSphere(tooth, 1.0f, 12, 10);  // Less detailed
            gluDeleteQuadric(tooth);
            glPopMatrix();
        }

        // Lip line separation - smaller
        glColor3fv(furDark);  // Use tail dark color
        glPushMatrix();
        glScalef(0.17f, 0.01f, 0.025f);  // Smaller dimensions
        GLUquadric* lipLine = gluNewQuadric();
        gluQuadricNormals(lipLine, GLU_SMOOTH);
        gluSphere(lipLine, 1.0f, 16, 10);  // Less detailed
        gluDeleteQuadric(lipLine);
        glPopMatrix();

        // Mouth corners - closer together
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furBase);  // Use tail base color
            glPushMatrix();
            glTranslatef(side * 0.15f, -0.005f, 0.01f);  // Closer positioning
            glScalef(0.03f, 0.025f, 0.03f);  // Smaller size
            GLUquadric* mouthCorner = gluNewQuadric();
            gluQuadricNormals(mouthCorner, GLU_SMOOTH);
            gluSphere(mouthCorner, 1.0f, 12, 10);  // Less detailed
            gluDeleteQuadric(mouthCorner);
            glPopMatrix();
        }
        glPopMatrix();

        // === HUMAN-LIKE EARS (ONLY ONE PAIR) ===
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furBase);  // Use tail base color
            glPushMatrix();
            glTranslatef(side * 0.52f, 0.0f, 0.15f);
            glRotatef(side * 25, 0, 0, 1);  // Human-like ear angle

            // Outer ear (helix) - human proportions
            glScalef(0.08f, 0.15f, 0.12f);  // Human-like ear size
            GLUquadric* outerEar = gluNewQuadric();
            gluQuadricNormals(outerEar, GLU_SMOOTH);
            gluSphere(outerEar, 1.0f, 16, 14);
            gluDeleteQuadric(outerEar);

            // Inner ear (concha) - human structure
            glColor3fv(furDark);  // Use tail dark color
            glScalef(0.6f, 0.7f, 0.4f);
            GLUquadric* innerEar = gluNewQuadric();
            gluQuadricNormals(innerEar, GLU_SMOOTH);
            gluSphere(innerEar, 1.0f, 12, 10);
            gluDeleteQuadric(innerEar);

            // Earlobe - human characteristic
            glColor3fv(furLight);  // Use tail light color
            glPushMatrix();
            glTranslatef(0.0f, -0.8f, 0.0f);
            glScalef(0.8f, 0.5f, 0.8f);
            GLUquadric* earlobe = gluNewQuadric();
            gluQuadricNormals(earlobe, GLU_SMOOTH);
            gluSphere(earlobe, 1.0f, 12, 10);
            gluDeleteQuadric(earlobe);
            glPopMatrix();
            glPopMatrix();
        }

        // === STRONG JAWLINE ===
        glColor3fv(furBase);  // Use tail base color
        glPushMatrix();
        glTranslatef(0.0f, -0.25f, 0.25f);
        glScalef(0.4f, 0.15f, 0.25f);
        GLUquadric* jawline = gluNewQuadric();
        gluQuadricNormals(jawline, GLU_SMOOTH);
        gluSphere(jawline, 1.0f, 20, 16);
        gluDeleteQuadric(jawline);
        glPopMatrix();

        // Jaw muscles
        for (int side = -1; side <= 1; side += 2) {
            glColor3fv(furLight);  // Use tail light color
            glPushMatrix();
            glTranslatef(side * 0.28f, -0.2f, 0.28f);
            glScalef(0.08f, 0.12f, 0.1f);
            GLUquadric* jawMuscle = gluNewQuadric();
            gluQuadricNormals(jawMuscle, GLU_SMOOTH);
            gluSphere(jawMuscle, 1.0f, 16, 12);
            gluDeleteQuadric(jawMuscle);
            glPopMatrix();
        }

        // === GOLDEN HEADBAND ===
        // Define gold colors for the headband
        GLfloat goldBase[] = { 0.85f, 0.65f, 0.13f, 1.0f };    // Rich gold base
        GLfloat goldHighlight[] = { 1.0f, 0.84f, 0.0f, 1.0f };  // Bright gold highlight
        GLfloat goldShadow[] = { 0.7f, 0.5f, 0.1f, 1.0f };      // Darker gold shadow
        
        // Main headband ring
        glPushMatrix();
        glTranslatef(0.0f, 0.45f, 0.0f);  // Position higher on the head
        
        // Create the circular gold band
        glColor3fv(goldBase);
        GLUquadric* band = gluNewQuadric();
        gluQuadricNormals(band, GLU_SMOOTH);
        
        // Draw the circular band around the head
        glPushMatrix();
        glRotatef(90.0f, 1.0f, 0.0f, 0.0f);
        gluCylinder(band, 0.58f, 0.58f, 0.08f, 32, 4);  // Slightly larger radius to avoid overlap
        
        // Add caps to the cylinder for a complete look
        gluDisk(band, 0.52f, 0.58f, 32, 4);  // Bottom cap
        glTranslatef(0.0f, 0.0f, 0.08f);
        gluDisk(band, 0.52f, 0.58f, 32, 4);  // Top cap
        glPopMatrix();
        
        // Add enhanced double spiral ornament for the front view
        GLfloat darkGold[] = { 0.6f, 0.45f, 0.08f, 1.0f };      // Darker gold for depth
        GLfloat brightGold[] = { 1.0f, 0.9f, 0.2f, 1.0f };      // Extra bright gold for highlights
        GLfloat rubyRed[] = { 0.8f, 0.1f, 0.1f, 1.0f };         // Ruby gem accent
        
        // Enhanced base plate with decorative border
        glColor3fv(goldBase);
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.56f);  // Front center of headband
        glScalef(0.14f, 0.1f, 0.03f);     // Slightly larger for more presence
        gluSphere(band, 1.0f, 18, 16);     // More detailed sphere
        glPopMatrix();
        
        // Add decorative border around base plate
        glColor3fv(brightGold);
        for (int i = 0; i < 8; i++) {
            float angle = i * 45.0f;
            float radius = 0.11f;
            float x = radius * cosf(angle * 3.14159f / 180.0f);
            float y = radius * 0.75f * sinf(angle * 3.14159f / 180.0f);  // Elliptical border
            
            glPushMatrix();
            glTranslatef(x, y, 0.58f);
            glScalef(0.015f, 0.015f, 0.01f);
            gluSphere(band, 1.0f, 8, 8);
            glPopMatrix();
        }
        
        // Add central ruby gem
        glColor3fv(rubyRed);
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.59f);
        glScalef(0.025f, 0.025f, 0.015f);
        gluSphere(band, 1.0f, 12, 12);
        glPopMatrix();
        
        // Add gem setting
        glColor3fv(brightGold);
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.585f);
        glScalef(0.035f, 0.035f, 0.01f);
        gluSphere(band, 1.0f, 14, 10);
        glPopMatrix();
        
        // Left spiral with smoother curve
        glColor3fv(brightGold);
        glPushMatrix();
        glTranslatef(-0.065f, 0.0f, 0.58f);  // Left side positioning
        
        // Create smoother, more elegant spiral with more segments
        float thickness = 0.025f;
        float height = 0.01f;
        
        // Use more segments for a smoother spiral
        for (int i = 0; i < 6; i++) {
            float angle = i * 45.0f;
            float radius = 0.05f - (i * 0.005f);  // Gradually decreasing radius
            float segmentHeight = i * height;      // Gradually increasing height
            float x = -radius * cosf(angle * 3.14159f / 180.0f);
            float y = radius * sinf(angle * 3.14159f / 180.0f);
            
            glPushMatrix();
            glTranslatef(x, y, segmentHeight);
            
            // Gradually decrease segment size toward the center
            float segmentSize = 0.03f - (i * 0.003f);
            glScalef(segmentSize, segmentSize, thickness);
            
            // Alternate between highlight and base gold for visual interest
            if (i % 2 == 0) {
                glColor3fv(brightGold);
            } else {
                glColor3fv(goldHighlight);
            }
            
            gluSphere(band, 1.0f, 12, 10);
            glPopMatrix();
        }
        glPopMatrix();  // End left spiral
        
        // Right spiral (mirrored with same enhancements)
        glPushMatrix();
        glTranslatef(0.065f, 0.0f, 0.58f);  // Right side positioning
        
        // Use more segments for a smoother spiral
        for (int i = 0; i < 6; i++) {
            float angle = i * 45.0f;
            float radius = 0.05f - (i * 0.005f);  // Gradually decreasing radius
            float segmentHeight = i * height;      // Gradually increasing height
            float x = radius * cosf(angle * 3.14159f / 180.0f);
            float y = radius * sinf(angle * 3.14159f / 180.0f);
            
            glPushMatrix();
            glTranslatef(x, y, segmentHeight);
            
            // Gradually decrease segment size toward the center
            float segmentSize = 0.03f - (i * 0.003f);
            glScalef(segmentSize, segmentSize, thickness);
            
            // Alternate between highlight and base gold for visual interest
            if (i % 2 == 0) {
                glColor3fv(brightGold);
            } else {
                glColor3fv(goldHighlight);
            }
            
            gluSphere(band, 1.0f, 12, 10);
            glPopMatrix();
        }
        glPopMatrix();  // End right spiral
        
        // Add connecting piece between spirals
        glColor3fv(darkGold);
        glPushMatrix();
        glTranslatef(0.0f, -0.01f, 0.59f);
        glScalef(0.04f, 0.02f, 0.015f);
        gluSphere(band, 1.0f, 12, 10);
        glPopMatrix();
        
        gluDeleteQuadric(band);
        glPopMatrix(); // End headband
        
        // === HAIR AND FUR BLEND ===
        glColor3fv(furTip);  // Use tail tip color for hair
        glPushMatrix();
        glTranslatef(0.0f, 0.25f, -0.1f);
        glScalef(0.8f, 0.6f, 0.7f);
        GLUquadric* hair = gluNewQuadric();
        gluQuadricNormals(hair, GLU_SMOOTH);
        gluSphere(hair, 0.65f, 24, 20);
        gluDeleteQuadric(hair);
        glPopMatrix();

        // === SEAMLESS NECK CONNECTION ===
        glColor3fv(furBase);  // Use tail base color
        glPushMatrix();
        glTranslatef(0.0f, -0.5f, 0.0f);
        GLUquadric* neckConnector = gluNewQuadric();
        gluQuadricNormals(neckConnector, GLU_SMOOTH);
        gluCylinder(neckConnector, 0.25f, 0.18f, 0.4f, 24, 3);

        // Add neck caps for seamless connection
        GLUquadric* neckTop = gluNewQuadric();
        gluQuadricOrientation(neckTop, GLU_INSIDE);
        gluDisk(neckTop, 0.0f, 0.25f, 24, 1);
        gluDeleteQuadric(neckTop);

        glPushMatrix();
        glTranslatef(0.0f, 0.0f, 0.4f);
        GLUquadric* neckBottom = gluNewQuadric();
        gluQuadricOrientation(neckBottom, GLU_OUTSIDE);
        gluDisk(neckBottom, 0.0f, 0.18f, 24, 1);
        gluDeleteQuadric(neckBottom);
        glPopMatrix();
        gluDeleteQuadric(neckConnector);
        glPopMatrix();

        // === FACIAL EXPRESSION LINES ===
        glColor3fv(furDark);  // Use tail dark color

        // Frown lines between eyebrows
        for (int i = 0; i < 3; i++) {
            glPushMatrix();
            glTranslatef((i - 1.0f) * 0.03f, 0.25f, 0.47f);
            glRotatef(15.0f * (i - 1), 0, 0, 1);
            glScalef(0.02f, 0.1f, 0.025f);
            GLUquadric* frownLine = gluNewQuadric();
            gluQuadricNormals(frownLine, GLU_SMOOTH);
            gluSphere(frownLine, 1.0f, 12, 10);
            gluDeleteQuadric(frownLine);
            glPopMatrix();
        }

        // Nasolabial folds for character depth
        for (int side = -1; side <= 1; side += 2) {
            glPushMatrix();
            glTranslatef(side * 0.15f, -0.05f, 0.45f);
            glRotatef(side * 25.0f, 0, 0, 1);
            glScalef(0.012f, 0.14f, 0.035f);
            GLUquadric* nasolabial = gluNewQuadric();
            gluQuadricNormals(nasolabial, GLU_SMOOTH);
            gluSphere(nasolabial, 1.0f, 12, 10);
            gluDeleteQuadric(nasolabial);
            glPopMatrix();
        }

        glPopMatrix();
    }

    void drawMonkeyTail() {
        // Authentic monkey fur colors - based on real macaque and baboon patterns
        GLfloat furBase[] = { 0.45f, 0.30f, 0.18f, 1.0f };         // Rich chestnut brown base
        GLfloat furLight[] = { 0.65f, 0.45f, 0.28f, 1.0f };        // Golden brown highlights  
        GLfloat furDark[] = { 0.30f, 0.18f, 0.10f, 1.0f };         // Deep brown shadows
        GLfloat furTip[] = { 0.25f, 0.15f, 0.08f, 1.0f };          // Very dark tip
        GLfloat furUnderside[] = { 0.75f, 0.55f, 0.35f, 1.0f };    // Lighter underside
        GLfloat skinPink[] = { 0.85f, 0.65f, 0.55f, 1.0f };        // Pink skin patches
        GLfloat muscleRidge[] = { 0.35f, 0.22f, 0.12f, 1.0f };     // Muscle definition
        GLfloat vertebraeColor[] = { 0.38f, 0.25f, 0.15f, 1.0f };  // Vertebrae bumps

        // Enhanced monkey tail parameters - uniform thickness with improved movement
        const int tailSegments = 60;  // More segments for ultra-smooth motion
        float tailLength = 7.5f;       // Longer for dramatic movement
        float segmentLength = tailLength / tailSegments;

        // UNIFORM THICKNESS - Same radius throughout the entire tail
        float uniformRadius = 0.15f;  // Consistent thickness from base to tip

        // Enhanced movement patterns with improved functionality
        animationTime += 0.015f;
        float primaryWave = sinf(animationTime * 0.4f) * 0.8f;        // Main movement wave
        float secondaryWave = sinf(animationTime * 0.6f) * 0.4f;      // Secondary wave for complexity
        float spiralMotion = sinf(animationTime * 0.25f) * 1.2f;      // Spiral movement
        float whipMotion = sinf(animationTime * 0.8f) * 0.6f;        // Quick whip-like motion
        float breathingMotion = sinf(animationTime * 0.3f) * 0.05f;   // Subtle breathing

        glPushMatrix();

        // Position at anatomically correct monkey tail base
        glTranslatef(0.0f, 1.1f, -0.8f);
        glRotatef(-12.0f, 1.0f, 0.0f, 0.0f); // Optimized angle for movement display

        // Draw uniform thickness monkey tail with enhanced movement
        for (int i = 0; i < tailSegments; i++) {
            float t = (float)i / (tailSegments - 1);

            // Enhanced biomechanical movement with multi-directional capability
            float gravity = t * t * 0.4f;  // Natural hanging effect
            float flexibility = sinf(t * PI) * 0.8f;  // Maximum flexibility in middle

            // Multi-directional movement calculations
            float verticalMotion = primaryWave * flexibility * sinf(t * PI * 1.5f);
            float horizontalMotion = secondaryWave * flexibility * cosf(t * PI * 1.2f);
            float spiralX = spiralMotion * flexibility * sinf(t * PI * 2.0f + animationTime * 0.5f);
            float spiralZ = spiralMotion * flexibility * cosf(t * PI * 2.0f + animationTime * 0.5f);
            float whipEffect = whipMotion * t * t * sinf(animationTime * 1.5f + t * PI * 3.0f);

            // Combined step calculations for enhanced movement
            float stepY = -gravity * 0.15f + verticalMotion * 0.12f + breathingMotion * (1.0f - t * 0.5f);
            float stepX = horizontalMotion * 0.1f + spiralX * 0.08f + whipEffect * 0.06f;
            float stepZ = -t * 0.08f + spiralZ * 0.08f + whipEffect * 0.04f;

            // Uniform thickness throughout
            float currentRadius = uniformRadius;
            float nextRadius = uniformRadius;  // Always the same for uniform appearance

            // Enhanced fur color patterns with position-based variation
            float dorsalVentral = stepY + 1.0f;
            float colorVariation = (sinf(t * PI * 8.0f + animationTime) + 1.0f) * 0.5f;
            float lightExposure = (dorsalVentral + stepX + 2.0f) / 4.0f;

            // Dynamic coloration based on movement and position
            if (t > 0.85f) {
                glColor3fv(furTip);  // Darker tip for visual distinction
            }
            else if (dorsalVentral < 0.3f) {
                glColor3fv(furUnderside);  // Lighter underside
            }
            else if (lightExposure > 0.7f && colorVariation > 0.6f) {
                glColor3fv(furLight);  // Dynamic light areas
            }
            else if (lightExposure < 0.3f || colorVariation < 0.25f) {
                glColor3fv(furDark);   // Shadow areas
            }
            else {
                glColor3fv(furBase);   // Base color
            }

            glPushMatrix();

            // Apply movement transformations
            glTranslatef(stepX, stepY, stepZ);

            // Enhanced rotational movement for natural tail flexibility
            float rotationZ = primaryWave * t * 15.0f + secondaryWave * t * 8.0f;
            float rotationX = spiralMotion * t * t * 12.0f;
            float rotationY = whipEffect * t * 10.0f;

            glRotatef(rotationZ, 0, 0, 1);
            glRotatef(rotationX, 1, 0, 0);
            glRotatef(rotationY, 0, 1, 0);

            // Calculate orientation for natural flow
            if (i < tailSegments - 1) {
                float nextT = (float)(i + 1) / (tailSegments - 1);
                float nextGravity = nextT * nextT * 0.4f;
                float nextFlexibility = sinf(nextT * PI) * 0.8f;

                float nextVertical = primaryWave * nextFlexibility * sinf(nextT * PI * 1.5f);
                float nextHorizontal = secondaryWave * nextFlexibility * cosf(nextT * PI * 1.2f);
                float nextSpiralX = spiralMotion * nextFlexibility * sinf(nextT * PI * 2.0f + animationTime * 0.5f);
                float nextSpiralZ = spiralMotion * nextFlexibility * cosf(nextT * PI * 2.0f + animationTime * 0.5f);
                float nextWhip = whipMotion * nextT * nextT * sinf(animationTime * 1.5f + nextT * PI * 3.0f);

                float nextStepY = -nextGravity * 0.15f + nextVertical * 0.12f + breathingMotion * (1.0f - nextT * 0.5f);
                float nextStepX = nextHorizontal * 0.1f + nextSpiralX * 0.08f + nextWhip * 0.06f;
                float nextStepZ = -nextT * 0.08f + nextSpiralZ * 0.08f + nextWhip * 0.04f;

                float dirX = nextStepX - stepX;
                float dirY = nextStepY - stepY;
                float dirZ = nextStepZ - stepZ;

                if (dirX != 0 || dirY != 0 || dirZ != 0) {
                    float angleY = atan2f(dirX, dirZ) * 180.0f / PI;
                    float angleX = -atan2f(dirY, sqrtf(dirX * dirX + dirZ * dirZ)) * 180.0f / PI;

                    glRotatef(angleY, 0, 1, 0);
                    glRotatef(angleX, 1, 0, 0);
                }
            }

            // Draw main tail segment with uniform thickness
            GLUquadric* segment = gluNewQuadric();
            gluQuadricOrientation(segment, GLU_OUTSIDE);
            gluQuadricNormals(segment, GLU_SMOOTH);
            gluQuadricTexture(segment, GL_TRUE);
            gluCylinder(segment, currentRadius, nextRadius, segmentLength, 28, 1);  // Higher resolution

            // Perfect end caps for seamless connection
            if (i == 0) {
                GLUquadric* baseCap = gluNewQuadric();
                gluQuadricOrientation(baseCap, GLU_INSIDE);
                gluDisk(baseCap, 0.0f, currentRadius, 28, 1);
                gluDeleteQuadric(baseCap);
            }

            if (i == tailSegments - 1) {
                glPushMatrix();
                glTranslatef(0.0f, 0.0f, segmentLength);
                GLUquadric* endCap = gluNewQuadric();
                gluQuadricOrientation(endCap, GLU_OUTSIDE);
                gluDisk(endCap, 0.0f, nextRadius, 28, 1);
                gluDeleteQuadric(endCap);
                glPopMatrix();
            }

            gluDeleteQuadric(segment);

            // Enhanced fur patterns with movement-responsive density
            if (i % 2 == 0) {
                int furCount = (int)(18 - t * 6);  // Slightly less fur toward tip
                for (int j = 0; j < furCount; j++) {
                    float angle = j * 2.0f * PI / furCount;
                    float furOffset = (sinf(animationTime * 3.0f + j + i) + 1.0f) * 0.02f;  // Dynamic fur movement
                    float furRadius = currentRadius * (1.03f + furOffset);
                    float furX = cosf(angle) * furRadius;
                    float furY = sinf(angle) * furRadius;
                    float furZ = segmentLength * ((j % 5) * 0.2f + 0.1f);

                    // Dynamic fur coloration
                    if (furY < 0) {
                        glColor3fv(furUnderside);
                    }
                    else if (j % 4 == 0) {
                        glColor3fv(furLight);
                    }
                    else if (j % 7 == 0) {
                        glColor3fv(furDark);
                    }

                    glPushMatrix();
                    glTranslatef(furX, furY, furZ);

                    GLUquadric* furTuft = gluNewQuadric();
                    gluQuadricNormals(furTuft, GLU_SMOOTH);
                    float furSize = currentRadius * (0.09f + (j % 4) * 0.02f);
                    gluSphere(furTuft, furSize, 10, 10);
                    gluDeleteQuadric(furTuft);
                    glPopMatrix();
                }
            }

            // Enhanced vertebrae definition
            if (t < 0.8f && i % 3 == 0) {
                glColor3fv(vertebraeColor);
                for (int v = 0; v < 8; v++) {
                    float vertAngle = v * PI / 4.0f;
                    float vertX = cosf(vertAngle) * currentRadius * 1.02f;
                    float vertY = sinf(vertAngle) * currentRadius * 1.02f;

                    glPushMatrix();
                    glTranslatef(vertX, vertY, segmentLength * 0.5f);
                    GLUquadric* vertebra = gluNewQuadric();
                    gluSphere(vertebra, currentRadius * 0.05f, 10, 10);
                    gluDeleteQuadric(vertebra);
                    glPopMatrix();
                }
            }

            // Enhanced muscle definition
            if (t < 0.6f && i % 4 == 0) {
                glColor3fv(muscleRidge);
                for (int m = 0; m < 10; m++) {
                    float muscleAngle = m * PI / 5.0f;
                    float muscleX = cosf(muscleAngle) * currentRadius * 0.99f;
                    float muscleY = sinf(muscleAngle) * currentRadius * 0.99f;

                    glPushMatrix();
                    glTranslatef(muscleX, muscleY, segmentLength * 0.35f);
                    GLUquadric* muscle = gluNewQuadric();
                    gluSphere(muscle, currentRadius * 0.05f, 10, 10);
                    gluDeleteQuadric(muscle);
                    glPopMatrix();
                }
            }

            // Skin patches near tip
            if (t > 0.75f && i % 8 == 0) {
                glColor3fv(skinPink);
                for (int s = 0; s < 4; s++) {
                    float skinAngle = s * PI / 2.0f;
                    float skinX = cosf(skinAngle) * currentRadius * 0.88f;
                    float skinY = sinf(skinAngle) * currentRadius * 0.88f;

                    glPushMatrix();
                    glTranslatef(skinX, skinY, segmentLength * 0.6f);
                    GLUquadric* skinPatch = gluNewQuadric();
                    gluSphere(skinPatch, currentRadius * 0.025f, 10, 10);
                    gluDeleteQuadric(skinPatch);
                    glPopMatrix();
                }
            }

            glPopMatrix();

            // Move to next position for perfect continuity
            glTranslatef(stepX, stepY, stepZ);
        }

        // Enhanced tail tip with uniform thickness
        glPushMatrix();
        glTranslatef(0.0f, 0.0f, segmentLength);

        // Larger tip pad maintaining uniform thickness
        glColor3fv(skinPink);
        GLUquadric* tipCore = gluNewQuadric();
        gluSphere(tipCore, uniformRadius * 0.8f, 24, 24);  // Proportional to uniform thickness
        gluDeleteQuadric(tipCore);

        // Enhanced ridges for better grip
        for (int r = 0; r < 10; r++) {
            float ridgeAngle = r * PI / 5.0f;
            float ridgeX = cosf(ridgeAngle) * uniformRadius * 0.6f;
            float ridgeY = sinf(ridgeAngle) * uniformRadius * 0.6f;

            glColor3fv(furTip);
            glPushMatrix();
            glTranslatef(ridgeX, ridgeY, uniformRadius * 0.3f);
            GLUquadric* ridge = gluNewQuadric();
            gluSphere(ridge, uniformRadius * 0.04f, 10, 10);
            gluDeleteQuadric(ridge);
            glPopMatrix();
        }

        // Enhanced fur tuft with dynamic movement
        for (int i = 0; i < 20; i++) {
            float angle = i * 2.0f * PI / 20.0f;
            float tufRadius = uniformRadius * (0.9f + (i % 6) * 0.1f);
            float dynamicMotion = sinf(animationTime * 2.0f + i) * 0.4f;
            float tufX = cosf(angle) * tufRadius * (0.9f + dynamicMotion);
            float tufY = sinf(angle) * tufRadius * (0.9f + cosf(animationTime * 2.0f + i) * 0.4f);
            float tufZ = (i % 6) * uniformRadius * 0.15f - uniformRadius * 0.1f;

            // Enhanced color variation
            if (i % 6 == 0) {
                glColor3fv(furTip);
            }
            else if (i % 6 == 1) {
                glColor3fv(furDark);
            }
            else if (i % 6 == 2) {
                glColor3fv(furBase);
            }
            else if (i % 6 == 3) {
                glColor3fv(furLight);
            }
            else if (i % 6 == 4) {
                glColor3fv(furUnderside);
            }
            else {
                glColor3fv(muscleRidge);
            }

            glPushMatrix();
            glTranslatef(tufX, tufY, tufZ);
            glRotatef((i % 8) * 12.0f + animationTime * 10.0f, 1, 1, 0);  // Dynamic curl

            GLUquadric* hairStrand = gluNewQuadric();
            gluQuadricNormals(hairStrand, GLU_SMOOTH);
            float strandLength = uniformRadius * (0.25f + (i % 6) * 0.08f);
            gluCylinder(hairStrand, uniformRadius * 0.02f, uniformRadius * 0.005f, strandLength, 8, 1);
            gluDeleteQuadric(hairStrand);
            glPopMatrix();
        }

        glPopMatrix();
        glPopMatrix();
    }

    // Function to render status text on screen
    void renderStatusText() {
        if (!showStatus) return;
        
        // Save the current matrix state
        glMatrixMode(GL_PROJECTION);
        glPushMatrix();
        glLoadIdentity();
        gluOrtho2D(0, 1024, 0, 768);
        
        glMatrixMode(GL_MODELVIEW);
        glPushMatrix();
        glLoadIdentity();
        
        // Disable lighting for text rendering
        glDisable(GL_LIGHTING);
        glDisable(GL_DEPTH_TEST);
        
        // Set text color to white
        glColor3f(1.0f, 1.0f, 1.0f);
        
        // Position text at top left corner
        glRasterPos2i(10, 740);
        

        
        // Restore lighting and depth test
        glEnable(GL_LIGHTING);
        glEnable(GL_DEPTH_TEST);
        
        // Restore matrices
        glMatrixMode(GL_PROJECTION);
        glPopMatrix();
        
        glMatrixMode(GL_MODELVIEW);
        glPopMatrix();
    }

    void drawFurStrand(float length, float thickness, float curvature) {
        const int strandSegments = 3;  // Reduced for simplicity

        for (int i = 0; i < strandSegments; i++) {
            float t = (float)i / strandSegments;

            // Apply slight curvature
            float bend = sinf(t * PI * curvature) * length * 0.1f;

            glPushMatrix();
            glTranslatef(bend, 0, t * length);

            float currentThickness = thickness * (1.0f - t * 0.3f);

            GLUquadric* strand = gluNewQuadric();
            gluQuadricNormals(strand, GLU_SMOOTH);
            gluCylinder(strand, currentThickness, currentThickness * 0.9f, length / strandSegments, 6, 1);
            gluDeleteQuadric(strand);

            glPopMatrix();
        }
    }

    void drawMuscleDefinition(float radius, float length, float t) {
        // Subtle muscle definition using same base color, just slightly darker
        glColor3f(0.55f, 0.40f, 0.25f);  // Slightly darker version of main color

        for (int i = 0; i < 4; i++) {
            float angle = i * PI / 2.0f;
            float muscleX = cosf(angle) * radius * 0.95f;
            float muscleY = sinf(angle) * radius * 0.95f;

            glPushMatrix();
            glTranslatef(muscleX, muscleY, 0);

            GLUquadric* muscle = gluNewQuadric();
            gluSphere(muscle, radius * 0.05f, 6, 6);
            gluDeleteQuadric(muscle);

            glPopMatrix();
        }

        // Restore main tail color
        glColor3f(0.65f, 0.50f, 0.35f);
    }

